<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>单片机复习-08</title>
    <link href="/2022/06/11/%E5%8D%95%E7%89%87%E6%9C%BA%E5%A4%8D%E4%B9%A0-08/"/>
    <url>/2022/06/11/%E5%8D%95%E7%89%87%E6%9C%BA%E5%A4%8D%E4%B9%A0-08/</url>
    
    <content type="html"><![CDATA[<h3 id="stm32串口通信">STM32串口通信</h3><p>STM3210RBT6最多可以提供3路串口，有分数波特率发生器、支持同步単信通信和半双工单线通信、支持LIN、支持调制解调器操作，智能卡协议和IrDASIR ENDEC 规范、具有DMA等。接下来从寄存器层次，告诉你如何设置串口，以达到我们最基本的通信功能。在端口复用中提到过，对于复用功能的IO口，首先要使能GPIO的时钟源，然后再使能复用功能时钟，同时要把GPIO模式设置为复用功能对应的模式（这个可以查看手册），这些准备工作做完之后，对串口参数的是初始化设置，包括波特率，停止位等等参数，在设置完成之后，就是使能串口。同时开启串口的终端，当然要初始化NVIC设置的中断优先级别，最后编写中断服务函数。串口设置的一般步骤可以总结为如下几个步骤：1.串口时钟使能，GPIO时钟使能 2.串口复位 3.GPIO端口模式设置4.串口参数初始化 5.开启中断并且初始化NVIC（如果开启中断才需要这个步骤）6.使能串口 7.编写中断处理函数接下介绍几个与串口基本配置直接相关的寄存器。1.串口时钟使能。串口作为单片机的一个外设，其时钟由外设时钟使能寄存器控制，这里我们使用的串口1是在APB2ENR寄存器的第14位。注意一点：除了串口1的时钟在APB2ENR寄存器，其余串口的时钟使能位都在APB1ENR寄存器。</p><p>2.串口波特率设置，STM32的每一个串口都有自己独立的波特率起存器USART_BRR,通过设置该寄存器就可以达到配置不同波特率的目的。<imgsrc="C:\Users\ARIES\hexo-blog\source_posts\单片机复习-08\image-20220611141447904.png"alt="image-20220611141447904" /></p><p>STM32采用了分数波特率，USART_BRR的最低4位用来存放小数部分DIV_Fraction,紧挨着的12位用来存放整数部分DIV_Mantissa，最高16位未使用。在这里介绍一下波特率的计算，STM32的串口波特率计算公式如下：、</p><figure><imgsrc="C:\Users\ARIES\hexo-blog\source_posts\单片机复习-08\image-20220611141836918.png"alt="image-20220611141836918" /><figcaption aria-hidden="true">image-20220611141836918</figcaption></figure><p>上式中$f_{pclk}$是给串口的时钟（PCLK1用于USART2、3、4、5，PCLK2用于USART1）;USARTDIV是一个无符号定点数。我们由已经知道的波特率和PCLKx的时钟，可求的它的值，在串口1的BRR寄存器中设置即可得到所需的波特率。</p><p>3.串口控制。STM32F1的每个串口都有3个控制USART_CR1~3，串口的很多功能都是通过配置这3个寄存器来设置的。</p><figure><imgsrc="C:\Users\ARIES\hexo-blog\source_posts\单片机复习-08\image-20220611143521706.png"alt="image-20220611143521706" /><figcaption aria-hidden="true">image-20220611143521706</figcaption></figure><p>该寄存器的高16位没有用到，低16位用于串口的功能设置。UE为串口使能位，通过该位置1，以使能串口：M为字节选择位，当该位为0的时候设置串口为8个字外加n个停止位，停止位的个数（n）是根据USART_CR2 的[13:12]位设置来决定的，默认为 0；PCE 为校验 使能位，设置为0，则禁止校验，否则使能校验：PS 为校验位选择位，设置为 0 则为偶校验，否则为奇校验；TXEIE 为发送缓冲区中断使能位，设置该位为 1，当 USART_SR中的 TXE 位 为 1 时，将产生串口中断；TCIE为发送完成中断使能位，设置该位为 1，当 USART_SR 中的 TXE 位为 1时，将产生串口中断；RXNEIE 为接收缓冲区非空中断使能，设置该位为 1，当USART_SR 中的 ORE 或者 RXNE 位为 1 时，将产生串口中断；TE为发送使能位，设置为 1， 将开启串口的发送功能：RE 为接收使能位，用法同TE。</p><p>4.数据发送与接收 STM32F1 的发送与接收是通过数据寄存器 USART_DR来实现的，这 是一个双寄存器，包含了 TDR 和 RDR。当向 DR寄存器写数据的时候，实际是写入 TDR，串口就会自动发送数据：当收到数据，读 DR 寄存器的时候，实际读取的是RDR。TDR 和 RDR 对外是不可见的，所以我们操作的就只有 DR 寄存器<imgsrc="C:\Users\ARIES\hexo-blog\source_posts\单片机复习-08\image-20220611143907536.png"alt="image-20220611143907536" /></p><p>5.串口状态。串口的状态可以通过状态寄存器USART-SR读取。USART_SR的各位如下</p><figure><imgsrc="C:\Users\ARIES\hexo-blog\source_posts\单片机复习-08\image-20220611144302913.png"alt="image-20220611144302913" /><figcaption aria-hidden="true">image-20220611144302913</figcaption></figure><p>RXNE(读数据寄存器非空)，当该位被置1的时候，就是提示已经有数据被接受到了，并且可以读出来了，这时候我们要做就是尽快读取USART_DR,通过读USART_DR可以将该位置0</p><p>接下来看看HAL库提供的串口相关函数。</p><p>1.串口参数初始化（波特率、停止位等），并使能串口<code>HAL_StatusTypeDef HAL_UART_Init(UART_HandlerTypeDef *huart)</code>该函数只有一个入口参数huart，为UART_handleTypeDef结构体指针类型，我们俗称其为串口句柄，它的使用会贯穿这个串口程序，一般情况下，我们会定义一个UART_HandleTypeDef结构体类型全局变量，然后初始化各个成员变量。结构体USART_HandleTypeDef的定义。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span></span><br><span class="hljs-class">&#123;</span><br> USART_TypeDef                 *Instance; <br> UART_InitTypeDef              Init; <br> <span class="hljs-type">uint8_t</span>                       *pTxBuffPtr; <br> <span class="hljs-type">uint16_t</span>                      TxXferSize; <br> __IO <span class="hljs-type">uint16_t</span>                 TxXferCount; <br> <span class="hljs-type">uint8_t</span>                       *pRxBuffPtr; <br> <span class="hljs-type">uint16_t</span>                       RxXferSize; <br> __IO <span class="hljs-type">uint16_t</span>                  RxXferCount; <br> DMA_HandleTypeDef              *hdmatx; <br> DMA_HandleTypeDef              *hdmarx; <br> HAL_LockTypeDef                Lock; <br> __IO HAL_UART_StateTypeDef     gState; <br> __IO HAL_UART_StateTypeDef     RxState; <br> __IO <span class="hljs-type">uint32_t</span>                  ErrorCode; <br>&#125;UART_HandleTypeDef;<br></code></pre></td></tr></table></figure><p>​该结构体成员变量非常多，一般情况下载调用HAL_UART_Init对串口进行初始化的时候，我们只需要先设置Instance和Init两个成员变量的值。Instance是USART_TypeDef结构体指针变量类型变量，它执行寄存器基地址，实际上这个基地址HAL库已经定义好了，如果是串口1，取值为USART1即可。Init是UART_InitTypeDef结构体类型变量，它是用来设置串口的各个参数，包括波特率，停止位等</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span></span><br><span class="hljs-class">&#123;</span><br> <span class="hljs-type">uint32_t</span> BaudRate; <span class="hljs-comment">//波特率</span><br> <span class="hljs-type">uint32_t</span> WordLength; <span class="hljs-comment">//字长</span><br><span class="hljs-type">uint32_t</span> StopBits; <span class="hljs-comment">//停止位</span><br><span class="hljs-type">uint32_t</span> Parity; <span class="hljs-comment">//奇偶校验</span><br><span class="hljs-type">uint32_t</span> Mode; <span class="hljs-comment">//收/发模式设置</span><br><span class="hljs-type">uint32_t</span> HwFlowCtl; <span class="hljs-comment">//硬件流设置</span><br><span class="hljs-type">uint32_t</span> OverSampling; <span class="hljs-comment">//过采样设置</span><br>&#125;UART_InitTypeDef;<br></code></pre></td></tr></table></figure><p>pTxBuddPtr，TxXferSize 和 TxXferCout三个变量分别用来设置串口发送的数据缓存指针，发送的数据量和还剩余的要发送的数据量。而接下来的三个变量pRxBuffPtr，RxXferSize 和 RxXferCount则是用来设置接收的数据缓存指针，接收的最大数据量以及还剩余的要接收的数据量。这六个变量是 HAL 库处理中间变量 hdmatx 和 hdmarx 是串口 DMA相关的变量，指向 DMA 句柄. 其他的三个变量就是一些 HAL库处理过程状态标志位和串口通信的错误码。</p><p>函数 HAL_UART_Init使用的一般格式为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c">UART_HandleTypeDef UART1_Handler; <span class="hljs-comment">//UART 句柄</span><br><br>UART1_Handler.Instance=USART1; <span class="hljs-comment">//USART1</span><br>UART1_Handler.Init.BaudRate=bound; <span class="hljs-comment">//波特率</span><br>UART1_Handler.Init.WordLength=UART_WORDLENGTH_8B; <span class="hljs-comment">//字长为 8 位数据格式</span><br>UART1_Handler.Init.StopBits=UART_STOPBITS_1; <span class="hljs-comment">//一个停止位</span><br>UART1_Handler.Init.Parity=UART_PARITY_NONE; <span class="hljs-comment">//无奇偶校验位</span><br>UART1_Handler.Init.HwFlowCtl=UART_HWCONTROL_NONE; <span class="hljs-comment">//无硬件流控</span><br>UART1_Handler.Init.Mode=UART_MODE_TX_RX; <span class="hljs-comment">//收发模式</span><br>HAL_UART_Init(&amp;UART1_Handler); <span class="hljs-comment">//HAL_UART_Init()会使能 UART</span><br></code></pre></td></tr></table></figure><p>这里需要说明的是，函数HAL_UART_Init内部会调用串口使能函数使能相应串口，所以无需再次重复使能串口，当然HAL库也提供了具体的串口使能和关闭方法，具体使用方法如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">__HAL_UART_ENABLE(handler)；<span class="hljs-comment">//使能句柄 handler 指定的串口</span><br>__HAL_UART_DISABLE(handler)；<span class="hljs-comment">//关闭句柄 hander 指定的串口</span><br></code></pre></td></tr></table></figure><p>串口作为一个重要的外设，在调用的初始化函数HAL_UART_Init内部，会先调用MSP初始化回调函数进行MCU相关的初始化，函数为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">HAL_UART_MspInit</span><span class="hljs-params">(UART_HandleTypeDef* huart)</span>;<br></code></pre></td></tr></table></figure><p>我们在程序中，只需要重新写该函数即可。一般情况下，该函数内部用来编写IO口初始化，时钟使能以及NVIC配置。</p><p>2.使能串口和GPIO口时钟我们使用串口，我们必须使能串口时钟和使用到的GPIO口时钟。例如我们要使用串口1，我们必须使能串口1时钟和GPIO时钟（串口1使用的是PA9和PA10）。具体方案如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">__HAL_RCC_USART1_CLK_ENABLE()；<span class="hljs-comment">//使能 USART1 时钟</span><br>__HAL_RCC_GPIOA_CLK_ENABLE()；<span class="hljs-comment">//使能 GPIOA 时钟</span><br></code></pre></td></tr></table></figure><p>3.GPIO口初始化设置（速度，上下拉等）以及复用映射配置在HAL库中IO口初始化参数设置和复用映射配置是在函数HAL_GPIO_Init中一次性完成的，我们需要复用PA9和PA10为串口发送接收相关引脚，我们需要配置IO口为复用，同时复用映射到串口1。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c">GPIO_InitTypeDef GPIO_Initure；<br><br>GPIO_Initure.Pin = GPIO_PIN_9;<br>GPIO_Initure.Mode=GPIO_MODE_AF_PP; <span class="hljs-comment">//复用推挽输出</span><br>GPIO_Initure.Pull=GPIO_PULLUP; <span class="hljs-comment">//上拉</span><br>GPIO_Initure.Speed=GPIO_SPEED_FREQ_HIGH;<span class="hljs-comment">//高速</span><br>HAL_GPIO_Init(GPIOA,&amp;GPIO_Initure); <span class="hljs-comment">//初始化 PA9</span><br><br>GPIO_Initure.Pin=GPIO_PIN_10; <span class="hljs-comment">//PA10</span><br>GPIO_Initure.Mode=GPIO_MODE_AF_INPUT;<span class="hljs-comment">//模式要设置为复用输入模式！</span><br>HAL_GPIO_Init(GPIOA,&amp;GPIO_Initure); <span class="hljs-comment">//初始化 PA1</span><br></code></pre></td></tr></table></figure><p>4.开启串口相关中断，配置串口中断优先级HAL库中定义了一个使能串口中断的标识符_HAL_UART_ENABLE_IT，可以把它当一个函数来使用，</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">__HAL_UART_ENABLE_IT(huart,UART_IT_RXNE); <span class="hljs-comment">//开启接收完成中断</span><br></code></pre></td></tr></table></figure><p>第一个参数为我们步骤 1 讲解的串口句柄，类型为 UART_HandleTypeDef结构体类型。第 二个参数为我们要开启的中断类型值，可选值在头文件stm32f1xx_hal_uart.h 中有宏定义。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">__HAL_UART_DISABLE_IT(huart,UART_IT_RXNE); <span class="hljs-comment">//关闭接收完成中断</span><br></code></pre></td></tr></table></figure><p>对于设置优先级，方法也很简单</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">HAL_NVIC_EnableIRQ(USART1_IRQn); <span class="hljs-comment">//使能 USART1 中断通道</span><br>HAL_NVIC_SetPriorty(USART1_IRQn,<span class="hljs-number">3</span>,<span class="hljs-number">3</span>); <span class="hljs-comment">//抢占优先级 3，子优先级 3</span><br></code></pre></td></tr></table></figure><p>5.编写中断服务函数串口1的服务中断函数为：<code>void USART1_IRQHandler(void);</code>当发生中断的时候，程序就会执行中断服务函数。我们在中断服务函数中编写相应的逻辑代码即可。</p><p>6.串口数据接收和发送 STM32F1 的发送与接收是通过数据寄存器 USART_DR来实现的，这是一个双寄存器，包 含了 TDR 和RDR。当向该寄存器写数据的时候，串口就会自动发送，当收到数据的时候，也是存在该寄存器内。HAL 库操作 USART_DR 寄存器发送数据的函数是：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">HAL_StatusTypeDef <span class="hljs-title function_">HAL_UART_Transmit</span><span class="hljs-params">(UART_HandleTypeDef*huart</span><br><span class="hljs-params"><span class="hljs-type">uint8_t</span>*pData,<span class="hljs-type">uint16_t</span> Size,<span class="hljs-type">uint32_t</span> Timeout)</span>;<br></code></pre></td></tr></table></figure><p>通过该函数向串口寄存器 USART_DR 写入一个数据。 HAL 库操作 USART_DR寄存器读取串口接收到的数据的函数是：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">HAL_StatusTypeDef <span class="hljs-title function_">HAL_UART_Receive</span><span class="hljs-params">(UART_Handler TypeDef*huart,</span><br><span class="hljs-params"><span class="hljs-type">uint8_t</span>*pData,<span class="hljs-type">uint16_t</span> Size,<span class="hljs-type">uint32_t</span> Timeout)</span>;<br></code></pre></td></tr></table></figure><p>通过该函数可以读取串口接收到的数据。</p><p>和其他外设一样，HAL库为串口的使用开放了MSP函数。在串口初始化函数HAL_UART_Init内部，会调用串口MSP函数HAL_UART_Mspinot来设置与MCU相关的配置。这里我们定义一个函数uart_Init用来调用HAL_UART_Init初始化串口参数配置，具体函数如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c">UART_HandleTypeDef   UART1_Handler;<span class="hljs-comment">//UART句柄</span><br><br><span class="hljs-comment">//初始化IO串口1</span><br><span class="hljs-comment">// bound:波特率</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">uart_init</span><span class="hljs-params">(u32 bound)</span><br>&#123;<br><span class="hljs-comment">//UART 初始化设置</span><br>    UART1_Handler.Instance=USART1;<span class="hljs-comment">//USART1</span><br>    UART1_Handler.Init.BaudRate=bound; <span class="hljs-comment">//波特率</span><br>UART1_Handler.Init.WordLength=UART_WORDLENGTH_8B; <span class="hljs-comment">//字长为 8 位数据格式</span><br>UART1_Handler.Init.StopBits=UART_STOPBITS_1; <span class="hljs-comment">//一个停止位</span><br>    UART1_Handler.Init.Parity=UART_PARITY_NONE; <span class="hljs-comment">//无奇偶校验位</span><br>UART1_Handler.Init.HwFlowCtl=UART_HWCONTROL_NONE; <span class="hljs-comment">//无硬件流控</span><br>UART1_Handler.Init.Mode=UART_MODE_TX_RX; <span class="hljs-comment">//收发模式</span><br>HAL_UART_Init(&amp;UART1_Handler); <span class="hljs-comment">//HAL_UART_Init()会使能 UART1</span><br>HAL_UART_Receive_IT(&amp;UART1_Handler, (u8 *)aRxBuffer, RXBUFFERSIZE);<br><span class="hljs-comment">//该函数会开启接收中断：标志位 UART_IT_RXNE，并且设置接收缓冲以及接收缓冲</span><br><span class="hljs-comment">//接收最大数据量</span><br><br><br>&#125;<br></code></pre></td></tr></table></figure><p>最后一行代 码调用函数HAL_UART_Receive_IT，作用是开启接收中断，同时设置接收的缓存区以及接收的数据量。 串口 MSP 函数 HAL_UART_MspInit函数我们自定义了其内容，代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">HAL_UART_MspInit</span><span class="hljs-params">(UART_HandleTypeDef *huart)</span><br>&#123;<br>    <span class="hljs-comment">// GPIO 端口设置</span><br>    GPIO_InitTypeDef GPIO_Initure;<br>    <span class="hljs-keyword">if</span> (huart-&gt;Instance == USART1) <span class="hljs-comment">//如果是串口 1，进行串口 1 MSP 初始化</span><br>    &#123;<br>        __HAL_RCC_GPIOA_CLK_ENABLE();  <span class="hljs-comment">//使能 GPIOA 时钟</span><br>        __HAL_RCC_USART1_CLK_ENABLE(); <span class="hljs-comment">//使能 USART1 时钟</span><br>        __HAL_RCC_AFIO_CLK_ENABLE();<br>        GPIO_Initure.Pin = GPIO_PIN_9;             <span class="hljs-comment">// PA9</span><br>        GPIO_Initure.Mode = GPIO_MODE_AF_PP;       <span class="hljs-comment">//复用推挽输出</span><br>        GPIO_Initure.Pull = GPIO_PULLUP;           <span class="hljs-comment">//上拉</span><br>        GPIO_Initure.Speed = GPIO_SPEED_FREQ_HIGH; <span class="hljs-comment">//高速</span><br>        HAL_GPIO_Init(GPIOA, &amp;GPIO_Initure);       <span class="hljs-comment">//初始化 PA9</span><br>        GPIO_Initure.Pin = GPIO_PIN_10;            <span class="hljs-comment">// PA10</span><br>        GPIO_Initure.Mode = GPIO_MODE_AF_INPUT;    <span class="hljs-comment">//模式要设置为复用输入模式！</span><br>        HAL_GPIO_Init(GPIOA, &amp;GPIO_Initure);       <span class="hljs-comment">//初始化 PA10</span><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> EN_USART1_RX</span><br>        HAL_NVIC_EnableIRQ(USART1_IRQn);         <span class="hljs-comment">//使能 USART1 中断通道</span><br>        HAL_NVIC_SetPriority(USART1_IRQn, <span class="hljs-number">3</span>, <span class="hljs-number">3</span>); <span class="hljs-comment">//抢占优先级 3，子优先级 3</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在该段 代码中，通过判断宏定义标识符 EN_USART1_RX的值来确定是否开启串口中断通道和设置串口 1 中断优先级。标识符EN_USART1_RX 在头文件 usart.h 中有定义，默认情况下我们设置为 1。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> EN_USART1_RX 1 <span class="hljs-comment">//使能（1）/禁止（0）串口 1 接收</span></span><br></code></pre></td></tr></table></figure><p>​通过上面两个函数，我们就配置了串口相关设置，接下来就是编写中断服务函数USART1_IRQHandler。在HAL库中，对中断函数的编写有非常严格的讲究。</p><p>首先HAL库定义了一个<strong>串口中断处理通用函数</strong>HAL_UART_IRQHandler，该函数声明如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">HAL_UART_IRQHandler</span><span class="hljs-params">(UART_HandleTypeDef*huart)</span>;<br></code></pre></td></tr></table></figure><p>该函数只有一个入口参数就是 UART_HandleTypeDef结构体指针类型的串口句柄 huart，使我们在调用 HAL_UART_Init函数时需要设置的同一个变量即可。该函数一般在中断服务函数中调用，作为串口中断处理的通用入口。一般调用方法为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">USART1_IRQHandler</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>HAL_UART_IRQHandler(&amp;UART1_Handler);<span class="hljs-comment">//调用 HAL 库中断处理公用函数</span><br>....<span class="hljs-comment">//中断处理完成后的结束工作</span><br>&#125;<br></code></pre></td></tr></table></figure><p>也就是说，真正的串口中断处理逻辑在函数HAL_UART_IRQHandler内部执行，用户一般不能随意修改。因为本章实验我们主要实现的是串口中断接收，也就是每次收到一个字符后进入中断服务函数来处理，下面仅仅列出串口中断执行流程中与接收相关的源码。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">HAL_UART_IRQHandler</span><span class="hljs-params">(UART_HandleTypeDef *huart)</span><br>&#123;<br>    <span class="hljs-type">uint32_t</span> isrflags = READ_REG(huart-&gt;Instance-&gt;SR);<br>    <span class="hljs-type">uint32_t</span> cr1its = READ_REG(huart-&gt;Instance-&gt;CR1);<br>    <span class="hljs-type">uint32_t</span> cr3its = READ_REG(huart-&gt;Instance-&gt;CR3);<br>    <span class="hljs-type">uint32_t</span> errorflags = <span class="hljs-number">0x00</span>U;<br>    <span class="hljs-type">uint32_t</span> dmarequest = <span class="hljs-number">0x00</span>U;<br>    errorflags = (isrflags &amp; (<span class="hljs-type">uint32_t</span>)(USART_SR_PE | USA RT_SR_FE | USART_SR_ORE | USART_SR_NE));<br>    <span class="hljs-keyword">if</span> (errorflags == RESET)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (((isrflags &amp; USART_SR_RXNE) != RESET) &amp;&amp;<br>            ((cr1its &amp; USART_CR1_RXNEIE) != RESET))<br>        &#123;<br>            UART_Receive_IT(huart);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>    &#125;<br>    ... <span class="hljs-comment">//此处省略部分代码</span><br>&#125;<br><br></code></pre></td></tr></table></figure><p>从代码逻辑可以看出，在函数 HAL_UART_IRQHandler内部通过判断中断类型<strong>是否为接收完成中断</strong>，确定是否调用HAL 另外一个函数 UART_Receive_IT()。函数 UART_Receive_IT()的作用是把<strong>每次中断接收到的字符保存在串口句柄的缓存指针 pRxBuffPtr中</strong>，同时每次接收一个字符，其计数器 RxXferCount 减1，直到接收完成 RxXferSize个字符之后 RxXferCount 设置为0，同时调用接收完成回调函数 HAL_UART_RxCpltCallback进行处理。为了篇幅考虑，这里我们仅列出 UART_Receive_IT()函数调用回调函数HAL_UART_RxCpltCallback 的处理逻辑，代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> HAL_StatusTypeDef <span class="hljs-title function_">UART_Receive_IT</span><span class="hljs-params">(UART_HandleTypeDef*huart)</span><br>&#123;<br> ...<span class="hljs-comment">//此处省略部分代码</span><br><span class="hljs-keyword">if</span>(--huart-&gt;RxXferCount == <span class="hljs-number">0U</span>)<br>&#123;<br> ...<span class="hljs-comment">//此处省略部分代码</span><br> HAL_UART_RxCpltCallback(huart);<br>&#125;<br>...<span class="hljs-comment">//此处省略部分代码</span><br>&#125;<br></code></pre></td></tr></table></figure><figure><imgsrc="C:\Users\ARIES\hexo-blog\source_posts\单片机复习-08\image-20220611165716638.png"alt="image-20220611165716638" /><figcaption aria-hidden="true">image-20220611165716638</figcaption></figure><p>对其进行概括：当接收到一个字符之后，在函数UART_Receive_IT中会把数据保存在串口句柄的成员变量pRxBuffPtr缓存中，同时RxXferCount计数器减1。如果我们设置 RxXferSize=10，那么当接收到 10 个字符之后，RxXferCount会由 10 减到 0（RxXferCount 初始值等于RxXferSize），这个时候再调用接收完成回调函数 HAL_UART_RxCpltCallback进行处理。</p><p>​ HAL 库定义的串口中断逻辑确实非常复杂，并且因为处理过程繁琐所以效率不高。这里我们需要说明的是，在中断服务函数中，大家也可以不用调用HAL_UART_IRQHandler 函数，而是直接编写自己的中断服务函数。</p><p>如果我们不用中断处理回调函数，那么就不用初始化串口句柄的中断接收缓存，所以我们HAL_UART_Receive_IT函数就不用出现在初始化函数uart_init中，而是直接在要开启中断的地方调用_HAL_UART_ENABLE_IT单独开启中断即可，如果不用中断回调函数，中断服务函数内容为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//串口1中断服务函数</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">USART1_IRQHandler</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>u8 Res;<br>    HAL_StatusTypeDef err;<br>    <span class="hljs-meta">#<span class="hljs-keyword">if</span> SYSTEM_SUPPORT_OS <span class="hljs-comment">//使用OS</span></span><br>    OSIntEnter();<br>    <span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>    <span class="hljs-keyword">if</span>((__HAL_UART_GET_FLAG(&amp;UART1_Handler,UART_FLAG_RXNE)!=RESET)) <br><span class="hljs-comment">//接收中断(接收到的数据必须是 0x0d 0x0a 结尾)</span><br>    &#123;<br>        Res=USART1-&gt;DR;<br>        <span class="hljs-keyword">if</span>((USART_RX_STA&amp;<span class="hljs-number">0x8000</span>)==<span class="hljs-number">0</span>)<span class="hljs-comment">//接收未完成</span><br>        &#123;<br>            <span class="hljs-keyword">if</span>(USART_RX_STA&amp;<span class="hljs-number">0x4000</span>)<span class="hljs-comment">//接收到了0x0d</span><br>            &#123;<br>                <span class="hljs-keyword">if</span>(Res!=<span class="hljs-number">0x0a</span>)USART_RX_STA=<span class="hljs-number">0</span>;<span class="hljs-comment">//接收错误,重新开始</span><br>    <span class="hljs-keyword">else</span> USART_RX_STA|=<span class="hljs-number">0x8000</span>; <span class="hljs-comment">//接收完成</span><br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                <span class="hljs-keyword">if</span>(Res==<span class="hljs-number">0x0d</span>)USART_RX_STA|=<span class="hljs-number">0x4000</span>;<br>                <span class="hljs-keyword">else</span><br>                &#123;<br>                    USART_RX_BUF[USART_RX_STA&amp;<span class="hljs-number">0X3FFF</span>]=Res;<br>   USART_RX_STA++;<br>                    <span class="hljs-keyword">if</span>(USART_RX_STA&gt;(USART_REC_LEN<span class="hljs-number">-1</span>))USART_RX_STA=<span class="hljs-number">0</span>;<br>                    <span class="hljs-comment">//接收数据错误,重新开始接收 </span><br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>    HAL_UART_IRQHandler(&amp;UART1_Handler);<br>    <span class="hljs-meta">#<span class="hljs-keyword">if</span> SYSTEM_SUPPORT_OS <span class="hljs-comment">//使用 OS</span></span><br>     OSIntExit(); <br>    <span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>&#125;<br></code></pre></td></tr></table></figure><p>这段代码逻辑跟上面的中断回调函数类似，只不过这里还需要通过 HAL库串口接收函数 HAL_UART_Receive来获取接收到的字符进行相应的处理，这里我们就不做过多的讲解。</p><p>HAL库一共提供了5个中断处理回调函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">HAL_UART_TxCpltCallback</span><span class="hljs-params">(UART_HandleTypeDef*huart)</span>;<span class="hljs-comment">//发送完成回调函数</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">HAL_USART_TxHalfCpltCallback</span><span class="hljs-params">(USART_HandleTypeDef *husart)</span>;<span class="hljs-comment">//发送完成过半</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">HAL_UART_RxCpltCallback</span><span class="hljs-params">(UART_HandleTypeDef*huart)</span>;<span class="hljs-comment">//接收完成回调函数</span><br>Void <span class="hljs-title function_">HAL_UART_RxHalfCpltCallbackk</span><span class="hljs-params">(UART_HandleTypeDef*huart)</span>;<span class="hljs-comment">//接收完成过半</span><br>Void <span class="hljs-title function_">HAL_UART_ErrorCallback</span><span class="hljs-params">(UART_HandleTypeDef*huart)</span>;<span class="hljs-comment">//错误处理回调函数</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>串口通信</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>单片机复习-07</title>
    <link href="/2022/06/10/%E5%8D%95%E7%89%87%E6%9C%BA%E5%A4%8D%E4%B9%A0-07/"/>
    <url>/2022/06/10/%E5%8D%95%E7%89%87%E6%9C%BA%E5%A4%8D%E4%B9%A0-07/</url>
    
    <content type="html"><![CDATA[<h3 id="按键输入实验">按键输入实验</h3><p>前一节介绍STM32的IO口作为输出的使用，这一节向大家介绍如何使用STM32的IO口作为输入用，利用板载的4个按键，来控制板载的两个LED的亮灯。</p><p><strong><imgsrc="C:\Users\ARIES\hexo-blog\source\images\image-20220610183415589.png"alt="image-20220610183415589" /></strong></p><p>注意：KEY0、KEY1、KEY2都是低电平有效，而KEY_UP是高电平有效的，而且外部都没有上下拉电阻，所以需要在STM32内部设置上下拉。</p><p>首先先看一下key.c文件</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;key.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;sys.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;delay.h&quot;</span></span><br><span class="hljs-comment">//按键初始化函数</span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">KEY_Init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><span class="hljs-comment">//IO初始化</span><br>&#123;<br>    GPIO_InitTypeDef GPIO_Initure;<br>    _HAL_RCC_GPIOA_CLK_ENABLE();<br>    _HAL_RCC_GPIOC_CLK_ENABLE();<br>    _HAL_RCC_GPIOD_CLK_ENABLE();<br>    <br><br>    GPIO_Initure.Pin=GPIO_PIN_0;<span class="hljs-comment">//PA0</span><br>    GPIO_Initure.Mode=GPIO_MODE_INPUT;<span class="hljs-comment">//输入</span><br>    GPIO_Initure.Pull=GPIO_PULLDOWN;<span class="hljs-comment">//下拉</span><br>    GPIO_Initure.Speed=GPIO_SPEED_HIGH;<span class="hljs-comment">//高速</span><br>    HAL_GPIO_Init(GPIOA,&amp;GPIO_Initure);<br><br>    GPIO_Initure.Pin=GPIO_PIN_8|GPIO_PIN_9;<br>    GPIO_Initure.Mode=GPIO_MODE_INPUT;<br>    GPIO_Initure.Pull=GPIO_PULLUP;<br>    GPIO_Initure.Speed=GPIO_SPEED_HIGH;<br>    HAL_GPIO_Init(GPIOC,&amp;GPIO_Initure);<br><br><br><br>    GPIO_Initure.Pin=GPIO_PIN_2;<br>    GPIO_Initure.Mode=GPIO_MODE_INPUT;<br>    GPIO_Initure.Pull=GPIO_PULLUP;<br>    HAL_GPIO_Init(GPIOD,&amp;GPIO_Initure);<br><br>&#125;<br><br><span class="hljs-comment">//按键处理函数</span><br><span class="hljs-comment">//返回按键值</span><br><span class="hljs-comment">// mode0 :不支持连按；mode1：支持连按</span><br><span class="hljs-comment">// 返回值 0 没有任何按键按下</span><br><span class="hljs-comment">// KEY0_PRES、KEY1_PRES分别表示 按键0 和1 按下</span><br><span class="hljs-comment">// 注意次函数有优先级；KEY0&gt;KEY1&gt;KEY2&gt;KEY_UP</span><br><br>u8 <span class="hljs-title function_">KEY_Scan</span><span class="hljs-params">(u8 mode)</span><br>&#123;<br>    <span class="hljs-type">static</span> u8 key_up=<span class="hljs-number">1</span>;<span class="hljs-comment">//按键松开标志</span><br><br>    <span class="hljs-keyword">if</span>(mode)key_up=<span class="hljs-number">1</span>; <span class="hljs-comment">//支持连按</span><br>    <br>    <span class="hljs-keyword">if</span>(key_up&amp;&amp;(KEY0==<span class="hljs-number">0</span>||KEY1==<span class="hljs-number">0</span>||KEY2==<span class="hljs-number">0</span>||WK_UP==<span class="hljs-number">1</span>))<br>    &#123;<br>        delay_ms(<span class="hljs-number">10</span>);<span class="hljs-comment">//去抖动</span><br>        key_up=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span>(KEY0==<span class="hljs-number">0</span>)<span class="hljs-keyword">return</span> KEY0_PRES;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(KEY0==<span class="hljs-number">0</span>)<span class="hljs-keyword">return</span> KEY0_PRES;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(KEY0==<span class="hljs-number">0</span>)<span class="hljs-keyword">return</span> KEY0_PRES;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(WK_UP==<span class="hljs-number">1</span>)<span class="hljs-keyword">return</span> WK_UP_PRES;<br><br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(KEY0==<span class="hljs-number">1</span>&amp;&amp;KEY1==<span class="hljs-number">1</span>&amp;&amp;KEY2==<span class="hljs-number">1</span>&amp;&amp;WK_UP==<span class="hljs-number">0</span>)key_up=<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>&#125;<br><br></code></pre></td></tr></table></figure><p>分析一下46行处的代码为啥支持连按：假设我们传入mode=0，假设有按键按下，持续一定的低电平时间了（抖动时间过去了），让key_up=0，然后判断此时是哪个键按下去，返回对应的值，如果我们一直按着不放，第二次执行，就会因为key_up在前一次函数执行中已经等于0，所以我们就算按着按键不放也进入不了当参数mode为1，总会执行<code>if(mode)key_up=1</code></p>]]></content>
    
    
    
    <tags>
      
      <tag>IO 口输入</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>单片机复习-06</title>
    <link href="/2022/06/10/%E5%8D%95%E7%89%87%E6%9C%BA%E5%A4%8D%E4%B9%A0-06/"/>
    <url>/2022/06/10/%E5%8D%95%E7%89%87%E6%9C%BA%E5%A4%8D%E4%B9%A0-06/</url>
    
    <content type="html"><![CDATA[<h3 id="跑马灯实验">跑马灯实验</h3><p>Stm32 最简单的<strong>外设</strong>是IO口的高低电平控制，通过跑马灯了解IO口作为输出使用的方法。外设都是通过读写设备上的寄存器来进行的，<strong>外设寄存器也被称为“IO端口”</strong>，<strong>端口是单片机内部CPU和外部IO的接口组</strong>。IO端口有两种编址方式：独立编址和统一编址，暂且不谈。32单片机有多个端口组，每个端口组有16个IO口（引脚）。</p><p>STM32的IO口相比51而言复杂的多，STM32的IO口可以由软件配置成如下8种模式：1、输入浮空 2、输入上拉 3、输出下拉 4、模拟输入 5、开漏输出 6、推挽输出7、推挽式复用功能 8、开漏复用功能</p><p>介绍一下开漏输出和推挽输出<strong>推挽输出</strong>是由2个MOS或者三极管收到互补控制的信号控制，两个管子时钟一个在导通，一个在截止。推挽输出的<strong>最大特点就是可以真正的输出高电平和低电平，在两种电平下都具用驱动能力</strong>，所谓驱动能力就是指<strong>输出电流</strong>的能力。<strong>开漏输出</strong>常被说是与推挽输出相对，开漏输出无法真正的输出高电平，即<strong>高电平的时候没有驱动能力</strong>，需要借助外部上拉电阻完成对外驱动。<imgsrc="C:\Users\ARIES\hexo-blog\source\images\image-20220610153136587.png"alt="image-20220610153136587" /></p><p>每个IO口可以自由编程，但<strong>IO口寄存器必须按32位字被访问</strong>。</p><p>STM32的每个IO口都有7个寄存器来控制：1、配置模式的2个32位的端口配置寄存器CRL和CRH，它们控制每个IO口的模式以及输出速率;2、2个32位数据寄存器IDR和ODR，用于控制GPIOx输出电平；3、1个32位的置位、复位寄存器BSRR; 4、1个16位的复位寄存器BRR;5、1个32位的锁存寄存器LCKR;</p><p>1、STM32的CRL控制每组IO端口的低8位（eg：PA_01~08）的模式，每个IO引脚占用CRL的4个位，高两位的位CNF，低两位的位MODE。这里记住几个常用的配置：0X0 (0b0000)表示模拟输入模式（ADC 用）、 0X3 (0b0011)表示推挽输出模式（做输出口 用，50M 速率）、 0X8 (0b1000)表示上/下拉输入模式（做输入口用）、 0XB (0b1011)表示复用输出（使用 IO 口的第二功能，50M 速率）<imgsrc="C:\Users\ARIES\hexo-blog\source\images\image-20220610161729298.png"alt="image-20220610161729298" /></p><p>CRH的作用和CRL完全一样，CRH控制的是IO端口组的高8位（eg：PA_09~15）</p><p>在HAL库中，操作寄存器CRH和CRL来配置IO口的模式和速度是通过GPIO初始化函数完成的</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">HAL_GPIO_Init</span><span class="hljs-params">(GPIO_TypeDef *GPIOx,GPIO_InitTypeDef *GPIO_Init)</span><br></code></pre></td></tr></table></figure><p>第一个参数是用来初始化指定的GPIO对应的GPIO组，取值范围为GPIOA~GPIOE（tip：这里是根据芯片类型包含的头文件而取的值范围）第二个参数为初始化参数结构体指针，结构体类型为GPIO_InitTypeDef，指定引脚的参数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-type">uint32_t</span> Pin;<span class="hljs-comment">//指定IO口</span><br><span class="hljs-type">uint32_t</span> Mode;<span class="hljs-comment">//模式设置</span><br><span class="hljs-type">uint32_t</span> Pull;<span class="hljs-comment">//上下拉设置</span><br><span class="hljs-type">uint32_t</span> Speed;<span class="hljs-comment">//速度设置</span><br>&#125;GPIO_InitTypeDef;<br></code></pre></td></tr></table></figure><p>2.看完的GPIO的参数配置寄存器，接下来是<strong>GPIO输入输出电平控制</strong>相关的寄存器首先先看<strong>ODR寄存器</strong>，该寄存器用于控制GPIOx输出电平<imgsrc="C:\Users\ARIES\hexo-blog\source\images\image-20220610163833080.png"alt="image-20220610163833080" /></p><p>该寄存器用于设置某个IO口（应该就是引脚）输出高电平（ODRy=1）还是低电平，该寄存器也仅在输出模式下有效，在输入模式下不起作用。操作还寄存器的库函数，主要就是HAL_GPIO_TogglePin函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">HAL_GPIO_TogglePin</span><span class="hljs-params">(GPIO_TypeDef* GPIOx,<span class="hljs-type">uint16_t</span> GPIO_Pin)</span>;<br></code></pre></td></tr></table></figure><p>该函数通过操作ODR寄存器，达到取反IO口输出电平的功能。</p><p><strong>置位/复位寄存器(BSSR)</strong>是一个非常重要的寄存器。该寄存器和ODR寄存器具有类似的作用，都可以设置GPIO端口（引脚）的输出是1还是0。<imgsrc="C:\Users\ARIES\hexo-blog\source\images\image-20220610164910406.png"alt="image-20220610164910406" /></p><p>上表中，BSSR低16位设置1对应引脚（0~16）为高电平，高16位设置1对应引脚（0-16）为低电平。取0无效。BSSR寄存器使用方法如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">GPIOA-&gt;BSRR=<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">1</span>;<span class="hljs-comment">//GPIOA的寄存器BSRR把1的值从0位移动到1位，所以是设置GPIOA.1为高电平</span><br>GPIOA-&gt;BSRR=<span class="hljs-number">1</span>&lt;&lt;(<span class="hljs-number">16</span>+<span class="hljs-number">1</span>);<span class="hljs-comment">//GPIOA的寄存器BSRR把1的值从0位移动到17位，17位还是对应引脚1，所以是设置GPIOA.1为低电平</span><br></code></pre></td></tr></table></figure><p>库函数操作BSSR寄存器来设置IO电平的函数为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">HAL_GPIO_WritePin</span><span class="hljs-params">(GPIO_TypeDef* GPIOx,<span class="hljs-type">uint16_t</span> GPIO_Pin,GPIO_PinState PinState)</span><br></code></pre></td></tr></table></figure><p>该函数可以用来设置一组IO口（引脚，不在重复）中的一个或者多个IO口的电平状态。</p><p>接下来来看<strong>IDR寄存器</strong>，该寄存器用于读取GPIOx的输入数据，<imgsrc="C:\Users\ARIES\hexo-blog\source\images\image-20220610171410463.png"alt="image-20220610171410463" /></p><p>该寄存器用于读取每个IO口的电平，如果对应的位为0（IRRy=0），则说明IO输入的是低电平，库函数中用于操作该寄存器读取IO输入数据相关函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">GPIO_PinState <span class="hljs-title function_">HAL_GPIO_ReadPin</span><span class="hljs-params">(GPIO_TypeDef* GPIOx，<span class="hljs-type">uint16_t</span> GPIO_Pin)</span>;<br></code></pre></td></tr></table></figure><p>该函数用来读取一组IO口中一个或者多个IO口电平状态。该函数的返回值就是IO口电平状态。</p><p><strong>GPIO操作总结</strong> 1、使能IO口时钟，调用函数为<code>_HAL_RCC_GPIOX_CLK_ENABLE(其中X=A~E)</code>； 2、操作IO输入输出；3、初始化IO参数，调用函数HAL_GPIO_Init();</p><figure><imgsrc="C:\Users\ARIES\hexo-blog\source\images\image-20220610173656765.png"alt="image-20220610173656765" /><figcaption aria-hidden="true">image-20220610173656765</figcaption></figure><p>在编译信息中可以看到，代码占用FLASH大小为5256字节（4964+292），所用的SRAM大小为1920（1900+20）。Code：表示程序所占用的FLASH的大小。 RO-data：即ReadOnly-data，表示程序定义的常量（FLASH）。 RW-data：即ReadWrite-data，表示已被初始化的变量（SRAM）。 ZI-data：即ZeroInit-data，表示未被初始化的变量（SRAM）。</p>]]></content>
    
    
    
    <tags>
      
      <tag>IO口</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>单片机总结-05</title>
    <link href="/2022/06/07/%E5%8D%95%E7%89%87%E6%9C%BA%E5%A4%8D%E4%B9%A0-05/"/>
    <url>/2022/06/07/%E5%8D%95%E7%89%87%E6%9C%BA%E5%A4%8D%E4%B9%A0-05/</url>
    
    <content type="html"><![CDATA[<p>名词总结：</p><p><strong>AHB，是Advanced High performanceBus的缩写</strong>，译作高级高性能总线，这是一种“系统总线”。AHB主要用于高性能模块(如CPU、DMA和DSP等)之间的连接。AHB系统由主模块、从模块和基础结构(Infrastructure)3部分组成，整个AHB总线上的传输都由主模块发出，由从模块负责回应。</p><p><strong>APB，是Advanced PeripheralBus的缩写</strong>，这是一种外围总线。APB主要用于低带宽的周边外设之间的连接，例如UART、1284等，它的总线架构不像AHB支持多个主模块，在APB里面唯一的主模块就是APB 桥。</p><p><strong>FSMC(Flexible Static MemoryController，可变静态存储控制器)</strong>是STM32系列采用的一种新型的存储器扩展技术。通俗的说，就是用来扩展外部RAM的。</p><p><strong>RTC，英文是Real-timeclock</strong>，翻译过来就是“实时时钟”，即<strong>单片机实时时钟</strong>，指可以像时钟一样输出实际时间的电子设备，一般为集成电路，因此也称为时钟芯片。在电脑主板上，晶振32.768KHz显然是不可或缺的，我们关闭电源之后，再开机，时间日期之所以显示正常是因为我们为它专门提供了一颗纽扣电池供电，可以这样说，<strong>RTC</strong>一直在工作。</p><p><strong>GPIO管脚复用：</strong>32芯片内部集成了很多外设控制器，（USART，ADC，CAN等），这些外设控制器也需要通过引脚与外设连接，复用功能是相对于单片机的引脚而言的，复用功能是指单片机的引脚既可以作为普通的GPIO也可以作为内部外设控制器的引脚来使用。比如F1系列PA5引脚可以作为多个SPI、DAC、ADC的复用引脚，但同一时刻只能选择一种。操作步骤：1.GPIO时钟使能 2.复用的外设时钟使能3.同时要初始化GPIO以及复用外设功能</p><p><strong>端口重映射：</strong>GPIO重映射是原IO映射到其他IO口去，应注意操作步骤：1.使能被重映射IO端口时钟 2.使能被重映射的外设时钟3.使能AFIO复用时钟（重要） 4.进行重映射</p><p><strong>NVIC称为嵌套向量中断控制器NVIC(Nested Vectored InterruptController)</strong>：</p><h3 id="stm32f1-时钟概述">STM32F1 时钟概述</h3><figure><imgsrc="C:\Users\ARIES\hexo-blog\source\images\image-20220607141917444.png"alt="image-20220607141917444" /><figcaption aria-hidden="true">image-20220607141917444</figcaption></figure><p>在STM32中有五个时钟源，为HSI、HSE、LSI、LSE、PLL。从时钟频率来分可以分为<strong>高速时钟源和低速时钟源</strong>，在这5 个中 HIS，HSE 以及 PLL 是高速时钟，LSI 和 LSE是低速时钟。从来源可分为外部时钟源和内部时钟源，外部时钟源就是从外部通过接晶振的方式获取时钟源，其中HSE 和 LSE 是外部时钟源，其他的是内部时钟源。下面我们看看 STM32 的 5个时 钟源，我们讲解顺序是按图中红圈标示的顺序：</p><p>①、HSI 是高速内部时钟，RC 振荡器，频率为 8MHz。 ②、HSE是高速外部时钟，可接石英/陶瓷谐振器，或者接外部时钟源，频率范围为4MHz~16MHz。我们的开发板接的是 8M 的晶振。 ③、LSI 是低速内部时钟，RC振荡器，频率为 40kHz。独立看门狗的时钟源只能是 LSI，同 时 LSI 还可以作为RTC 的时钟源。 ④、LSE 是低速外部时钟，接频率为 32.768kHz的石英晶体。这个主要是 RTC 的时钟源。 ⑤、PLL为锁相环倍频输出，其时钟输入源可选择为 HSI/2、HSE 或者HSE/2。倍频可选择为2~16 倍，但是其输出频率最大不得超过 72MHz。</p><p>上面我们简要概括了 STM32 的时钟源，那么这 5个时钟源是怎么给各个外设以及系统提供时钟的呢？这里我们将一一讲解。我们还是从图的下方讲解起吧，因为下方比较简单。图中我们用 A~E 标示我们要讲解的地方。</p><p><strong>A. </strong>MCO 是 STM32 的一个时钟输出IO(PA8)，它可以选择一个时钟信号输出，可以 选择为 PLL 输出的 2分频、HSI、HSE、或者系统时钟。这个时钟可以用来给外部其他系统提供时钟源。 <strong>B. </strong>这里是 RTC时钟源，从图上可以看出，RTC 的时钟源可以选择 LSI，LSE，以及 HSE 的 128分频。 <strong>C. </strong>从图中可以看出 C 处 USB 的时钟是来自 PLL时钟源。STM32 中有一个全速功能 的 USB 模块，其串行接口引擎需要一个频率为48MHz 的时钟源。该时钟源只能 从 PLL 输出端获取，可以选择为 1.5 分频或者1 分频，也就是，当需要使用 USB 模块时，PLL 必须使能，并且时钟频率配置为48MHz 或 72MHz。 <strong>D. </strong>D 处就是 STM32 的系统时钟SYSCLK，它是供 STM32 中绝大部分部件工作的时 钟源。系统时钟可选择为 PLL输出、HSI 或者 HSE。系统时钟最大频率为 72MHz，当然你也可以超频，不过一般情况为了系统稳定性是没有必要冒风险去超频的。<strong>E. </strong>这里的 E处是指其他所有外设了。从时钟图上可以看出，其他所有外设的时钟最终来源都是 SYSCLK。</p><p>SYSCLK 通过 AHB 分频器分频后送给各模块使用。这些 模块包括：</p><p>①、AHB 总线、内核、内存和 DMA 使用的 HCLK 时钟。 ②、通过 8 分频后送给Cortex 的系统定时器时钟，也就是 systick 了。 ③、直接送给 Cortex的空闲运行时钟 FCLK。 ④、送给 APB1 分频器。APB1 分频器输出一路供 APB1外设使用(PCLK1，最大 频率 36MHz)，另一路送给定时器(Timer)2、3、4倍频器使用。 ⑤、送给 APB2 分频器。APB2 分频器分频输出一路供 APB2外设使用(PCLK2， 最大频率 72MHz)，另一路送给定时器(Timer)1倍频器使用。</p><p>其中需要理解的是 APB1 和 APB2 的区别，<strong>APB1上面连接的是低速外设</strong>，包括电源接口、备份接口、CAN、USB、I2C1、I2C2、UART2、UART3 等等，<strong>APB2上面连接的是高速外设</strong>包括UART1、SPI1、Timer1、ADC1、ADC2、所有普通 IO 口(PA~PE)、第二功能 IO口等。</p>]]></content>
    
    
    
    <tags>
      
      <tag>单片机</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>单片机复习-04</title>
    <link href="/2022/06/05/%E5%8D%95%E7%89%87%E6%9C%BA%E5%A4%8D%E4%B9%A0-04/"/>
    <url>/2022/06/05/%E5%8D%95%E7%89%87%E6%9C%BA%E5%A4%8D%E4%B9%A0-04/</url>
    
    <content type="html"><![CDATA[<h2 id="定时器中断的应用">定时器中断的应用</h2><p>在第五章我们学过了定时器，而实际上<strong>定时器一般用法都是采取中断方式来做的</strong>，我是故意在第五章用查询法，就是使用if(TF0==1)这样的语句先用定时器，目的是明确告诉同学们，定时器和中断不是一回事，定时器是单片机模块的一个资源，确确实实存在的一个模块，而<strong>中断，是单片机的一种运行机制</strong>。尤其是初学者们，很多人会误以为定时器和中断是一个东西，只有定时器才会触发中断，但实际上很多事件都会触发中断的，除了“烧水”，还有“有人按门铃”，“来电话了”等等。</p><p>标准 51单片机中控制中断的寄存器有两个，一个是<strong>中断使能寄存器</strong>，另一个是<strong>中断优先级寄存器</strong>，这里先介绍中断使能寄存器，如表6-1 和表 6-2 所示。随着一些增强型 51单片机的问世，可能会有增加的寄存器，大家理解了我们这里所讲的，其它的通过自己研读数据手册就可以理解明白并且用起来了。</p><table><thead><tr class="header"><th>位</th><th>7</th><th>6</th><th>5</th><th>4</th><th>3</th><th>2</th><th>1</th><th>0</th></tr></thead><tbody><tr class="odd"><td>符号</td><td>EA</td><td>--</td><td>ET2</td><td>ES</td><td>ET1</td><td>EX1</td><td>ET0</td><td>EX0</td></tr><tr class="even"><td>复位值</td><td>0</td><td>--</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td></tr></tbody></table><table><thead><tr class="header"><th>位</th><th>符号</th><th>描述</th></tr></thead><tbody><tr class="odd"><td>7</td><td>EA</td><td>总中断使能位，相当于总开关</td></tr><tr class="even"><td>6</td><td>--</td><td>--</td></tr><tr class="odd"><td>5</td><td>ET2</td><td>定时器 2 中断使能</td></tr><tr class="even"><td>4</td><td>ES</td><td>串口中断使能</td></tr><tr class="odd"><td>3</td><td>ET1</td><td>定时器 1 中断使能</td></tr><tr class="even"><td>2</td><td>EX1</td><td>外部中断 1 使能</td></tr><tr class="odd"><td>1</td><td>ET0</td><td>定时器 0 中断使能</td></tr><tr class="even"><td>0</td><td>EX0</td><td>外部中断 0 使能</td></tr></tbody></table><p>中断使能寄存器 IE 的位 0～5 控制了 6 个中断使能，而第 6位没有用到，第 7位是总开关。总开关就相当于我们家里或者学生宿舍里的那个电源总闸门，而0～5 位这 6 个位相当于每个分开关。那么也就是说，我们只要用到中断，就要写EA = 1这一句，打开中断总开关，然后用到哪个分中断，再打开相对应的控制位就可以了。</p><p>我们现在就把前面的数码管动态显示的程序改用中断再实现出来，同时数码管显示抖动和“鬼影”也一并处理掉了。程序运行的流程跟图6-1所示的流程图是基本一致的，但因为加入了中断，所以整个流程被分成了两部分，<strong>秒计数和转换为数码管显示字符的部分还留在主循环内，而动态扫描部分则移到了中断函数内，并加入了消隐的处理</strong>。下面来看程序：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;reg52.h&gt;</span></span><br><br>sbit ADDR0 = P1^<span class="hljs-number">0</span>;<br>sbit ADDR1 = P1^<span class="hljs-number">1</span>;<br>sbit ADDR2 = P1^<span class="hljs-number">2</span>;<br>sbit ADDR3 = P1^<span class="hljs-number">3</span>;<br>sbit ENLED = P1^<span class="hljs-number">4</span>;<br><br><span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> code LedChar[] = &#123; <span class="hljs-comment">//数码管显示字符转换表</span><br>    <span class="hljs-number">0xC0</span>, <span class="hljs-number">0xF9</span>, <span class="hljs-number">0xA4</span>, <span class="hljs-number">0xB0</span>, <span class="hljs-number">0x99</span>, <span class="hljs-number">0x92</span>, <span class="hljs-number">0x82</span>, <span class="hljs-number">0xF8</span>,<br>    <span class="hljs-number">0x80</span>, <span class="hljs-number">0x90</span>, <span class="hljs-number">0x88</span>, <span class="hljs-number">0x83</span>, <span class="hljs-number">0xC6</span>, <span class="hljs-number">0xA1</span>, <span class="hljs-number">0x86</span>, <span class="hljs-number">0x8E</span><br>&#125;;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> LedBuff[<span class="hljs-number">6</span>] = &#123; <span class="hljs-comment">//数码管显示缓冲区，初值 0xFF 确保启动时都不亮</span><br>    <span class="hljs-number">0xFF</span>, <span class="hljs-number">0xFF</span>, <span class="hljs-number">0xFF</span>, <span class="hljs-number">0xFF</span>, <span class="hljs-number">0xFF</span>, <span class="hljs-number">0xFF</span><br>&#125;;<br><br><span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> i = <span class="hljs-number">0</span>;  <span class="hljs-comment">//动态扫描的索引</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>;  <span class="hljs-comment">//记录 T0 中断次数</span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> sec = <span class="hljs-number">0</span>;  <span class="hljs-comment">//记录经过的秒数</span><br>    EA = <span class="hljs-number">1</span>;  <span class="hljs-comment">//使能总中断</span><br>    ENLED = <span class="hljs-number">0</span>;  <span class="hljs-comment">//使能 U3，选择控制数码管</span><br>    ADDR3 = <span class="hljs-number">1</span>;  <span class="hljs-comment">//因为需要动态改变 ADDR0-2 的值，所以不需要再初始化了</span><br>    TMOD = <span class="hljs-number">0x01</span>;  <span class="hljs-comment">//设置 T0 为模式 1</span><br>    TH0 = <span class="hljs-number">0xFC</span>;  <span class="hljs-comment">//为 T0 赋初值 0xFC67，定时 1ms</span><br>    TL0 = <span class="hljs-number">0x67</span>;<br>    ET0 = <span class="hljs-number">1</span>;  <span class="hljs-comment">//使能 T0 中断</span><br>    TR0 = <span class="hljs-number">1</span>;  <span class="hljs-comment">//启动 T0</span><br><br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)&#123;<br>        <span class="hljs-keyword">if</span> (cnt &gt;= <span class="hljs-number">1000</span>)&#123;  <span class="hljs-comment">//判断 T0 溢出是否达到 1000 次</span><br>            cnt = <span class="hljs-number">0</span>;  <span class="hljs-comment">//达到 1000 次后计数值清零</span><br>            sec++;  <span class="hljs-comment">//秒计数自加 1</span><br>           <br>            <span class="hljs-comment">//以下代码将 sec 按十进制位从低到高依次提取并转为数码管显示字符</span><br>            LedBuff[<span class="hljs-number">0</span>] = LedChar[sec%<span class="hljs-number">10</span>];<br>            LedBuff[<span class="hljs-number">1</span>] = LedChar[sec/<span class="hljs-number">10</span>%<span class="hljs-number">10</span>];<br>            LedBuff[<span class="hljs-number">2</span>] = LedChar[sec/<span class="hljs-number">100</span>%<span class="hljs-number">10</span>];<br>            LedBuff[<span class="hljs-number">3</span>] = LedChar[sec/<span class="hljs-number">1000</span>%<span class="hljs-number">10</span>];<br>            LedBuff[<span class="hljs-number">4</span>] = LedChar[sec/<span class="hljs-number">10000</span>%<span class="hljs-number">10</span>];<br>            LedBuff[<span class="hljs-number">5</span>] = LedChar[sec/<span class="hljs-number">100000</span>%<span class="hljs-number">10</span>];<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-comment">/* 定时器 0 中断服务函数 */</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">InterruptTimer0</span><span class="hljs-params">()</span> interrupt 1&#123;<br>    TH0 = <span class="hljs-number">0xFC</span>;  <span class="hljs-comment">//重新加载初值</span><br>    TL0 = <span class="hljs-number">0x67</span>;<br>    cnt++;  <span class="hljs-comment">//中断次数计数值加 1</span><br>   <br>    <span class="hljs-comment">//以下代码完成数码管动态扫描刷新</span><br>    P0 = <span class="hljs-number">0xFF</span>;<br>    <span class="hljs-comment">//显示消隐</span><br>    <span class="hljs-keyword">switch</span> (i)&#123;<br>        <span class="hljs-keyword">case</span> <span class="hljs-number">0</span>: ADDR2=<span class="hljs-number">0</span>; ADDR1=<span class="hljs-number">0</span>; ADDR0=<span class="hljs-number">0</span>; i++; P0=LedBuff[<span class="hljs-number">0</span>]; <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>: ADDR2=<span class="hljs-number">0</span>; ADDR1=<span class="hljs-number">0</span>; ADDR0=<span class="hljs-number">1</span>; i++; P0=LedBuff[<span class="hljs-number">1</span>]; <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>: ADDR2=<span class="hljs-number">0</span>; ADDR1=<span class="hljs-number">1</span>; ADDR0=<span class="hljs-number">0</span>; i++; P0=LedBuff[<span class="hljs-number">2</span>]; <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-number">3</span>: ADDR2=<span class="hljs-number">0</span>; ADDR1=<span class="hljs-number">1</span>; ADDR0=<span class="hljs-number">1</span>; i++; P0=LedBuff[<span class="hljs-number">3</span>]; <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-number">4</span>: ADDR2=<span class="hljs-number">1</span>; ADDR1=<span class="hljs-number">0</span>; ADDR0=<span class="hljs-number">0</span>; i++; P0=LedBuff[<span class="hljs-number">4</span>]; <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-number">5</span>: ADDR2=<span class="hljs-number">1</span>; ADDR1=<span class="hljs-number">0</span>; ADDR0=<span class="hljs-number">1</span>; i=<span class="hljs-number">0</span>; P0=LedBuff[<span class="hljs-number">5</span>]; <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">default</span>: <span class="hljs-keyword">break</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>大家可以先把程序抄下来，编译下载到单片机里运行，看看实际效果。是否可以看到，近乎完美的显示效果经过我们的努力终于做成功了。下面我们还要再来解析一下这个程序。</p><p>在这个程序中，有两个函数，一个是主函数，一个是中断服务函数。主函数main()我们就不用说了，重点强调一下<strong>中断服务函数</strong>，它的书写格式是固定的，首先中断函数前边void表示函数返回空，即中断函数不返回任何值，函数名是InterruptTimer0()，这个函数名在符合函数命名规则的前提下可以随便取，我们取这个名字是为了方便区分和记忆，而后是interrupt这个关键字，一定不能错，这是中断特有的关键字，另外后边还有个数字1，这个数字 1 怎么来的呢？我们先来看表 6-3。</p><table><thead><tr class="header"><th>中断 函数编号</th><th>中断名称</th><th>中断 标志位</th><th>中断 使能位</th><th>中断 向量地址</th><th>默认 优先级</th></tr></thead><tbody><tr class="odd"><td>0</td><td>外部中断 0</td><td>IE0</td><td>EX0</td><td>0x0003</td><td>1(最高)</td></tr><tr class="even"><td>1</td><td>T0 中断</td><td>TF0</td><td>ET0</td><td>0x000B</td><td>2</td></tr><tr class="odd"><td>2</td><td>外部中断 1</td><td>IE1</td><td>EX1</td><td>0x0013</td><td>3</td></tr><tr class="even"><td>3</td><td>T1 中断</td><td>TF1</td><td>ET1</td><td>0x001B</td><td>4</td></tr><tr class="odd"><td>4</td><td>UART 中断</td><td>TI/RI</td><td>ES</td><td>0x0023</td><td>5</td></tr><tr class="even"><td>5</td><td>T2 中断</td><td>TF2/EXF2</td><td>ET2</td><td>0x002B</td><td>6</td></tr></tbody></table><p>这个表格同样不需要大家记住，需要的时候过来查就可以了。我们现在看第二行的T0中断，要使能这个中断那么就要把它的中断使能位 ET0 置1，当它的中断标志位 TF0 变为 1时，就会触发 T0中断了，那么这时就应该来执行中断函数了，单片机又怎样找到这个中断函数呢？靠的就是中断向量地址，所以i**nterrupt 后面中断函数编号的数字 x就是根据中断向量得出的，它的计算方法是x*8+3=向量地址**。当然表中都已经给算好放在第一栏了，我们可以直接查出来用就行了。到此为止，中断函数的命名规则我们就都搞清楚了。</p><p>中断函数写好后，每当满足中断条件而触发中断后，系统就会自动来调用中断函数。比如我们上面这个程序，平时一直在主程序while(1)的循环中执行，假如程序有 100 行，当执行到 50行时，定时器溢出了，那么单片机就会立刻跑到中断函数中执行中断程序，中断程序执行完毕后再自动返回到刚才的第50 行处继续执行下面的程序，这样就保证了动态显示间隔是固定的1ms，不会因为程序执行时间不一致的原因导致数码管显示的抖动了。</p><p><strong>中断优先级有两种，一种是抢占优先级，一种是固有优先级</strong>，先介绍抢占优先级。来看表6-4 和表 6-5。</p><table><thead><tr class="header"><th>位</th><th>7</th><th>6</th><th>5</th><th>4</th><th>3</th><th>2</th><th>1</th><th>0</th></tr></thead><tbody><tr class="odd"><td>符号</td><td>--</td><td>--</td><td>PT2</td><td>PS</td><td>PT1</td><td>PX1</td><td>PT0</td><td>PX0</td></tr><tr class="even"><td>复位值</td><td>--</td><td>--</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td></tr></tbody></table><table><thead><tr class="header"><th>位</th><th>符号</th><th>描述</th></tr></thead><tbody><tr class="odd"><td>7</td><td>--</td><td>保留</td></tr><tr class="even"><td>6</td><td>--</td><td>保留</td></tr><tr class="odd"><td>5</td><td>PT2</td><td>定时器 2 中断优先级控制位</td></tr><tr class="even"><td>4</td><td>PS</td><td>串口中断优先级控制位</td></tr><tr class="odd"><td>3</td><td>PT1</td><td>定时器 1 中断优先级控制位</td></tr><tr class="even"><td>2</td><td>PX1</td><td>外部中断 1 中断优先级控制位</td></tr><tr class="odd"><td>1</td><td>PT0</td><td>定时器 0 中断优先级控制位</td></tr><tr class="even"><td>0</td><td>PX0</td><td>外部中断 0 中断优先级控制位</td></tr></tbody></table><p>IP 这个寄存器的每一位，表示对应中断的抢占优先级，每一位的复位值都是0，当我们把某一位设置为 1的时候，这一位的优先级就比其它位的优先级高了。比如我们设置了 PT0位为 1后，当单片机在主循环或者任何其它中断程序中执行时，一旦定时器 T0发生中断，作为更高的优先级，程序马上就会跑到 T0的中断程序中来执行。反过来，当单片机正在T0中断程序中执行时，如果有其它中断发生了，还是会继续执行 T0中断程序，直到把 T0中的中断程序执行完毕以后，才会去执行其它中断程序。</p><p><strong>当进入低优先级中断中执行时，如又发生了高优先级的中断，则立刻进入高优先级中断执行，处理完高优先级级中断后，再返回处理低优先级中断，这个过程就叫做中断嵌套</strong>，也称为<strong>抢占</strong>。所以抢占优先级的概念就是，优先级高的中断可以打断优先级低的中断的执行，从而形成嵌套。当然反过来，优先级低的中断是不能打断优先级高的中断的。</p><p>那么既然有抢占优先级，自然就也有非抢占优先级了，也称为固有优先级。在表6-3中的最后一列给出的就是固有优先级，请注意，<strong>在中断优先级的编号中，一般都是数字越小优先级越高</strong>。从表中可以看到一共有1～6 共 6级的优先级，这里的优先级与抢占优先级的一个不同点就是，它不具有抢占的特性，也就是说<strong>即使在低优先级中断执行过程中又发生了高优先级的中断，那么这个高优先级的中断也只能等到低优先级中断执行完后才能得到响应</strong>。既然不能抢占，那么这个优先级有什么用呢？</p><p>答案是多个中断同时存在时的仲裁。比如说有多个中断同时发生了，当然实际上发生这种情况的概率很低，但另外一种情况就常见的多了，那就是出于某种原因我们暂时关闭了总中断，即EA=0，执行完一段代码后又重新使能了总中断，即EA=1，那么在这段时间里就很可能有多个中断都发生了，但因为总中断是关闭的，所以它们当时都得不到响应，而当总中断再次使能后，它们就会在同时请求响应了，很明显，这时也必需有个先后顺序才行，这就是非抢占优先级的作用了——如表6-3 中，谁优先级最高先响应谁，然后按编号排队，依次得到响应。</p><p>抢占优先级和非抢占优先级的协同，可以使单片机中断系统有条不紊的工作，既不会无休止的嵌套，又可以保证必要时紧急任务得到优先处理。在后续的学习过程中，中断系统会与我们如影随形，处处都有它的身影，随着学习的深入，相信你对它的理解也会更加的深入</p>]]></content>
    
    
    
    <tags>
      
      <tag>单片机 中断</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>单片机复习-03</title>
    <link href="/2022/06/05/%E5%8D%95%E7%89%87%E6%9C%BA%E5%A4%8D%E4%B9%A0-03/"/>
    <url>/2022/06/05/%E5%8D%95%E7%89%87%E6%9C%BA%E5%A4%8D%E4%B9%A0-03/</url>
    
    <content type="html"><![CDATA[<h2 id="单片机定时器介绍">单片机定时器介绍</h2><p>定时器是单片机系统的一个重点，但并不是难点，大家一定要完全理解并且熟练掌握定时器的应用。</p><p><strong>1) 时钟周期</strong> 时钟周期 T是<strong>时序中最小的时间单位</strong>，具体计算的方法就是1/时钟源频率，我们 KST-51 单片机开发板上用的晶振是11.0592M，那么对于我们这个单片机系统来说，时钟周期=1/11059200 秒。</p><p><strong>2) 机器周期</strong>我们的单片机完成一个操作的最短时间。机器周期主要针对汇编语言而言，在<strong>汇编语言下程序的每一条语句执行所使用的时间都是机器周期的整数倍</strong>，而且语句占用的时间是可以计算出来的，而<strong>C语言一条语句的时间是不确定的，受到诸多因素的影响</strong>。51单片机系列，在其标准架构下一个机器周期是12 个时钟周期，也就是 12/11059200 秒。现在有不少增强型的 51单片机，其速度都比较块，有的 1 个机器周期等于 4 个时钟周期，有的1个机器周期就等于 1 个时钟周期，也就是说大体上其速度可以达到标准 51架构的 3 倍或 12倍。因为我们是讲标准的 51单片机，所以我们后边的课程如果遇到这个概念，全部是指 12 个时钟周期。</p><p>这两个概念了解即可，下边就来我们的重头戏，定时器和计数器。<strong>定时器和计数器是单片机内部的同一个模块，通过配置SFR（特殊功能寄存器）可以实现两种不同的功能</strong>，我们大多数情况下是使用定时器功能，因此我们的课程也是主要来讲定时器功能，计数器功能大家自己了解下即可。</p><p>顾名思义，定时器就是用来进行定时的。定时器内部有一个寄存器，我们让它开始计数后，这个<strong>寄存器的值每经过一个机器周期就会自动加1</strong>，因此，我们可以把机器周期理解为定时器的计数周期。就像我们的钟表，每经过一秒，数字自动加1，而这个定时器就是每过一个机器周期的时间，也就是 12/11059200秒，数字自动加 1。还有一个特别注意的地方，就是钟表是加到 60后，秒就自动变成 0 了，这种情况在单片机或计算机里我们称之为溢出。</p><p>那定时器加到多少才会溢出呢？后面会讲到定时器有多种工作模式，分别使用不同的位宽（指使用多少个二进制位），假如是16 位的定时器，也就是 2 个字节，最大值就是 65535，那么加到 65535后，再加 1 就算溢出，如果有其他位数的话，道理是一样的，对于 51单片机来说，溢出后，这个值会直接变成0。从某一个初始值开始，经过确定的时间后溢出，这个过程就是定时的含义。</p><h2 id="单片机定时器的寄存器">单片机定时器的寄存器</h2><p>标准的 51 单片机内部有 T0 和 T1 这两个定时器，T 就是 Timer的缩写，现在很多 51 系列单片机还会增加额外的定时器，在这里我们先讲定时器0 和 1。前边提到过，<strong>对于单片机的每一个功能模块，都是由它的SFR，也就是特殊功能寄存器来控制</strong>。与定时器有关的特殊功能寄存器，有以下几个，大家不需要去记忆这些寄存器的名字和作用，你只要大概知道就行，用的时候，随时可以查手册，找到每个寄存器的名字和每个寄存器所起到的作用。</p><p>表 5-1 的寄存器是<strong>存储定时器的计数值</strong>的。TH0/TL0 用于T0，TH1/TL1 用于 T1。</p><table><thead><tr class="header"><th>名称</th><th>描述</th><th>SFR 地址</th><th>复位值</th></tr></thead><tbody><tr class="odd"><td>TH0</td><td>定时器 0 高字节</td><td>0x8C</td><td>0x00</td></tr><tr class="even"><td>TL0</td><td>定时器 0 低字节</td><td>0x8A</td><td>0x00</td></tr><tr class="odd"><td>TH1</td><td>定时器 1 高字节</td><td>0x8D</td><td>0x00</td></tr><tr class="even"><td>TL1</td><td>定时器 1 低字节</td><td>0x8B</td><td>0x00</td></tr></tbody></table><p>表 5-2 是定时器<strong>控制寄存器 TCON 的位分配</strong>，表 5-3是则是对每一位的具体含义的描述。</p><table><thead><tr class="header"><th>位</th><th>7</th><th>6</th><th>5</th><th>4</th><th>3</th><th>2</th><th>1</th><th>0</th></tr></thead><tbody><tr class="odd"><td>符号</td><td>TF1</td><td>TR1</td><td>TF0</td><td>TR0</td><td>IE1</td><td>IT1</td><td>IE0</td><td>IT0</td></tr><tr class="even"><td>复位值</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td></tr></tbody></table><table><thead><tr class="header"><th>位</th><th>符号</th><th>描述</th></tr></thead><tbody><tr class="odd"><td>7</td><td>TF1</td><td>定时器 1 溢出标志。一旦定时器 1 发生溢出时硬件置 1。清零有两种方式：软件清零，或者进入定时器中断时硬件清零。</td></tr><tr class="even"><td>6</td><td>TR1</td><td>定时器 1 运行控制位。软件置位/清零来进行启动/停止定时器。</td></tr><tr class="odd"><td>5</td><td>TF0</td><td>定时器 0 溢出标志。一旦定时器 0 发生溢出时硬件置 1。清零有两种方式：软件清零，或者进入定时器中断时硬件清零。</td></tr><tr class="even"><td>4</td><td>TR0</td><td>定时器 0 运行控制位。软件置位/清零来进行启动/停止定时器。</td></tr><tr class="odd"><td>3</td><td>IE1</td><td>外部中断部分，与定时器无关，暂且不看。</td></tr><tr class="even"><td>2</td><td>IT1</td><td></td></tr><tr class="odd"><td>1</td><td>IE0</td><td></td></tr><tr class="even"><td>0</td><td>IT0</td><td></td></tr></tbody></table><p>大家注意在表 5-3 中的描述中，只要写到<strong>硬件置 1 或者清 0的，就是指一旦符合条件，单片机将自动完成的动作</strong>，只要写<strong>软件置1 或者清 0的，是指我们必须用程序去完成这个动作</strong>，后续遇到此类描述就不再另做说明了。</p><p>对于 TCON 这个 SFR，其中有 TF1、TR1、TF0、TR0 这 4位需要我们理解清楚，它们分别对应于 T1 和 T0，我们以定时器 1为例讲解，那么定时器 0 同理。先看 TR1，当我们程序中写 TR1 = 1以后，定时器值就会每经过一个机器周期自动加 1，当我们程序中写 TR1 =0以后，定时器就会停止加1，其值会保持不变化。TF1，这个是一个标志位，他的作用是告诉我们定时器溢出了。比如我们的定时器设置成16 位的模式，那么每经过一个机器周期，TL1加 1 一次，当 TL1 加到 255后，再加 1，TL1 变成 0，TH1 会加 1 一次，如此一直加到 TH1和 TL1 都是255（即 TH1 和 TL1 组成的 16 位整型数为 65535）以后，再加 1一次，就会溢出了，TH1 和 TL1 同时都变为 0，只要一溢出，TF1 马上自动变成1，告诉我们定时器溢出了，仅仅是提供给我们一个信号，让我们知道定时器溢出了，它不会对定时器是否继续运行产生任何影响。</p><p>本节开头我们就提到了定时器有多种工作模式，工作模式的选择就由 TMOD来控制，TMOD 的位分配和描述见表 5-4 到 5-6 所示，TMOD 的位功能如表 5-5所示。</p><table style="width:100%;"><thead><tr class="header"><th>位</th><th>7</th><th>6</th><th>5</th><th>4</th><th>3</th><th>2</th><th>1</th><th>0</th></tr></thead><tbody><tr class="odd"><td>符号</td><td>GATE (T1)</td><td>C/T (T1)</td><td>M1 (T1)</td><td>M0 (T1)</td><td>GATE (T0)</td><td>C/T (T0)</td><td>M1 (T0)</td><td>M0 (T0)</td></tr><tr class="even"><td>复位值</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td></tr></tbody></table><table><thead><tr class="header"><th>符号</th><th>描述</th></tr></thead><tbody><tr class="odd"><td>T1/T0</td><td>在表 5-5 中，标 T1 的表示控制定时器 1 的位，标 T0 的表示控制定时器 0的位。</td></tr><tr class="even"><td>GATE</td><td>该位被置 1 时为门控位。仅当„INTx‟脚为高并且„TRx‟控制位被置 1 时使能定时器„x‟，定时器开始计时，当该位被清 0 时，只要„TRx‟位被置 1，定时 器 x就使能开始计时，不受到单片机引脚„INTx‟外部信号的干扰，常用来测量外部信号脉冲宽度。这是定时器一个额外功能，本节课暂不介绍。</td></tr><tr class="odd"><td>C/T</td><td>定时器或计数器选择位。该位被清零时用作定时器功能（内部系统时钟），被置 1 用作计数器功能。</td></tr></tbody></table><table><thead><tr class="header"><th>M1</th><th>M0</th><th>工作模式</th><th>描述</th></tr></thead><tbody><tr class="odd"><td>0</td><td>0</td><td>0</td><td>兼容 8048 单片机的 13 位定时器，THn 的 8 位和 TLn 的 5 位组 成一个13 位定时器。</td></tr><tr class="even"><td>0</td><td>1</td><td>1</td><td>THn 和 TLn 组成一个 16 位的定时器。</td></tr><tr class="odd"><td>1</td><td>0</td><td>2</td><td>8 位自动重装模式，定时器溢出后 THn 重装到 TLn 中。</td></tr><tr class="even"><td>1</td><td>1</td><td>3</td><td>禁用定时器 1，定时器 0 变成 2 个 8 位定时器。</td></tr></tbody></table><p>可能你已经注意到了，表 5-2 的 TCON最后标注了“<strong>可位寻址</strong>”，而表 5-4 的 TMOD标注的是“<strong>不可位寻址</strong>”。意思就是说：<strong>比如 TCON有一个位叫 TR1，我们可以在程序中直接进行 TR1 = 1 这样的操作。但对 TMOD里的位比如(T1)M1 = 1这样的操作就是错误的</strong>。我们要操作就必须一次操作这整个字节，也就是必须一次性对TMOD所有位操作，不能对其中某一位单独进行操作，那么我们能不能只修改其中的一位而不影响其它位的值呢？当然可以，在后续课程中你就会学到方法的，现在就先不关心它了。</p><p>表 5-6 列出的就是定时器的 4 中工作模式，其中模式 0 是为了兼容老的8048 系列单片机而设计的，现在的 51 几乎不会用到这种模式，而模式 3根据我的应用经验，它的功能用模式 2完全可以取代，所以基本上也是不用的，那么我们就重点来学习模式 1 和模式2。</p><p><strong>模式 1，是 THn 和 TLn 组成了一个 16 位的定时器，计数范围是0～65535，溢出后，只要不对 THn 和 TLn 重新赋值，则从 0开始计数。</strong> <strong>模式 2，是 8 位自动重装载模式，只有 TLn做加1 计数，计数范围 0～255，THn 的值并不发生变化，而是保持原值，TLn溢出后，TFn就直接置 1 了，并且 THn 原先的值直接赋给 TLn，然后 TLn从新赋值的这个数字开始计数。这个功能可以用来产生串口的通信波特率</strong>，我们讲串口的时候要用到，本章节我们重点来学习模式1。为了加深大家理解定时器的原理，我们来看一下他的模式 1 的电路示意图5-2。</p><p><imgsrc="http://c.biancheng.net/cpp/uploads/allimg/140316/1-140316222340409.png"alt="图 5-2 定时器/计数器模式 1 示意图" /> 图 5-2 定时器/计数器模式 1示意图</p><p>我带领大家一起来分析一遍这个示意图，日后如果再遇到类似的图，大家就可以自己研究了。OSC框表示时钟频率，因为 1 个机器周期等于 12 个时钟周期，所以那个 d 就等于12。下边 GATE右边的那个门是一个非门电路，再右侧是一个或门，再往右是一个与门电路，大家可以对照一下5-1 节的内容。</p><p>图上可以看出来，下边部分电路是控制了上边部分，那我们先来看下边是如何控制的，我们以定时器0 为例。</p><ol type="1"><li><p>TR0 和下边或门电路的结果要进行与运算，TR0 如果是 0的话，与运算完了肯定是 0，所以如果要让定时器工作，那么 TR0 就必须置1。</p></li><li><p>这里的与门结果要想得到 1，那么前面的或门出来的结果必须也得是 1才行。在 GATE位为 1 的情况下，经过一个非门变成 0，或门电路结果要想是 1的话，那 INT0 即 P3.2 引脚必须是 1 的情况下，这个时候定时器才会工作，而INT0 引脚是 0 的情况下，定时器不工作，这就是 GATE 位的作用。</p></li><li><p>当 GATE 位为 0 的时候，经过一个非门会变成 1，那么不管 INT0引脚是什么电平，经过或门电路后都肯定是 1，定时器就会工作。</p></li><li><p>要想让定时器工作，就是自动加1，从图上看有两种方式，第一种方式是那个开关打到上边的箭头，就是 C/T = 0的时候，一个机器周期 TL 就会加 1 一次，当开关打到下边的箭头，即 C/T =1的时候，T0 引脚即 P3.4 引脚来一个脉冲，TL 就加 1一次，这也就是计数器功能。</p></li></ol><h3 id="单片机中定时器的应用">单片机中定时器的应用</h3><p>了解了定时器相关的寄存器，那么我们下面就来做一个定时器的程序，巩固一下我们学到的内容。我们这节课的程序先使用定时器0，在使用定时器的时候，需要以下几个步骤： 第一步：设置特殊功能寄存器TMOD，配置好工作模式。 第二步：设置计数寄存器 TH0 和 TL0 的初值。第三步：设置 TCON，通过 TR0 置 1 来让定时器开始计数。 第四步：判断 TCON寄存器的 TF0 位，监测定时器溢出情况。</p><p>写程序之前，我们要先来学会计算如何用定时器定时时间。我们的晶振是11.0592M，时钟周期就是 1/11059200，机器周期是 12/11059200，假如要定时20ms，就是 0.02 秒，要经过x 个机器周期得到 0.02 秒，我们来算一下x*12/11059200=0.02，得到 x= 18432。16 位定时器的溢出值是 65536（因 65535再加 1 才是溢出），于是我们就可以这样操作，先给 TH0 和TL0一个初始值，让它们经过 18432 个机器周期后刚好达到65536，也就是溢出，溢出后可以通过检测 TF0 的值得知，就刚好是 0.02秒。那么初值 y = 65536 - 18432 = 47104，转成 16 进制就是 0xB800，也就是TH0 = 0xB8，TL0 = 0x00。</p><p>这样 0.02秒的定时我们就做出来了，细心的同学会发现，如果初值直接给一个0x0000，一直到 65536 溢出，定时器定时值最大也就是 71ms左右，那么我们想定时更长时间怎么办呢？用你小学学过的逻辑，倍数关系就可以解决此问题。</p><h3 id="单片机中led数码管的介绍">单片机中LED数码管的介绍</h3><p>LED 小灯是一种简单的LED，只能通过亮和灭来表达简单的信息。而这节课我们要来学习一种能表达更复杂信息的器件——LED数码管。</p><p>先给大家提供一张原理图看一下，如图 5-3 所示。</p><p><imgsrc="http://c.biancheng.net/cpp/uploads/allimg/140316/1-140316224449451.png"alt="图 5-3 数码管原理图" /> 图 5-3 数码管原理图</p><p>这是比较常见的数码管的原理图，我们板子上一共有 6 个数码管。前边有了LED 小灯的学习，数码管学习就会轻松的多了。从图 5-3可以看出来，数码管共有 a、b、c、d、e、f、g、dp 这么 8 个段，而实际上，这8 个段每一段都是一个 LED 小灯，所以一个数码管就是由 8个 LED小灯组成的。我们看一下数码管内部结构的示意图，如图 5-4。</p><p><imgsrc="http://c.biancheng.net/cpp/uploads/allimg/140316/1-140316224A11S.png"alt="图 5-4 数码管结构示意图" /> 图 5-4 数码管结构示意图</p><p><strong>数码管分为共阳和共阴两种</strong>，共阴数码管就是 8 只 LED小灯的阴极是连接在一起的，阴极是公共端，由阳极来控制单个小灯的亮灭。同理，共阳数码管就是阳极接在一起，大家可以认真研究下图5-4。细心的同学会发现，图 5-3 的数码管上边有 2 个com，这就是我们数码管的公共端。为什么有 2 个呢，一方面是 2个可以起到对称的效果，刚好是 10个引脚，另外一个方面，公共端通过的电流较大，我们初中就学过，并联电路电流之和等于总电流，<strong>用2个 com 可以把公共电流平均到 2个引脚上去，降低单条线路承受的电流</strong>。</p><p>从我们开发板的电路图上能看出来，我们所用的数码管都是共阳数码管，一共有6 个，如图 5-5 所示。</p><p><imgsrc="http://c.biancheng.net/cpp/uploads/allimg/140316/1-140316224953358.png"alt="图 5-5 KST-51 数码管电路" /> 图 5-5 KST-51 数码管电路</p><p>6 个数码管的 com 都是接到了正极上，当然了，和 LED小灯电路一样，也是由74HC138控制三极管的导通来控制整个数码管的使能。先来看最右边的 DS1这个数码管，原理图上可以看出，控制 DS1 的三极管是 Q17，控制 Q17 的引脚是LEDS0，对应到 74HC138 上边就是U3 的 Y0 输出，如图 5-6 所示。</p><p><imgsrc="http://c.biancheng.net/cpp/uploads/allimg/140316/1-140316225114G6.png"alt="图 5-6 74HC138 控制图" /> 图 5-6 74HC138 控制图</p><p>我们现在的目的是让 LEDS0这个引脚输出低电平，相信大家现在可以根据前边学过的知识独立把ADDR0、ADDR1、ADDR2、ADDR3、ENLED 这 4个所需输入的值写出来了，现在大家不要偷懒，根据 74HC138的手册去写一下，不需要你记住这些结论，但是遇到就写一次，锻炼过几次后，遇到同类芯片自己就知道如何去解决问题了。</p><p>数码管通常是用来显示数字的，我们板子上有 6 个数码管，习惯上称之为 6位，那控制位选择的就是 74HC138 了。而数码管内部的 8 个 LED小灯我们称之为数码管的段，那么数码管的段选择（即该段的亮灭）是通过 P0口控制，经过 74HC245 驱动。</p>]]></content>
    
    
    
    <tags>
      
      <tag>单片机</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>单片机复习--02</title>
    <link href="/2022/06/05/%E5%8D%95%E7%89%87%E6%9C%BA%E5%A4%8D%E4%B9%A0-02/"/>
    <url>/2022/06/05/%E5%8D%95%E7%89%87%E6%9C%BA%E5%A4%8D%E4%B9%A0-02/</url>
    
    <content type="html"><![CDATA[<h2 id="单片机延时方法keil软件延时">单片机延时方法（keil软件延时）</h2><p>C 语言常用的延时方法，有如图 4-2 所示 4 种。</p><p><imgsrc="http://c.biancheng.net/cpp/uploads/allimg/140316/1-14031620401VZ.png"alt="图 2-4 C 语言延时方法" /> 图 2-4 C 语言延时方法</p><p>图 4-2 是 C 语言编程常用的 4种延时方法，其中两种非精确延时，两种精确一些的延时。for 语句和 while语句都可以通过改变 i 的范围值来改变延时时间，但是 C语言循环的执行时间都是不能通过程序看出来的。<strong>精确延时有两个方法</strong>，一个方法是<strong>用定时器来延时</strong>*，这个方法我们后边课程要详细介绍，定时器是单片机的一个重点。另外一个就是用<strong>库函数_nop_()</strong>;，<strong>一个NOP 的时间是一个机器周期的时间</strong>，这个后边也要介绍。</p><p>非精确延时，只是在我们做一些比如小灯闪烁，流水灯等简单演示实验中使用，而实际项目开发过程中其实这种非精确延时用的很少。</p><p>好了，介绍完了，我们就要实战了。上节课的 LED小灯闪烁的程序，我们用的延时方式是for(i=0;i&lt;30000;i++);大家如果把这里的 i 改成100，下载进入单片机，会发现小灯一直亮，而不是闪烁状态，现在就请大家都把这个程序改一下，改成100，然后下载观察一下现象再继续......</p><p>观察完了，毫无疑问，实际现象和我提到的理论是相符合的，这是为什么呢？这里介绍一个常识。我们人的肉眼对闪烁的光线有一个最低分辨能力，通常情况下当闪烁的频率高于50Hz时，我们看到的信号就是常亮的。即，延时的时间低于 20ms的时候，我们的肉眼是分辨不出来小灯是在闪烁的，可能最多看到的是小灯亮暗稍微变化了一下。要想清楚的看到小灯闪烁，延时的值必须大一点，大到什么程度呢，不同的亮度的灯不完全一样，大家可以自己做实验。</p><p>那么如何观察我们写的延时到底有多长时间呢？选择 Keil 菜单项Project--&gt;Options for Target „Target1‟...，或点击在图 2-17中已提到过的图标，进入工程选项，如图 4-3 所示。</p><p><imgsrc="http://c.biancheng.net/cpp/uploads/allimg/140316/1-14031620460B00.png"alt="图 4-3 工程选项——时钟频率设置" /> 图 4-3 工程选项——时钟频率设置</p><p>首先打开 Target 这个选项卡，找到里边的Xtal(MHz)这个位置，这是填写我们进行模拟时间的晶振选项，从我们原理图以及板子上都可以看到，单片机所使用的晶振是11.0592MHz，所以这个地方我们要填上 11.0592。然后找到 Debug这个选项卡，选择左侧的 Use Simulator，然后点击最下边的 OK 就可以了，如图4-4 所示。</p><p><imgsrc="http://c.biancheng.net/cpp/uploads/allimg/140316/1-140316205125161.png"alt="图 4-4 工程选项——仿真设置" /> 图 4-4 工程选项——仿真设置</p><p>选择菜单项 Debug--&gt;Start/Stop Debug Session，或者点击图 4-5中红框内的按钮，就会进入一个新的页面，如图 4-6 所示。</p><p><imgsrc="http://c.biancheng.net/cpp/uploads/allimg/140316/1-140316205235S1.png"alt="图 4-5 启动/结束调试按钮" /> 图 4-5 启动/结束调试按钮</p><p><imgsrc="http://c.biancheng.net/cpp/uploads/allimg/140316/1-14031620532L57.png"alt="图 4-6 工程调试界面" /> 图 4-6 工程调试界面</p><p>最左侧那一栏显示单片机一些寄存器的当前值和系统信息，最上边那一栏是Keil 将 C 语言转换成汇编的代码，下边就是我们写 C语言的程序，调试界面包含很多的子窗口，都可以通过菜单 View中的选项打开和关闭。你可能会感觉这种默认的分布不符合习惯或者不方便观察特定信息，好办，界面上几乎所有子窗口的位置都可以调整的。比如我想把Disassembly反汇编窗口和源代码窗口横向并排摆放，那么只需要用鼠标拖动反汇编窗口的标题栏，这时会在屏幕上出现多个指示目标位置的图标，拖着窗口把鼠标移动到相应的图标上，软件还会用蓝色底纹指示具体的位置，如图4-7 所示，松开鼠标窗口就会放到新位置了。调整后的效果如图 4-8 所示。</p><p><imgsrc="http://c.biancheng.net/cpp/uploads/allimg/140316/1-14031620544aD.png"alt="图 4-7 调整窗口位置" /> 图 4-7 调整窗口位置</p><p><imgsrc="http://c.biancheng.net/cpp/uploads/allimg/140316/1-14031620560G10.png"alt="图 4-8 窗口位置调整效果" /> 图 4-8 窗口位置调整效果</p><p>你可能已经注意到在 C语言的源代码文件和反汇编窗口内都有一个黄色的箭头，这个箭头代表的就是程序当前运行的位置，因为反汇编内的代码就由源文件编译生成的，所以它们指示的是相同的实际位置。在这个工程调试界面里，我们可以看到程序运行的过程。在左上角的工具栏里有这样三个按钮：第一个标注有RST字样的是复位，点击一下之后，程序就会跑到最开始的位置运行；右侧紧挨着的按钮是全速运行，点击一下程序就会全速跑起来；再右边打叉的是停止按钮，当程序全速运行起来后，我们可以通过点击第三个图标来让程序停止，观察程序运行到哪里了。点击一下复位后，会发现C语言程序左侧有灰色或绿色，有的地方还是保持原来的白色，我们可以在我们灰色的位置双击鼠标设置断点，就是比如程序一共20行，在第十行设置断点后，点全速运行，程序就会运行到第十行停止，方便我们观察运行到这个地方的情况。</p><p>同学们会发现，有的位置可以设置断点，有的地方不可以设置断点，这是为什么呢？因为Keil软件本身具备程序优化的功能，如果大家想在所有的代码位置都能设置断点，可以在工程选项里把优化等级设置为0，就是告诉 Keil 不要进行优化。如图 4-9 所示。</p><p><imgsrc="http://c.biancheng.net/cpp/uploads/allimg/140316/1-140316205JU23.png"alt="图 4-9 工程优化等级" /> 图 4-9 工程优化等级</p><p>这节课我们重点是看看 C 语言代码的运行时间，在最左侧的 register那个框内，有一个sec选项，这个选项显示就是单片机运行了多少时间。单击一下复位按钮，会发现这个sec 变成了 0，然后我们在 LED = 0;这一句加一个断点，在 LED =1;这个位置加一个断点，我们点击全速运行按钮，会直接停留在 LED =0;我们会看到我们的时间变化成 0.00042752 秒，如图4-10所示。请注意，我们这里设置的优化等级是默认的8，如果你用的是其它等级的话运行时间就会有所差别，因为优化等级会直接影响程序的执行效率。</p><p><imgsrc="http://c.biancheng.net/cpp/uploads/allimg/140316/1-14031620592V57.png"alt="图 4-10 查看程序运行时间" /> 图 4-10 查看程序运行时间</p><p>再点一下全速运行，会发现 sec 变成了0.16342556，那么减去上次的值，就是程序在这两个断点之间执行所经历的时间，也就是这个for 循环的执行时间，大概是 163ms。我们也可以通过改变 30000这个数字来改变这个延时时间。当然了，大家要注意 i的取值范围，你如果写成了大于 65535的值以后，程序就一直运行不下去了，因为 i无论如何变化，都不会大于这个值，如果要大于这个值且正常运行，必须改变 i定义的类型了。后边如果我们要查看一段程序运行了多长时间，都可以通过这种方式来查看。</p><p>实际上，进入 debug模式，除了可以看程序运行了多长时间外，还可以观察各个寄存器、各个变量的数值变化情况。点击View 菜单里的 Watch Windows--&gt;Watch 1，可以打开变量观察窗口，如图4-11 所示。</p><p><imgsrc="http://c.biancheng.net/cpp/uploads/allimg/140316/1-140316210039233.png"alt="图4-11 变量观察窗口" /> 图4-11 变量观察窗口</p><p>在这个窗口内，可以通过双击或按 F2键，然后输入我们想观察的变量或寄存器的名字，后边就会显示出它的数值，这个功能在我们后边的调试程序中比较有用，大家先了解一下。</p><h2 id="单片机逻辑电路与逻辑运算">单片机逻辑电路与逻辑运算</h2><p>在数字电路，我们经常会遇到逻辑电路，而在 C语言中，我们则经常用到逻辑运算。二者在原理上是相互关联的，我们在这里就先简单介绍一下，随着学习的深入，再慢慢加深理解。</p><p>首先，在“逻辑”这个概念范畴内，存在真和假这两个逻辑值，而将其对应到数字电路或C 语言中，就变成了“非 0 值”和“0值”这两个值，即逻辑上的“假”就是数字电路或C语言中的“0”这个值，而逻辑“真”就是其它一切“非 0 值”。</p><p>然后，我们来具体分析一下几个主要的逻辑运算符。我们假定有 2个字节变量：A 和 B，二者进行某种逻辑运算后的结果为 F。</p><p>以下逻辑运算符都是按照变量整体值进行运算的，通常就叫做<strong>逻辑运算符</strong>：</p><table><thead><tr class="header"><th>逻辑运算符</th><th>说明</th></tr></thead><tbody><tr class="odd"><td>&amp;&amp; 逻辑与</td><td>F = A &amp;&amp; B，当 A、B 的值都为真（即非 0值，下同）时，其运算结果 F为真（具体数值为1，下同）；当 A、B值任意一个为假（即 0，下同）时，结果 F 为假（具体数值为 0，下同）。</td></tr><tr class="even"><td>|| 逻辑或</td><td>F = A || B，当 A、B 值任意一个为真时，其运算结果 F 为真；当 A、B值都为假时，结果 F 为假。</td></tr><tr class="odd"><td>! 逻辑非</td><td>F = !A，当 A 值为假时，其运算结果 F 为真；当 A 值为真时，结果 F为假。</td></tr></tbody></table><p>以下逻辑运算符都是按照变量内的每一个位来进行运算的，通常就叫做<strong>位运算符</strong>：</p><table><thead><tr class="header"><th>逻辑运算</th><th>说明</th></tr></thead><tbody><tr class="odd"><td>&amp; 按位与</td><td>F = A &amp; B，将 A、B两个字节中的每一位都进行与运算，再将得到的每一位结果组合为总结果 F，例如A = 0b11001100，B = 0b11110000，则结果 F 就等于 0b11000000。</td></tr><tr class="even"><td>| 按位或</td><td>F = A | B，将 A、B两个字节中的每一位都进行或运算，再将得到的每一位结果组合为总结果 F，例如A = 0b11001100，B = 0b11110000，则结果 F 就等于 0b11111100。</td></tr><tr class="odd"><td>~ 按位取反</td><td>F = ~A，将 A字节内的每一位进行非运算（就是取反），再将得到的每一位结果组合为总结果F，例如 A = 0b11001100，则结果 F 就等于0b00110011；这个运算符我们在前面的流水灯实验里已经用过了，现在再回头看一眼，是不是清楚多了。</td></tr><tr class="even"><td>^ 按位异或</td><td>异或的意思是，如果运算双方的值不同（即相异）则结果为真，双方值相同则结果为假。在C 语言里没有按变量整体值进行的异或运算，所以我们仅以按位异或为例，F = A^ B，A = 0b11001100，B = 0b11110000，则结果 F 就等于 0b00111100。</td></tr></tbody></table><p>我们今后要看资料或芯片手册的时候，会经常遇到一些电路符号，图 5-1所示就是数字电路中的常用符号，知道这些符号有利于我们理解器件的逻辑结构，尤其重点认识图5-1中的国外流行图形符号。在这里我们先简单看一下，如果日后遇到了可以到这里来查阅。</p><p><imgsrc="http://c.biancheng.net/cpp/uploads/allimg/140316/1-140316214U3622.png"alt="图 5-1 逻辑电路符号" /> 图 5-1 逻辑电路符号</p>]]></content>
    
    
    
    <tags>
      
      <tag>单片机</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>单片机复习——01</title>
    <link href="/2022/06/05/%E5%8D%95%E7%89%87%E6%9C%BA%E5%A4%8D%E4%B9%A0-01/"/>
    <url>/2022/06/05/%E5%8D%95%E7%89%87%E6%9C%BA%E5%A4%8D%E4%B9%A0-01/</url>
    
    <content type="html"><![CDATA[<p>单片机提供给我们可以使用的内部资源。</p><ul><li>Flash：程序存储空间，早期单片机是 OTPROM。</li><li>RAM：数据存储空间。</li><li>SFR：特殊功能寄存器。</li></ul><p><strong>1) Flash</strong> 在早期的单片机中，主要是用 OTPROM（One TimeProgrammable Read-OnlyMemory，即一次可编程只读存储器）来存储单片机的程序，程序只能写入一次，如果发现错了，没办法，只能换一片，重新写入了。随着技术的发展，Flash以其可重复擦写且容量大成本低的优点成为现在绝大多数单片机的程序存储器。对于单片机来说Flash最大的意义是断电后数据不丢失，这个概念类似于我们电脑的硬盘，我们保存了电影、文档、音乐等文件，把电源关掉后，下次重新开电脑，所有的文件都还照样存在。</p><p><strong>2) RAM</strong> RAM是单片机的数据存储空间，用来存储程序运行过程中产生的和需要的数据，跟电脑的内存是相似的概念，其实最典型的比喻是我们的计算器，我们用计算器计算个加减法，一些中间的数据都会保存在RAM里边，关电后数据丢失，所以我们每次打开计算器，都是从归零开始计算。但是它的优点，第一是读写速度非常快，第二是理论上是可无限次写入的，即寿命无限，不管程序怎么运行怎么读写它都不会坏。</p><p><strong>3) SFR</strong> 第三个资源是SFR，特殊功能寄存器。这个概念大家可能刚开始理解不了，但是一定要记住。单片机有很多很多功能，每个功能都会对应一个或多个SFR，我们就是通过对 SFR 的读写来实现单片机的多种多样的功能的。</p><p><strong>单片机最小系统</strong>，也叫做单片机最小应用系统，是指用最少的原件组成单片机可以工作的系统。单片机最小系统的三要素就是<strong>电源、晶振、复位电路</strong>，如图2-1 所示。</p><p><imgsrc="http://c.biancheng.net/cpp/uploads/allimg/140316/1-140316134133918.png"alt="图 2-1 单片机最小系统电路" /> 图 2-1 单片机最小系统电路</p><p>这张最小系统的电路图节选自我们的 KST-51开发板原理图，下面我们就照这张电路图来具体分析最小系统的三要素。</p><h2 id="电源">1) 电源</h2><p>这个很好理解，电子设备都需要供电，就连我们的家用电器（手电筒^_^）也不例外。目前主流单片机的电源分为5V 和 3.3V这两个标准，当然现在还有对电压要求更低的单片机系统，一般多用在一些特定场合，在学习中我们不做过多的关注。</p><p>我们所选用的 STC89C52，它需要 5V 的供电系统，我们的开发板是使用 USB口输出的5V 直流直接供电的。从图 2-1 可以看到，供电电路在 40 脚和 20脚的位置上，40 脚接的是+5V，通常也称为 VCC 或 VDD，代表的是电源正极，20脚接的是 GND，代表的是电源的负极。+5V 和 GND之间还有个电容，作用我们下节课介绍。</p><p>这个地方我们还要普及一个看原理图的知识。<strong>电路原理图</strong>是为了表达这个电路的工作原理而存在的，很多器件在绘制的时候更多考虑的是方便原理分析，而不是表达各个器件实际位置。比如原理图中的单片机引脚图，<strong>引脚的位置我们是可以随意放的，但是每个引脚上有一个数字标号，这个数字标号代表的才是单片机真正的引脚位置</strong>。一般情况下，这种双列直插封装的芯片，左上角是1脚，逆时针旋转引脚号依次增加，一直到右上角是最大脚位，我们现在选用的单片机一共是40 个引脚，因此右上角就是 40（在表示芯片的方框的内部），如图 2-2所示，大家要分清原理图引脚标号和实际引脚位置的区别。</p><p><imgsrc="http://c.biancheng.net/cpp/uploads/allimg/140316/1-14031613441B42.png"alt="图 2-2 单片机封装图" /> 图 2-2 单片机封装图</p><h2 id="晶振">2) 晶振</h2><p>晶振，又叫晶体振荡器，从这个名字我们就可以看出来，它注定一生都要不停振荡的。</p><p>他起到的作用是为单片机系统提供基准时钟信号，类似于我们部队训练时喊口令的人，单片机内部所有的工作都是以这个时钟信号为步调基准来进行工作的。STC89C52单片机的 18 脚和 19 脚是晶振引脚，我们接了一个 11.0592M的晶振（它每秒钟振荡 11,059,200 次），外加两个 20pF的电容，<strong>电容的作用是帮助晶振起振，并维持振荡信号的稳定</strong>。</p><h2 id="复位电路">3) 复位电路</h2><p>在图 2-1 左侧是一个复位电路，接到了单片机的 9 脚RST(Reset)复位引脚上，这个复位电路如何起作用我们后边再讲，现在着重讲一下复位对单片机的作用。单片机复位一般是3种情况：<strong>上电复位、手动复位、程序自动复位</strong>。</p><p>假如我们的单片机程序有 100 行，当某一次运行到第 50行的时候，突然停电了，这个时候单片机内部有的区域数据会丢失掉，有的区域数据可能还没丢失。那么下次打开设备的时候，我们希望单片机能正常运行，所以上电后，单片机要进行一个内部的初始化过程，这个过程就可以理解为上电复位，上电复位保证单片机每次都从一个固定的相同的状态开始工作。这个过程跟我们打开电脑电源开电脑的过程是一致的。</p><p>当我们的程序运行时，如果遭受到意外干扰而导致程序死机，或者程序跑飞的时候，我们就可以按下一个复位按键，让程序重新初始化重新运行，这个过程就叫做手动复位，最典型的就是我们电脑的重启按钮。</p><p>当程序死机或者跑飞的时候，我们的单片机往往有一套自动复位机制，比如看门狗，具体应用以后再了解。在这种情况下，如果程序长时间失去响应，单片机看门狗模块会自动复位重启单片机。还有一些情况是我们程序故意重启复位单片机。</p><p>电源、晶振、复位构成了单片机最小系统的三要素，也就是说，一个单片机具备了这三个条件，就可以运行我们下载的程序了，其他的比如LED小灯、数码管、液晶等设备都是属于单片机的外部设备，即外设。最终完成我们想要的功能就是通过对单片机编程来控制各种各样的外设实现的。</p><h3 id="硬件基础知识学习">硬件基础知识学习</h3><p>第一个知识点，<strong>去耦电容的应用</strong>。首先要介绍一下去耦电容的应用背景，这个背景就是电磁干扰，也就是“传说中”的EMI。</p><ol type="1"><li><p>冬天的时候，尤其是空气比较干燥的内陆城市，很多朋友都有这样的经历，手触碰到电脑外壳、铁柜子等物品的时候会被电击，这就是<strong>静电放电”</strong>现象，也称之为<strong>ESD</strong>。</p></li><li><p>不知道有没有同学有这样的经历，早期我们使用电钻这种电机设备，并且同时在听收音机或者看电视的时候，收音机或者电视会出现杂音，这就是“<strong>快速瞬间群脉冲</strong>”的效果，也称之为<strong>EFT</strong>。</p></li><li><p>以前的老电脑，有的性能不是很好，带电热插拔优盘、移动硬盘等外围设备的时候，内部会产生一个百万分之一秒的电源切换，直接导致电脑出现蓝屏或者重启现象，就是热插拔的“浪涌”效果，称之为Surge。 ......</p></li></ol><p>电磁干扰的内容有很多，我们这里不能一一列举，但是有些内容非常重要，后边我们要一点点的了解。这些问题大家不要认为是小问题，比如一个简单的静电放电，我们用手能感觉到的静电，可能已经达到3KV 以上了，如果用眼睛能看得到的，至少是 5KV了，只是因为这个电压虽然很高，能量却非常小，持续的时间非常短，因此不会对人体造成伤害。但是我们应用的这些半导体元器件就不一样了，一旦瞬间电压过高，就有可能造成器件的损坏。</p><p>而且，即使不损坏，在 2、3里边介绍的两种现象，也已经严重干扰到设备的正常使用了。基于以上的这些问题，就诞生了<strong>电磁兼容(EMC)</strong>这个名词。下节我们仅仅讲一下去耦电容的应用，电磁兼容的处理在今后设计电路，对PCB 画板布局中应用尤为重要，那是后话，暂且不说。</p><p>首先来看图 3-1，这是上节课已经见过的 USB 接口和供电电路。</p><p><imgsrc="http://c.biancheng.net/cpp/uploads/allimg/140316/1-1403161J616114.png"alt="图 3-1 USB 接口和供电电路" /> 图 3-1 USB 接口和供电电路</p><p>左边这张图，过了保险丝以后，接了一个 470uF 的电容C16，右边这张图，经过开关后，接了一个 100uF 的电容 C19，并且并联了一个0.1uF 的电容 C10。其中 <strong>C16 和 C19起到的作用是一样的</strong>，<strong>C10的作用和他们两个不一样</strong>，我们先来介绍这 2 个大一点的电容。</p><p><strong>容值比较大的电容，理论上可以理解成水缸或者水池子</strong>，同时，大家可以直接把电流理解成水流，其实大自然万物的原理都是类似的。</p><p>作用一，<strong>缓冲作用</strong>。当上电的瞬间，电流从电源处流下来的时候，不稳定，容易冲击电子器件，加个电容可以起到缓冲作用。就如同我们直接用水龙头的水浇地，容易冲坏花花草草。我们只需要在水龙头处加个水池，让水经过水池后再缓慢流进草地，就不会冲坏花草，起到有效的保护作用。</p><p>作用二，<strong>稳定作用</strong>。我们的一整套电路，后级电子器件的功率大小都不一样，而器件正常工作的时候，所需电流的大小也不是一成不变的。比如后级有个器件还没有工作的时候，电流消耗是100mA，突然它参与工作了，电流猛的增大到了150mA，这个时候如果没有一个水缸的话，电路中的电压（水位）就会直接突然下降，比如我们的5V 电压突然降低到3V了。而我们系统中有些电子元器件，必须高于一定的电压才能正常工作，电压太低就直接不工作了，这个时候水缸就必不可少了。电容会在这个时候把存储在里边的电量释放一下，稳定电压，当然，随后前级的电流会及时把水缸充满的。</p><p>有了这个电容，可以说我们的电压和电流就会很稳定了，不会产生大的波动。这种电容常用的有如图3-2、图 3-3、图 3-4 所示三种：</p><p><imgsrc="http://c.biancheng.net/cpp/uploads/allimg/140316/1-1403161JT4Z6.png"alt="图 3-2 铝电解电容" /> 图 3-2 铝电解电容</p><p><imgsrc="http://c.biancheng.net/cpp/uploads/allimg/140316/1-1403161J955125.png"alt="图 3-3 钽电容" /> <imgsrc="http://c.biancheng.net/cpp/uploads/allimg/140316/1-1403161K051129.png"alt="图 3-4 陶瓷电容" /> 图 3-3 钽电容 图 3-4 陶瓷电容</p><p>这三种电容是最常用的三种，其中第一种个头大，占空间大，单位容量价格最便宜，第二种和第三种个头小，占空间小，性能一般也略好于第一种，但是价格也贵不少。当然，除了价格，还有一些特殊参数，在通信要求高的场合也要考虑很多，这里暂且不说。我们板子上现在用的是第一种，在同样的符合条件的耐压值和容值下，第一种 470uF的电容不到一毛钱，而第二种和第三种可能要 1 块钱左右了。</p><p>电容的选取，第一个参数是<strong>耐压值的考虑</strong>。我们用的是 5V系统，电容的耐压值要高于5V，<strong>一般推荐 1.5 倍到 2倍即可</strong>，有些场合稍微再高点也可以。我们板子上用的是 10V耐压的。第二个参数是<strong>电容容值</strong>，这个就需要根据经验来选取了，选取的时候，要看这个电容起作用的<strong>整套系统的功率消耗情况</strong>，如果系统耗电较大，波动可能比较大，那么容值就要选大一些，反之可以小一些。</p><p>同学们刚开始设计电路也是要模仿别人，别人用多大自己也用多大，慢慢积累。比如咱上边讲电容作用二的时候，电流从100mA 突然增大到 150mA的时候，其实即使加上这个电容，电压也会轻微波动，比如从 5V 波动到4.9V，但是只要我们板子上的器件在电压 4.9V以上也可以正常工作的话，这点波动是被容许的，但是如果不加或者加的很小，电压波动比较大，有些器件的工作就会不正常了。但是如果加的太大，占空间并且价格也高，所以这个地方电容的选取多参考经验。</p><p>我们再来看图 3-1 中的另一种电容 C10，它容值较小，是 0.1uF，也就是100nF，是用来<strong>滤除高频信号干扰的</strong>。比如 ESD，EFT等。我们初中学过电容的特性——可以通交流隔直流，但是电容的参数对不同频率段的干扰的作用是不一样的。这个100nF的电容，是我们的前辈根据干扰的频率段，根据板子的参数，根据电容本身的参数所总结出来的一个值。也就是说，以后大家在设计数字电路的时候，在电源处的去耦高频电容，直接用这个0.1uF 就可以了，不需要再去计算和考量太多。</p><h3 id="单片机中三极管的应用">单片机中三极管的应用</h3><p>极管在数字电路里的开关特性，最常见的应用有 2个：<strong>一个是控制应用，一个是驱动应用</strong>。所谓的控制就是如图3-7里边介绍的，我们可以通过单片机控制三极管的基极来间接控制后边的小灯的亮灭，用法大家基本熟悉了。还有一个控制就是<strong>进行不同电压之间的转换控制</strong>，比如我们的单片机是5V 系统，它现在要跟一个 12V 的系统对接，如果 IO 直接接12V电压就会烧坏单片机，所以我们加一个三极管，三极管的工作电压高于单片机的IO 口电压，用 5V 的 IO 口来控制 12V 的电路，如图 3-8 所示。</p><p><imgsrc="http://c.biancheng.net/cpp/uploads/allimg/140316/1-1403161QI3601.png"alt="图 3-8 三极管实现电压转换" /> 图 3-8 三极管实现电压转换</p><p>图 3-8 中，当 IO 口输出高电平 5V 时，三极管导通，OUT 输出低电平0V，当 IO 口输出低电平时，三极管截止，OUT 则由于上拉电阻 R2 的作用而输出12V 的高电平，这样就实现了低电压控制高电压的工作原理。</p><p><strong>所谓的驱动，主要是指电流输出能力</strong>。我们再来看如图 3-9中两个电路之间的对比。</p><p><imgsrc="http://c.biancheng.net/cpp/uploads/allimg/140316/1-1403161QU0M4.png"alt="图 3-9 LED 小灯控制方式对比" /> 图 3-9 LED 小灯控制方式对比</p><p>图 3-9 中上边的 LED 灯，和我们第二课讲过的 LED 灯是一样的，当 IO口是高电平时，小灯熄灭，当 IO口是低电平时，小灯点亮。那么<strong>下边的电路呢，按照这种推理，IO口是高电平的时候，应该有电流流过并且点亮小灯，但实际上却并非这么简单</strong>。</p><p>单片机主要是个控制器件，具备四两拨千斤的特点。就如同杠杆必须有一个支点一样，想要撑起整个地球必须有力量承受的支点。<strong>单片机的IO 口可以输出一个高电平，但是他的输出电流却很有限，普通 IO口输出高电平的时候，大概只有几十到几百 uA的电流，达不到1mA</strong>，也就点不亮这个 LED小灯或者是亮度很低，这个时候如果我们想用高电平点亮LED，就可以用上三极管来处理了，我们板上的这种三极管型号，可以通过 500mA的电流，有的三极管通过的电流还更大一些，如图 3-10 所示。</p><p><imgsrc="http://c.biancheng.net/cpp/uploads/allimg/140316/1-1403161R020N2.png"alt="图 3-10 三极管驱动 LED 小灯" /> 图 3-10 三极管驱动 LED 小灯</p><p>图 3-10 中，当 IO 口是高电平，三极管导通，因为三极管的电流放大作用，c极电流就可以达到 mA 以上了，就可以成功点亮 LED 小灯。</p><p>虽然我们用了 <strong>IO 口的低电平可以直接点亮 LED，但是单片机的 IO口作为低电平，输入电流就可以很大吗？</strong>这个我想大家都能猜出来，当然不可以。单片机的IO 口电流承受能力，不同型号不完全一样，就 STC89C52 来说，官方手册的 81页有对电气特性的介绍，整个单片机的工作电流，不要超过 50mA，单个 IO口总电流不要超过 6mA。即使一些增强型 51 的IO 口承受电流大一点，可以到25mA，但是还要受到总电流 50mA 的限制。那我们来看电路图的 8 个 LED小灯这部分电路，如图 3-11 所示。</p><p><imgsrc="http://c.biancheng.net/cpp/uploads/allimg/140316/1-1403161R2112K.png"alt="图 3-11 LED 电路图（一）" /> 图 3-11 LED 电路图（一）</p><p>这里我们要学会看电路图的一个知识点，电路图右侧所有的 LED下侧的线最终都连到一根黑色的粗线上去了，大家注意，<strong>这个地方不是实际的完全连到一起，而是一种总线的画法，画了这种线以后，表示这是个总线结构</strong>。而所有的名字一样的节点是<strong>一一对应的连接到一起，其他名字不一样的，是不连在一起的</strong>。比如左侧的DB0 和右侧的最右边的 LED2 小灯下边的DB0 是连在一起的，而和 DB1等其他线不是连在一起的。</p><p>那么我们把图 3-11 中现在需要讲解的这部分单独摘出来看，如图 3-12所示。</p><p><imgsrc="http://c.biancheng.net/cpp/uploads/allimg/140316/1-1403161R32W52.png"alt="图 3-12 LED 电路图（二）" /> 图 3-12 LED 电路图（二）</p><p>现在我们通过 3-12 的电路图来计算一下，5V 的电压减去 LED本身的压降，减掉三极管e 和 c 之间的压降，限流电阻用的是 330欧，那么每条支路的电流大概是 8mA，那么 8 路LED如果全部同时点亮的话电流总和就是64mA。这样如果<strong>直接接到单片机的 IO口，那单片机肯定是承受不了的</strong>，即使短时间可以承受，长时间工作就会不稳定，甚至导致单片机烧毁。</p><p>有的同学会提出来可以加大限流电阻的方式来降低这个电流。比如改到1K，那么电流不到 3mA，8 路总的电流就是 20mA 左右。首先，降低电流会导致LED小灯亮度变暗，小灯的亮度可能关系还不大，但因为我们同样的电路接了数码管，后边我们要讲数码管还要动态显示，如果数码管亮度不够的话，那视觉效果就会很差，所以降低电流的方法并不可取。其次，<strong>对于单片机来说，他主要是起到控制作用，电流输入和输出的能力相对较弱</strong>，P0的 8 个口总电流也有一定限制，所以如果接一两个 LED小灯观察，可以勉强直接用单片机的 IO口来接，但是接多个小灯，从实际工程的角度去考虑，就不推荐直接接 IO口了。那么我们如果要用单片机控制多个 LED 小灯该怎么办呢？</p><p><strong>除了三极管之外，其实还有一些驱动 IC</strong>，这些驱动 IC可以作为单片机的缓冲器，仅仅是电流驱动缓冲，不起到任何逻辑控制的效果，比如我们板子上用的74HC245这个芯片，这个芯片在逻辑上起不到什么别的作用，就是当做电流缓冲器的，我们通过查看其数据手册，74HC245稳定工作在 70mA 电流是没有问题的，比单片机的 8 个 IO口大多了，所以我们可以把他接在小灯和 IO 口之间做缓冲，如图 3-13所示。</p><p><imgsrc="http://c.biancheng.net/cpp/uploads/allimg/140316/1-1403161R534E8.png"alt="图 3-13 74HC245 功能图" /> 图 3-13 74HC245 功能图</p><p>从图 3-13 我们来分析，其中 VCC 和 GND就不用多说了，细心的同学会发现这里有个0.1uF 的去耦电容哦。</p><p><strong>74HC245 是个双向缓冲器</strong>，1 引脚 DIR是<strong>方向引脚</strong>，当这个引脚接高电平的时候，右侧所有的 B编号的电压都等于左侧 A 编号对应的电压。比如 A1 是高电平，那么 B1就是高电平，A2 是低电平，B2 就是低电平等等。如果 DIR引脚接低电平，得到的效果是左侧 A 编号的电压都会等于右侧 B编号对应的电压。因为我们这个地方控制端是左侧接的是 P0 口，我们要求 B等于 A 的状态，所以 1 脚我们直接接的 5V 电源，即高电平。图 3-13中还有一排电阻 R10 到 R17 是上拉电阻，这个电阻的用法我们在后边介绍。</p><p>还有最后一个使能引脚 19 脚OE，叫做<strong>输出使能</strong>，这个<strong>引脚上边有一横，表明是低电平有效，当接了低电平后</strong>，74HC245就会按照刚才上边说的起到双向缓冲器的作用，如果 OE接了高电平，那么无论DIR 怎么接，A 和 B 的引脚是没有关系的，也就是 74HC245功能不能实现出来。</p><p>从下面的图 3-14 可以看出来，单片机的 P0 口和 74HC245 的 A端是直接接起来的。这个地方，有个别同学有个疑问，就是我们明明在<strong>电源VCC 那地方加了一个三极管驱动了，为何还要再加 245驱动芯片呢</strong>。这里大家要理解一个道理，电路上从正极经过器件到地，首先必须有电流才能正常工作，电路中任何一个位置断开，都不会有电流，器件也就不会参与工作了。其次，和水流一个道理，从电源正极到负极的电流水管的粗细都要满足要求，任何一个位置的管子过细，都会出现瓶颈效应，电流在整个通路中细管处会受到限制而降低，所以在电路通路的每个位置上，都要保证通道足够畅通，这个74HC245 的作用就是消除单片机IO 这一环节的瓶颈。</p><p><imgsrc="http://c.biancheng.net/cpp/uploads/allimg/140316/1-1403161RJ2a2.png"alt="图 3-14 单片机与 74HC245 的连接" /> 图 3-14 单片机与 74HC245的连接</p><h3id="单片机中74hc138三八译码器的应用">单片机中74HC138三八译码器的应用</h3><p>在我们设计单片机电路的时候，单片机的 IO口数量是有限的，有时并满足不了我们的设计需求，比如我们的 STC89C52 一共有32 个 IO口，但是我们<strong>为了控制更多的器件，就要使用一些外围的数字芯片</strong>，这种数字芯片由简单的输入逻辑来控制输出逻辑，比如74HC138这个三八译码器，图 3-15 是 74HC138 在我们原理图上的一个应用。</p><p><imgsrc="http://c.biancheng.net/cpp/uploads/allimg/140316/1-1403161S41A38.png"alt="图 3-15 74HC138 应用原理图" /> 图 3-15 74HC138 应用原理图</p><p>从这个名字来分析，<strong>三八译码器，就是把 3 种输入状态翻译成 8种输出状态</strong>。从图 3-15所能看出来的，74HC138 有 1～6 一共是 6个输入引脚，但是<strong>其中 4、5、6这三个引脚是使能引脚</strong>。使能引脚和我们前边讲 74HC245 的 OE引脚是一样的，这三个引脚如果不符合规定的输入要求，Y0 到 Y7 不管你输入的1、2、3 引脚是什么电平状态，总是高电平。所以我们要想让这个 74HC138正常工作，ENLED 那个输入位置必须输入低电平，ADDR3位置必须输入高电平，这两个位置都是使能控制端口。不知道大家是否记得我们第二课的程序有这么两句ENLED = 0；ADDR3 = 1；就是控制使这个 74HC138 使能的。</p><p>这类逻辑芯片，大多都是有使能引脚的，使能符合要求了，那下面就要研究控制逻辑了。对于数字器件的引脚，如果一个引脚输入的时候，有0 和 1 两种状态；对于两个引脚输入的时候，就会有 00、01、10、11这四种状态了，那么对于 3 个输入的时候，就会出现 8种状态了，大家可以看下边的这个真值表——图 3-16，其中输入是 A2、A1、A0的顺序，输出是从Y0、Y1......Y7 的顺序。</p><p><imgsrc="http://c.biancheng.net/cpp/uploads/allimg/140316/1-1403161S64M60.png"alt="图 3-16 74HC138 真值表" /> 图 3-16 74HC138 真值表</p><p>从图 3-16可以看出，<strong>任一输入状态下，只有一个输出引脚是低电平，其他的引脚都是高电平</strong>。在前面的电路中我们已经看到，8个 LED 小灯的总开关三极管 Q16 基极的控制端是LEDS6，也就是 Y6输出一个低电平的时候，可以开通三极管Q16，从右侧的希望输出的结果，我们可以推导出我们的 A2、A1、A0的输入状态应该是 110，如图 3-17。</p><p><imgsrc="http://c.biancheng.net/cpp/uploads/allimg/140316/1-1403161SKNQ.png"alt="图 3-17 LED 小灯整体电路图" /> 图 3-17 LED 小灯整体电路图</p><p>那么我们再整体捋一遍点亮 LED 小灯的过程，首先看 74HC138，我们要让LEDS6 为低电平才能导通三极管 Q16，所以 ENLED = 0;ADDR3 = 1;保证 74HC138使能。然后 ADDR2 =1; ADDR1 = 1; ADDR0 = 0;这样保证了三极管 Q16这个开关开通，5V 电源加到 LED 上。</p><p>而 74HC245 左侧是通过 P0 口控制，我们让 P0.0 引脚等于 0，就是 DB_0等于 0，而右侧 DB0 等于 DB_0 的状态，也是 0，那么这样在这一排共 8 个 LED小灯当中，只有最右侧的小灯和 5V之间有压差，有压差就会有电流通过，有电流通过我们的 LED2 就会发光了。</p><p>74HC245 左侧我们可以看出来，是直接接到 P0 口上的，而 74HC138 的 ADDR0~ ADDR3接在何处呢？来看图 3-18。</p><p><imgsrc="http://c.biancheng.net/cpp/uploads/allimg/140316/1-1403161S92U04.png"alt="图 3-18 显示译码与步进电机的选择跳线" /> 图 3-18显示译码与步进电机的选择跳线</p><p><strong>跳线是大家以后经常会接触到的一个器件</strong>，它就是 2根或者 3 根靠在一起的排针，然后可以用一个叫作跳线帽的东西连接其相邻的 2根针。它的作用就是起到导线的作用，我们可以通过<strong>跳线帽来实现连接线的切换</strong>。如图3-19。</p><p><imgsrc="http://c.biancheng.net/cpp/uploads/allimg/140316/1-1403161T0363L.png"alt="图3-19 跳线实物图" /> 图3-19 跳线实物图</p><p>从图中可以看出，跳线帽本身可以占 2个针的位置，现在是把右侧和中间的针连到了一起，这样实现的就是图 3-18 中的P1.0 和 ADDR0 连接到一起、P1.1 和 ADDR1 接一起、P1.2和 ADDR2接一起、P1.3 和 ADDR3 接一起。这样就可以透彻理解我们第二课的程序了。</p>]]></content>
    
    
    
    <tags>
      
      <tag>单片机</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>结构体共用体内存</title>
    <link href="/2022/05/31/%E7%BB%93%E6%9E%84%E4%BD%93%E5%85%B1%E7%94%A8%E4%BD%93%E5%86%85%E5%AD%98/"/>
    <url>/2022/05/31/%E7%BB%93%E6%9E%84%E4%BD%93%E5%85%B1%E7%94%A8%E4%BD%93%E5%86%85%E5%AD%98/</url>
    
    <content type="html"><![CDATA[<p><strong>结构体的内存计算 struct</strong></p><p>思路: 结构体的每个成员的字节相加, 然后注意一下字节对齐</p><p>解析在注释中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span>&#123;</span><br><span class="hljs-type">char</span> a[<span class="hljs-number">5</span>];<span class="hljs-comment">//占5字节</span><br><span class="hljs-type">int</span> b;<span class="hljs-comment">//占4字节</span><br><span class="hljs-comment">//结构体的计算就是 5+4 = 9, 但是9不是最大类型int(4字节的倍数), 就会补齐到12字节, (只有12除以4才能整除)</span><br><span class="hljs-comment">//内存结构就是: aaaa a空空空 bbbb</span><br><span class="hljs-comment">//空就是补齐的内存, 每隔4个一组, 因为int是4字节</span><br>&#125;too;<br>too bb;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span>&#123;</span><br><span class="hljs-type">char</span> a[<span class="hljs-number">5</span>];<span class="hljs-comment">//占5字节</span><br><span class="hljs-type">double</span> b;<span class="hljs-comment">//占8字节</span><br><span class="hljs-comment">//内存就是: 5+8 = 13, 最大类型是double(8字节), 所以要补齐到16字节</span><br><span class="hljs-comment">//内存结构: aaaaa空空空 bbbbbbbb</span><br><span class="hljs-comment">//因为double是8字节, 所以8个一组</span><br>&#125;too1;<br>too1 bb1;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span>&#123;</span><br><span class="hljs-type">char</span> a[<span class="hljs-number">5</span>];<span class="hljs-comment">//占5字节</span><br><span class="hljs-comment">//内存就是: 5, 最大字节类型就是char(1字节), 5除以1能整除, 就不用补齐</span><br>&#125;too2;<br>too2 bb2; <br></code></pre></td></tr></table></figure><p>printf("%d",sizeof(bb));</p><p>printf("%d",sizeof(bb1));</p><p>printf("%d",sizeof(bb2));</p><p>输出结果就是: 12 ,16, 5</p><p><strong>共用体的内存计算 union</strong></p><p>思路: 共用体的成员共用内存,所以找最大内存的数据类型,并且能被最大类型整除就行了,并且也要注意字节对齐</p><p>解析在注释中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">union</span>&#123;</span><br><span class="hljs-type">char</span> a[<span class="hljs-number">5</span>];<span class="hljs-comment">//占5字节</span><br><span class="hljs-type">int</span> b;<span class="hljs-comment">//占4字节</span><br><span class="hljs-comment">//最大成员是5字节, 最大数据类型4字节,  对齐后就是 8字节 (可以被4字节整除)</span><br>&#125;uu;<br>uu u1;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">union</span>&#123;</span><br><span class="hljs-type">char</span> a[<span class="hljs-number">9</span>];<span class="hljs-comment">//占9字节</span><br><span class="hljs-type">int</span> b;<span class="hljs-comment">//占4字节</span><br><span class="hljs-type">double</span> c;<span class="hljs-comment">//占8字节</span><br><span class="hljs-comment">//最大的内存是9字节, 最大数据类型是8字节, 对齐后就是 16字节</span><br>&#125;uu2;<br>uu2 u2; <br></code></pre></td></tr></table></figure><p>printf("%d",sizeof(u1));</p><p>printf("%d",sizeof(u2));</p><p>输出结果是: 8,16</p>]]></content>
    
    
    
    <tags>
      
      <tag>C语言</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据结构——01</title>
    <link href="/2022/05/31/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E2%80%9401/"/>
    <url>/2022/05/31/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E2%80%9401/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>algorithm_day1</title>
    <link href="/2022/05/30/algorithm-day1/"/>
    <url>/2022/05/30/algorithm-day1/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>搭建CPP服务器_03</title>
    <link href="/2022/05/30/%E6%90%AD%E5%BB%BACPP%E6%9C%8D%E5%8A%A1%E5%99%A8-03/"/>
    <url>/2022/05/30/%E6%90%AD%E5%BB%BACPP%E6%9C%8D%E5%8A%A1%E5%99%A8-03/</url>
    
    <content type="html"><![CDATA[<p>在上一天，我们写了一个简单的echo服务器，但只能同时处理一个客户端的连接。但在这个连接的生命周期中，绝大部分时间都是空闲的，活跃时间（发送数据和接收数据的时间）占比极少，这样独占一个服务器是严重的资源浪费。事实上所有的服务器都是高并发的，可以同时为成千上万个客户端提供服务，这一技术又被称<strong>IO复用</strong>。</p><blockquote><p>IO复用和多线程有相似之处，但绝不是一个概念。IO复用是针对IO接口，而多线程是针对CPU。</p></blockquote><p>IO复用的基本思想是事件驱动，服务器同时保持多个客户端IO连接，当这个IO上有可读或可写事件发生时，表示这个IO对应的客户端在请求服务器的某项服务，此时服务器响应该服务。<strong>在Linux系统中，IO复用使用select,poll和epoll来实现</strong>。epoll改进了前两者，更加高效、性能更好，是目前几乎所有高并发服务器的基石。请读者务必先掌握epoll的原理再进行编码开发。</p><blockquote><p>select,poll与epoll的详细原理和区别请参考《UNIX网络编程：卷1》第二部分第六章，游双《Linux高性能服务器编程》第九章</p></blockquote><p>epoll主要由三个系统调用组成：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//int epfd = epoll_create(1024);  //参数表示监听事件的大小，如超过内核会自动调整，已经被舍弃，无实际意义，传入一个大于0的数即可</span><br><span class="hljs-type">int</span> epfd = <span class="hljs-built_in">epoll_create1</span>(<span class="hljs-number">0</span>);       <span class="hljs-comment">//参数是一个flag，一般设为0，详细参考man epoll</span><br></code></pre></td></tr></table></figure><p>创建一个epoll文件描述符并返回，失败则返回-1。</p><p>epoll监听事件的描述符会放在一颗红黑树上，我们将要监听的IO口放入epoll红黑树中，就可以监听该IO上的事件。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">epoll_ctl</span>(epfd, EPOLL_CTL_ADD, sockfd, &amp;ev);    <span class="hljs-comment">//添加事件到epoll</span><br><span class="hljs-built_in">epoll_ctl</span>(epfd, EPOLL_CTL_MOD, sockfd, &amp;ev);    <span class="hljs-comment">//修改epoll红黑树上的事件</span><br><span class="hljs-built_in">epoll_ctl</span>(epfd, EPOLL_CTL_DEL, sockfd, <span class="hljs-literal">NULL</span>);   <span class="hljs-comment">//删除事件</span><br></code></pre></td></tr></table></figure><p>其中sockfd表示我们要添加的IO文件描述符，ev是一个epoll_event结构体，其中的events表示事件，如EPOLLIN等，data是一个用户数据union:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">union</span> <span class="hljs-title class_">epoll_data</span> &#123;<br>  <span class="hljs-type">void</span> *ptr;<br>  <span class="hljs-type">int</span> fd;<br>  <span class="hljs-type">uint32_t</span> u32;<br>  <span class="hljs-type">uint64_t</span> u64;<br>&#125; <span class="hljs-type">epoll_data_t</span>;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">epoll_event</span> &#123;<br>  <span class="hljs-type">uint32_t</span> events;<span class="hljs-comment">/* Epoll events */</span><br>  <span class="hljs-type">epoll_data_t</span> data;<span class="hljs-comment">/* User data variable */</span><br>&#125; __EPOLL_PACKED;<br></code></pre></td></tr></table></figure><p>epoll默认采用LT触发模式，即水平触发，只要fd上有事件，就会一直通知内核。这样可以保证所有事件都得到处理、不容易丢失，但可能发生的大量重复通知也会影响epoll的性能。如使用ET模式，即边缘触法，fd从无事件到有事件的变化会通知内核一次，之后就不会再次通知内核。这种方式十分高效，可以大大提高支持的并发度，但程序逻辑必须一次性很好地处理该fd上的事件，编程比LT更繁琐。注意ET模式必须搭配非阻塞式socket使用。</p><blockquote><p>非阻塞式socket和阻塞式有很大的不同，请参考《UNIX网络编程：卷1》第三部分第16章。</p></blockquote><p>我们可以随时使用<code>epoll_wait</code>获取有事件发生的fd：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> nfds = <span class="hljs-built_in">epoll_wait</span>(epfd, events, maxevents, timeout);<br></code></pre></td></tr></table></figure><p>其中events是一个epoll_event结构体数组，maxevents是可供返回的最大事件大小，一般是events的大小，timeout表示最大等待时间，设置为-1表示一直等待。</p><p>接下来将day02的服务器改写成epoll版本，基本思想为：在创建了服务器socketfd后，将这个fd添加到epoll，只要这个fd上发生可读事件，表示有一个新的客户端连接。然后accept这个客户端并将客户端的socketfd添加到epoll，epoll会监听客户端socketfd是否有事件发生，如果发生则处理事件。</p><p>接下来的教程在伪代码中：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> sockfd = <span class="hljs-built_in">socket</span>(...);   <span class="hljs-comment">//创建服务器socket fd</span><br><span class="hljs-built_in">bind</span>(sockfd...);<br><span class="hljs-built_in">listen</span>(sockfd...);<br><span class="hljs-type">int</span> epfd = <span class="hljs-built_in">epoll_create1</span>(<span class="hljs-number">0</span>);<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">epoll_event</span> events[MAX_EVENTS], ev;<br>ev.events = EPOLLIN;    <span class="hljs-comment">//在代码中使用了ET模式，且未处理错误，在day12进行了修复，实际上接受连接最好不要用ET模式</span><br>ev.data.fd = sockfd;    <span class="hljs-comment">//该IO口为服务器socket fd</span><br><span class="hljs-built_in">epoll_ctl</span>(epfd, EPOLL_CTL_ADD, sockfd, &amp;ev);    <span class="hljs-comment">//将服务器socket fd添加到epoll</span><br><span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;    <span class="hljs-comment">// 不断监听epoll上的事件并处理</span><br>    <span class="hljs-type">int</span> nfds = <span class="hljs-built_in">epoll_wait</span>(epfd, events, MAX_EVENTS, <span class="hljs-number">-1</span>);   <span class="hljs-comment">//有nfds个fd发生事件</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nfds; ++i)&#123;  <span class="hljs-comment">//处理这nfds个事件</span><br>        <span class="hljs-keyword">if</span>(events[i].data.fd == sockfd)&#123;    <span class="hljs-comment">//发生事件的fd是服务器socket fd，表示有新客户端连接</span><br>            <span class="hljs-type">int</span> clnt_sockfd = <span class="hljs-built_in">accept</span>(sockfd, (sockaddr*)&amp;clnt_addr, &amp;clnt_addr_len);<br>            ev.data.fd = clnt_sockfd;   <br>            ev.events = EPOLLIN | EPOLLET;  <span class="hljs-comment">//对于客户端连接，使用ET模式，可以让epoll更加高效，支持更多并发</span><br>            <span class="hljs-built_in">setnonblocking</span>(clnt_sockfd);    <span class="hljs-comment">//ET需要搭配非阻塞式socket使用</span><br>            <span class="hljs-built_in">epoll_ctl</span>(epfd, EPOLL_CTL_ADD, clnt_sockfd, &amp;ev);   <span class="hljs-comment">//将该客户端的socket fd添加到epoll</span><br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(events[i].events &amp; EPOLLIN)&#123;      <span class="hljs-comment">//发生事件的是客户端，并且是可读事件（EPOLLIN）</span><br>            <span class="hljs-built_in">handleEvent</span>(events[i].data.fd);         <span class="hljs-comment">//处理该fd上发生的事件</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>从一个非阻塞式socket fd上读取数据时：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;    <span class="hljs-comment">//由于使用非阻塞IO，需要不断读取，直到全部读取完毕</span><br>    <span class="hljs-type">ssize_t</span> bytes_read = <span class="hljs-built_in">read</span>(events[i].data.fd, buf, <span class="hljs-built_in">sizeof</span>(buf));<br>    <span class="hljs-keyword">if</span>(bytes_read &gt; <span class="hljs-number">0</span>)&#123;<br>      <span class="hljs-comment">//保存读取到的bytes_read大小的数据</span><br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(bytes_read == <span class="hljs-number">-1</span> &amp;&amp; errno == EINTR)&#123;  <span class="hljs-comment">//客户端正常中断、继续读取</span><br>        <span class="hljs-keyword">continue</span>;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(bytes_read == <span class="hljs-number">-1</span> &amp;&amp; ((errno == EAGAIN) || (errno == EWOULDBLOCK)))&#123;<span class="hljs-comment">//非阻塞IO，这个条件表示数据全部读取完毕</span><br>        <span class="hljs-comment">//该fd上数据读取完毕</span><br>        <span class="hljs-keyword">break</span>;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(bytes_read == <span class="hljs-number">0</span>)&#123;  <span class="hljs-comment">//EOF事件，一般表示客户端断开连接</span><br>        <span class="hljs-built_in">close</span>(events[i].data.fd);   <span class="hljs-comment">//关闭socket会自动将文件描述符从epoll树上移除</span><br>        <span class="hljs-keyword">break</span>;<br>    &#125; <span class="hljs-comment">//剩下的bytes_read == -1的情况表示其他错误，这里没有处理</span><br>&#125;<br></code></pre></td></tr></table></figure><p>至此，day03的主要教程已经结束了，完整源代码请在<code>code/day03</code>文件夹，接下来看看今天的学习成果以及测试我们的服务器！</p><p>进入<code>code/day03</code>文件夹，使用make命令编译，将会得到<code>server</code>和<code>client</code>，输入命令<code>./server</code>开始运行服务器。然后在一个新终端输入命令<code>./client</code>运行客户端，可以看到服务器接收到了客户端的连接请求，并成功连接。再新开一个或多个终端，运行client，可以看到这些客户端也同时连接到了服务器。此时我们在任意一个client输入一条信息，服务器都显示并发送到该客户端。如使用<code>control+c</code>终止掉某个client，服务器回显示这个client已经断开连接，但其他client并不受影响。</p><p>至此，我们已经完整地开发了一个echo服务器，并且支持多个客户端同时连接，为他们提供服务！</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>搭建CPP服务器_02</title>
    <link href="/2022/05/28/%E6%90%AD%E5%BB%BACPP%E6%9C%8D%E5%8A%A1%E5%99%A8-02/"/>
    <url>/2022/05/28/%E6%90%AD%E5%BB%BACPP%E6%9C%8D%E5%8A%A1%E5%99%A8-02/</url>
    
    <content type="html"><![CDATA[<p>在《EffectiveC++》中条款08讲到，别让异常逃离析构函数。在这里我拓展一下，我们不应该放过每一个异常，否则在大型项目开发中一定会遇到很难定位的bug！</p><blockquote><p>具体信息可以参考《Effective C++》原书条款08，这里不再赘述。</p></blockquote><p>对于Linux系统调用，常见的错误提示方式是使用返回值和设置errno来说明错误类型。</p><blockquote><p>详细的C++语言异常处理请参考《C++ Primer》第五版第五章第六节</p></blockquote><p>通常来讲，当一个系统调用返回-1，说明有error发生。我们来看看socket编程最常见的错误处理模版：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> sockfd = <span class="hljs-built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="hljs-number">0</span>);<br><span class="hljs-keyword">if</span>(sockfd == <span class="hljs-number">-1</span>)<br>&#123;<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;socket create error&quot;</span>);<br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">-1</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>为了处理一个错误，需要至少占用五行代码，这使编程十分繁琐，程序也不好看，异常处理所占篇幅比程序本身都多。</p><p>为了方便编码以及代码的可读性，可以封装一个错误处理函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">errif</span><span class="hljs-params">(<span class="hljs-type">bool</span> condition, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *errmsg)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(condition)&#123;<br>        <span class="hljs-built_in">perror</span>(errmsg);<br>        <span class="hljs-built_in">exit</span>(EXIT_FAILURE);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>第一个参数是是否发生错误，如果为真，则表示有错误发生，会调用<code>&lt;stdio.h&gt;</code>头文件中的<code>perror</code>，这个函数会打印出<code>errno</code>的实际意义，还会打印出我们传入的字符串，也就是第函数第二个参数，让我们很方便定位到程序出现错误的地方。然后使用<code>&lt;stdlib.h&gt;</code>中的<code>exit</code>函数让程序退出并返回一个预定义常量<code>EXIT_FAILURE</code>。</p><p>在使用的时候:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> sockfd = <span class="hljs-built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="hljs-number">0</span>);<br><span class="hljs-built_in">errif</span>(sockfd == <span class="hljs-number">-1</span>, <span class="hljs-string">&quot;socket create error&quot;</span>);<br></code></pre></td></tr></table></figure><p>这样我们只需要使用一行进行错误处理，写起来方便简单，也输出了自定义信息，用于定位bug。</p><p>对于所有的函数，我们都使用这种方式处理错误：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">errif</span>(<span class="hljs-built_in">bind</span>(sockfd, (sockaddr*)&amp;serv_addr, <span class="hljs-built_in">sizeof</span>(serv_addr)) == <span class="hljs-number">-1</span>, <span class="hljs-string">&quot;socket bind error&quot;</span>);<br><span class="hljs-built_in">errif</span>(<span class="hljs-built_in">listen</span>(sockfd, SOMAXCONN) == <span class="hljs-number">-1</span>, <span class="hljs-string">&quot;socket listen error&quot;</span>);<br><span class="hljs-type">int</span> clnt_sockfd = <span class="hljs-built_in">accept</span>(sockfd, (sockaddr*)&amp;clnt_addr, &amp;clnt_addr_len);<br><span class="hljs-built_in">errif</span>(clnt_sockfd == <span class="hljs-number">-1</span>, <span class="hljs-string">&quot;socket accept error&quot;</span>);<br><span class="hljs-built_in">errif</span>(<span class="hljs-built_in">connect</span>(sockfd, (sockaddr*)&amp;serv_addr, <span class="hljs-built_in">sizeof</span>(serv_addr)) == <span class="hljs-number">-1</span>, <span class="hljs-string">&quot;socket connect error&quot;</span>);<br></code></pre></td></tr></table></figure><p>到现在最简单的错误处理函数已经封装好了，但这仅仅用于本教程的开发，在真实的服务器开发中，错误绝不是一个如此简单的话题。</p><p>当我们建立一个socket连接后，就可以使用<code>&lt;unistd.h&gt;</code>头文件中<code>read</code>和<code>write</code>来进行网络接口的数据读写操作了。</p><blockquote><p>这两个函数用于TCP连接。如果是UDP，需要使用<code>sendto</code>和<code>recvfrom</code>，这些函数的详细用法可以参考游双《Linux高性能服务器编程》第五章第八节。</p></blockquote><p>接下来的教程用注释的形式写在代码中，先来看服务器代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>    <span class="hljs-type">char</span> buf[<span class="hljs-number">1024</span>];     <span class="hljs-comment">//定义缓冲区</span><br>    <span class="hljs-built_in">bzero</span>(&amp;buf, <span class="hljs-built_in">sizeof</span>(buf));       <span class="hljs-comment">//清空缓冲区</span><br>    <span class="hljs-type">ssize_t</span> read_bytes = <span class="hljs-built_in">read</span>(clnt_sockfd, buf, <span class="hljs-built_in">sizeof</span>(buf)); <span class="hljs-comment">//从客户端socket读到缓冲区，返回已读数据大小</span><br>    <span class="hljs-keyword">if</span>(read_bytes &gt; <span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;message from client fd %d: %s\n&quot;</span>, clnt_sockfd, buf);  <br>        <span class="hljs-built_in">write</span>(clnt_sockfd, buf, <span class="hljs-built_in">sizeof</span>(buf));           <span class="hljs-comment">//将相同的数据写回到客户端</span><br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(read_bytes == <span class="hljs-number">0</span>)&#123;             <span class="hljs-comment">//read返回0，表示EOF</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;client fd %d disconnected\n&quot;</span>, clnt_sockfd);<br>        <span class="hljs-built_in">close</span>(clnt_sockfd);<br>        <span class="hljs-keyword">break</span>;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(read_bytes == <span class="hljs-number">-1</span>)&#123;        <span class="hljs-comment">//read返回-1，表示发生错误，按照上文方法进行错误处理</span><br>        <span class="hljs-built_in">close</span>(clnt_sockfd);<br>        <span class="hljs-built_in">errif</span>(<span class="hljs-literal">true</span>, <span class="hljs-string">&quot;socket read error&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>客户端代码逻辑是一样的：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;<br>    <span class="hljs-type">char</span> buf[<span class="hljs-number">1024</span>];     <span class="hljs-comment">//定义缓冲区</span><br>    <span class="hljs-built_in">bzero</span>(&amp;buf, <span class="hljs-built_in">sizeof</span>(buf));       <span class="hljs-comment">//清空缓冲区</span><br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s&quot;</span>, buf);             <span class="hljs-comment">//从键盘输入要传到服务器的数据</span><br>    <span class="hljs-type">ssize_t</span> write_bytes = <span class="hljs-built_in">write</span>(sockfd, buf, <span class="hljs-built_in">sizeof</span>(buf));      <span class="hljs-comment">//发送缓冲区中的数据到服务器socket，返回已发送数据大小</span><br>    <span class="hljs-keyword">if</span>(write_bytes == <span class="hljs-number">-1</span>)&#123;          <span class="hljs-comment">//write返回-1，表示发生错误</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;socket already disconnected, can&#x27;t write any more!\n&quot;</span>);<br>        <span class="hljs-keyword">break</span>;<br>    &#125;<br>    <span class="hljs-built_in">bzero</span>(&amp;buf, <span class="hljs-built_in">sizeof</span>(buf));       <span class="hljs-comment">//清空缓冲区 </span><br>    <span class="hljs-type">ssize_t</span> read_bytes = <span class="hljs-built_in">read</span>(sockfd, buf, <span class="hljs-built_in">sizeof</span>(buf));    <span class="hljs-comment">//从服务器socket读到缓冲区，返回已读数据大小</span><br>    <span class="hljs-keyword">if</span>(read_bytes &gt; <span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;message from server: %s\n&quot;</span>, buf);<br>    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(read_bytes == <span class="hljs-number">0</span>)&#123;      <span class="hljs-comment">//read返回0，表示EOF，通常是服务器断开链接，等会儿进行测试</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;server socket disconnected!\n&quot;</span>);<br>        <span class="hljs-keyword">break</span>;<br>    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(read_bytes == <span class="hljs-number">-1</span>)&#123;     <span class="hljs-comment">//read返回-1，表示发生错误，按照上文方法进行错误处理</span><br>        <span class="hljs-built_in">close</span>(sockfd);<br>        <span class="hljs-built_in">errif</span>(<span class="hljs-literal">true</span>, <span class="hljs-string">&quot;socket read error&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>一个小细节，Linux系统的文件描述符理论上是有限的，在使用完一个fd之后，需要使用头文件<code>&lt;unistd.h&gt;</code>中的<code>close</code>函数关闭。更多内核相关知识可以参考RobertLove《Linux内核设计与实现》的第三版。</p></blockquote><p>进入<code>code/day02</code>文件夹，使用make命令编译，将会得到<code>server</code>和<code>client</code>。输入命令<code>./server</code>开始运行，直到<code>accept</code>函数，程序阻塞、等待客户端连接。然后在一个新终端输入命令<code>./client</code>运行客户端，可以看到服务器接收到了客户端的连接请求，并成功连接。现在客户端阻塞在<code>scanf</code>函数，等待我们键盘输入，我们可以输入一句话，然后回车。在服务器终端，我们可以看到:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">message from client fd <span class="hljs-number">4</span>: Hello!<br></code></pre></td></tr></table></figure><p>然后在客户端，也能接受到服务器的消息：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">message from server: Hello!<br></code></pre></td></tr></table></figure><blockquote><p>由于是一个<code>while(true)</code>循环，客户端可以一直输入，服务器也会一直echo我们的消息。由于<code>scanf</code>函数的特性，输入的语句遇到空格时，会当成多行进行处理，我们可以试试。</p></blockquote><p>接下来在客户端使用<code>control+c</code>终止程序，可以看到服务器也退出了程序并显示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">client fd <span class="hljs-number">4</span> disconnected<br></code></pre></td></tr></table></figure><p>再次运行两个程序，这次我们使用<code>control+c</code>终止掉服务器，再试图从客户端发送信息，可以看到客户端输出：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">server socket disconnected!<br></code></pre></td></tr></table></figure><p>至此，我们已经完整地开发了一个echo服务器，并且有最基本的错误处理！</p><p>但现在，我们的服务器只能处理一个客户端，我们可以试试两个客户端同时连接服务器，看程序将会如何运行。在day03的教程里，我们将会讲解Linux系统高并发的基石--epoll，并编程实现一个可以支持无数客户端同时连接的echo服务器！</p><p>client.cpp</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/socket.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;arpa/inet.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;util.h&quot;</span></span><br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> sockfd = <span class="hljs-built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="hljs-number">0</span>);<br>    <span class="hljs-built_in">errif</span>(sockfd == <span class="hljs-number">-1</span>, <span class="hljs-string">&quot;socket create error&quot;</span>);<br><br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">sockaddr_in</span> serv_addr;<br>    <span class="hljs-built_in">bzero</span>(&amp;serv_addr, <span class="hljs-built_in">sizeof</span>(serv_addr));<br>    serv_addr.sin_family = AF_INET;<br>    serv_addr.sin_addr.s_addr = <span class="hljs-built_in">inet_addr</span>(<span class="hljs-string">&quot;127.0.0.1&quot;</span>);<br>    serv_addr.sin_port = <span class="hljs-built_in">htons</span>(<span class="hljs-number">8888</span>);<br><br>    <span class="hljs-built_in">errif</span>(<span class="hljs-built_in">connect</span>(sockfd, (sockaddr*)&amp;serv_addr, <span class="hljs-built_in">sizeof</span>(serv_addr)) == <span class="hljs-number">-1</span>, <span class="hljs-string">&quot;socket connect error&quot;</span>);<br>    <br>    <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;<br>        <span class="hljs-type">char</span> buf[<span class="hljs-number">1024</span>];<br>        <span class="hljs-built_in">bzero</span>(&amp;buf, <span class="hljs-built_in">sizeof</span>(buf));<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s&quot;</span>, buf);<br>        <span class="hljs-type">ssize_t</span> write_bytes = <span class="hljs-built_in">write</span>(sockfd, buf, <span class="hljs-built_in">sizeof</span>(buf));<br>        <span class="hljs-keyword">if</span>(write_bytes == <span class="hljs-number">-1</span>)&#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;socket already disconnected, can&#x27;t write any more!\n&quot;</span>);<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-built_in">bzero</span>(&amp;buf, <span class="hljs-built_in">sizeof</span>(buf));<br>        <span class="hljs-type">ssize_t</span> read_bytes = <span class="hljs-built_in">read</span>(sockfd, buf, <span class="hljs-built_in">sizeof</span>(buf));<br>        <span class="hljs-keyword">if</span>(read_bytes &gt; <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;message from server: %s\n&quot;</span>, buf);<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(read_bytes == <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;server socket disconnected!\n&quot;</span>);<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(read_bytes == <span class="hljs-number">-1</span>)&#123;<br>            <span class="hljs-built_in">close</span>(sockfd);<br>            <span class="hljs-built_in">errif</span>(<span class="hljs-literal">true</span>, <span class="hljs-string">&quot;socket read error&quot;</span>);<br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">close</span>(sockfd);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>server.cpp</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/socket.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;arpa/inet.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;util.h&quot;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> sockfd = <span class="hljs-built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="hljs-number">0</span>);<br>    <span class="hljs-built_in">errif</span>(sockfd == <span class="hljs-number">-1</span>, <span class="hljs-string">&quot;socket create error&quot;</span>);<br><br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">sockaddr_in</span> serv_addr;<br>    <span class="hljs-built_in">bzero</span>(&amp;serv_addr, <span class="hljs-built_in">sizeof</span>(serv_addr));<br>    serv_addr.sin_family = AF_INET;<br>    serv_addr.sin_addr.s_addr = <span class="hljs-built_in">inet_addr</span>(<span class="hljs-string">&quot;127.0.0.1&quot;</span>);<br>    serv_addr.sin_port = <span class="hljs-built_in">htons</span>(<span class="hljs-number">8888</span>);<br><br>    <span class="hljs-built_in">errif</span>(<span class="hljs-built_in">bind</span>(sockfd, (sockaddr*)&amp;serv_addr, <span class="hljs-built_in">sizeof</span>(serv_addr)) == <span class="hljs-number">-1</span>, <span class="hljs-string">&quot;socket bind error&quot;</span>);<br><br>    <span class="hljs-built_in">errif</span>(<span class="hljs-built_in">listen</span>(sockfd, SOMAXCONN) == <span class="hljs-number">-1</span>, <span class="hljs-string">&quot;socket listen error&quot;</span>);<br>    <br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">sockaddr_in</span> clnt_addr;<br>    <span class="hljs-type">socklen_t</span> clnt_addr_len = <span class="hljs-built_in">sizeof</span>(clnt_addr);<br>    <span class="hljs-built_in">bzero</span>(&amp;clnt_addr, <span class="hljs-built_in">sizeof</span>(clnt_addr));<br><br>    <span class="hljs-type">int</span> clnt_sockfd = <span class="hljs-built_in">accept</span>(sockfd, (sockaddr*)&amp;clnt_addr, &amp;clnt_addr_len);<br>    <span class="hljs-built_in">errif</span>(clnt_sockfd == <span class="hljs-number">-1</span>, <span class="hljs-string">&quot;socket accept error&quot;</span>);<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;new client fd %d! IP: %s Port: %d\n&quot;</span>, clnt_sockfd, <span class="hljs-built_in">inet_ntoa</span>(clnt_addr.sin_addr), <span class="hljs-built_in">ntohs</span>(clnt_addr.sin_port));<br>    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>        <span class="hljs-type">char</span> buf[<span class="hljs-number">1024</span>];<br>        <span class="hljs-built_in">bzero</span>(&amp;buf, <span class="hljs-built_in">sizeof</span>(buf));<br>        <span class="hljs-type">ssize_t</span> read_bytes = <span class="hljs-built_in">read</span>(clnt_sockfd, buf, <span class="hljs-built_in">sizeof</span>(buf));<br>        <span class="hljs-keyword">if</span>(read_bytes &gt; <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;message from client fd %d: %s\n&quot;</span>, clnt_sockfd, buf);<br>            <span class="hljs-built_in">write</span>(clnt_sockfd, buf, <span class="hljs-built_in">sizeof</span>(buf));<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(read_bytes == <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;client fd %d disconnected\n&quot;</span>, clnt_sockfd);<br>            <span class="hljs-built_in">close</span>(clnt_sockfd);<br>            <span class="hljs-keyword">break</span>;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(read_bytes == <span class="hljs-number">-1</span>)&#123;<br>            <span class="hljs-built_in">close</span>(clnt_sockfd);<br>            <span class="hljs-built_in">errif</span>(<span class="hljs-literal">true</span>, <span class="hljs-string">&quot;socket read error&quot;</span>);<br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">close</span>(sockfd);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>util.cpp</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;util.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">errif</span><span class="hljs-params">(<span class="hljs-type">bool</span> condition, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *errmsg)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(condition)&#123;<br>        <span class="hljs-built_in">perror</span>(errmsg);<br>        <span class="hljs-built_in">exit</span>(EXIT_FAILURE);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>util.h</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> UTIL_H</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> UTIL_H</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">errif</span><span class="hljs-params">(<span class="hljs-type">bool</span>, <span class="hljs-type">const</span> <span class="hljs-type">char</span>*)</span></span>;<br><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>cpp服务器</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>搭建CPP服务器_01</title>
    <link href="/2022/05/28/%E6%90%AD%E5%BB%BACPP%E6%9C%8D%E5%8A%A1%E5%99%A8-01/"/>
    <url>/2022/05/28/%E6%90%AD%E5%BB%BACPP%E6%9C%8D%E5%8A%A1%E5%99%A8-01/</url>
    
    <content type="html"><![CDATA[<p>首先在服务器，我们需要建立一个socket套接字，对外提供一个网络通信接口，在Linux系统中这个套接字竟然仅仅是一个文件描述符，也就是一个<code>int</code>类型的值！这个对套接字的所有操作（包括创建）都是最底层的系统调用。</p><blockquote><p>Unix哲学KISS：keep it simple,stupid。在Linux系统里，一切看上去十分复杂的逻辑功能，都用简单到不可思议的方式实现，甚至有些时候看上去很愚蠢。但仔细推敲，人们将会赞叹Linux的精巧设计，或许这就是大智若愚。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/socket.h&gt;</span></span><br><span class="hljs-type">int</span> sockfd = <span class="hljs-built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="hljs-number">0</span>);<br></code></pre></td></tr></table></figure><ul><li>第一个参数：IP地址类型，AF_INET表示使用IPv4，如果使用IPv6请使用AF_INET6。</li><li>第二个参数：数据传输方式，SOCK_STREAM表示流格式、面向连接，多用于TCP。SOCK_DGRAM表示数据报格式、无连接，多用于UDP。</li><li>第三个参数：协议，0表示根据前面的两个参数自动推导协议类型。设置为IPPROTO_TCP和IPPTOTO_UDP，分别表示TCP和UDP。</li></ul><p><strong>对于客户端，服务器存在的唯一标识是一个IP地址和端口</strong>，这时候我们需要将这个套接字绑定到一个IP地址和端口上。首先创建一个sockaddr_in结构体</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;arpa/inet.h&gt;</span>  <span class="hljs-comment">//这个头文件包含了&lt;netinet/in.h&gt;，不用再次包含了</span></span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">sockaddr_in</span> serv_addr;<br><span class="hljs-built_in">bzero</span>(&amp;serv_addr, <span class="hljs-built_in">sizeof</span>(serv_addr));<br></code></pre></td></tr></table></figure><p>然后使用<strong><code>bzero</code>初始化这个结构体</strong>，这个函数在头文件<code>&lt;string.h&gt;</code>或<code>&lt;cstring&gt;</code>中。这里用到了两条《EffectiveC++》的准则：</p><blockquote><p>条款04:确定对象被使用前已先被初始化。<strong>如果不清空，使用gdb调试器查看addr内的变量，会是一些随机值，未来可能会导致意想不到的问题。</strong></p></blockquote><blockquote><p>条款01:视C++为一个语言联邦。把C和C++看作两种语言，写代码时需要清楚地知道自己在写C还是C++。如果在写C，请包含头文件<code>&lt;string.h&gt;</code>。如果在写C++，请包含<code>&lt;cstring&gt;</code>。</p></blockquote><p>设置地址族、IP地址和端口：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++">serv_addr.sin_family = AF_INET;<br>serv_addr.sin_addr.s_addr = <span class="hljs-built_in">inet_addr</span>(<span class="hljs-string">&quot;127.0.0.1&quot;</span>);<br>serv_addr.sin_port = <span class="hljs-built_in">htons</span>(<span class="hljs-number">8888</span>);<br></code></pre></td></tr></table></figure><p>然后将socket地址与文件描述符绑定：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">bind</span>(sockfd, (sockaddr*)&amp;serv_addr, <span class="hljs-built_in">sizeof</span>(serv_addr));<br></code></pre></td></tr></table></figure><blockquote><p>为什么定义的时候使用专用socket地址（sockaddr_in）而绑定的时候要转化为通用socket地址（sockaddr），以及转化IP地址和端口号为网络字节序的<code>inet_addr</code>和<code>htons</code>等函数及其必要性，在游双《Linux高性能服务器编程》第五章第一节：<ahref="https://blog.csdn.net/chyabc123456hh/article/details/118805521">socket地址API</a>中有详细讨论。</p></blockquote><p>最后我们需要使用<code>listen</code>函数监听这个socket端口，这个函数的第二个参数是listen函数的最大监听队列长度，系统建议的最大值<code>SOMAXCONN</code>被定义为128。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">listen</span>(sockfd, SOMAXCONN);<br></code></pre></td></tr></table></figure><p>要接受一个客户端连接，需要使用<code>accept</code>函数。对于每一个客户端，我们在接受连接时也需要保存客户端的socket地址信息，于是有以下代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">sockaddr_in</span> clnt_addr;<br><span class="hljs-type">socklen_t</span> clnt_addr_len = <span class="hljs-built_in">sizeof</span>(clnt_addr);<br><span class="hljs-built_in">bzero</span>(&amp;clnt_addr, <span class="hljs-built_in">sizeof</span>(clnt_addr));<br><span class="hljs-type">int</span> clnt_sockfd = <span class="hljs-built_in">accept</span>(sockfd, (sockaddr*)&amp;clnt_addr, &amp;clnt_addr_len);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;new client fd %d! IP: %s Port: %d\n&quot;</span>, clnt_sockfd, <span class="hljs-built_in">inet_ntoa</span>(clnt_addr.sin_addr), <span class="hljs-built_in">ntohs</span>(clnt_addr.sin_port));<br></code></pre></td></tr></table></figure><p>要注意和<code>accept</code>和<code>bind</code>的第三个参数有一点区别，对于<code>bind</code>只需要传入serv_addr的大小即可，而<code>accept</code>需要写入客户端socket长度，所以需要定义一个类型为<code>socklen_t</code>的变量，并传入这个变量的地址。另外，<code>accept</code>函数会阻塞当前程序，直到有一个客户端socket被接受后程序才会往下运行。</p><p>到现在，客户端已经可以通过IP地址和端口号连接到这个socket端口了，让我们写一个测试客户端连接试试：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> sockfd = <span class="hljs-built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="hljs-number">0</span>);<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">sockaddr_in</span> serv_addr;<br><span class="hljs-built_in">bzero</span>(&amp;serv_addr, <span class="hljs-built_in">sizeof</span>(serv_addr));<br>serv_addr.sin_family = AF_INET;<br>serv_addr.sin_addr.s_addr = <span class="hljs-built_in">inet_addr</span>(<span class="hljs-string">&quot;127.0.0.1&quot;</span>);<br>serv_addr.sin_port = <span class="hljs-built_in">htons</span>(<span class="hljs-number">8888</span>);<br><span class="hljs-built_in">connect</span>(sockfd, (sockaddr*)&amp;serv_addr, <span class="hljs-built_in">sizeof</span>(serv_addr));  <br></code></pre></td></tr></table></figure><p>代码和服务器代码几乎一样：创建一个socket文件描述符，与一个IP地址和端口绑定，最后并不是监听这个端口，而是使用<code>connect</code>函数尝试连接这个服务器。</p><p>client.cpp</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/socket.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;arpa/inet.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> sockfd = <span class="hljs-built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="hljs-number">0</span>);<br><br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">sockaddr_in</span> serv_addr;<br>    <span class="hljs-built_in">bzero</span>(&amp;serv_addr, <span class="hljs-built_in">sizeof</span>(serv_addr));<br>    serv_addr.sin_family = AF_INET;<br>    serv_addr.sin_addr.s_addr = <span class="hljs-built_in">inet_addr</span>(<span class="hljs-string">&quot;127.0.0.1&quot;</span>);<br>    serv_addr.sin_port = <span class="hljs-built_in">htons</span>(<span class="hljs-number">8888</span>);<br><br>    <span class="hljs-comment">//bind(sockfd, (sockaddr*)&amp;serv_addr, sizeof(serv_addr)); 客户端不进行bind操作</span><br><br>    <span class="hljs-built_in">connect</span>(sockfd, (sockaddr*)&amp;serv_addr, <span class="hljs-built_in">sizeof</span>(serv_addr));    <br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>server.cpp</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/socket.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;arpa/inet.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> sockfd = <span class="hljs-built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="hljs-number">0</span>);<br><br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">sockaddr_in</span> serv_addr;<br>    <span class="hljs-built_in">bzero</span>(&amp;serv_addr, <span class="hljs-built_in">sizeof</span>(serv_addr));<br>    serv_addr.sin_family = AF_INET;<br>    serv_addr.sin_addr.s_addr = <span class="hljs-built_in">inet_addr</span>(<span class="hljs-string">&quot;127.0.0.1&quot;</span>);<br>    serv_addr.sin_port = <span class="hljs-built_in">htons</span>(<span class="hljs-number">8888</span>);<br><br>    <span class="hljs-built_in">bind</span>(sockfd, (sockaddr*)&amp;serv_addr, <span class="hljs-built_in">sizeof</span>(serv_addr));<br><br>    <span class="hljs-built_in">listen</span>(sockfd, SOMAXCONN);<br>    <br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">sockaddr_in</span> clnt_addr;<br>    <span class="hljs-type">socklen_t</span> clnt_addr_len = <span class="hljs-built_in">sizeof</span>(clnt_addr);<br>    <span class="hljs-built_in">bzero</span>(&amp;clnt_addr, <span class="hljs-built_in">sizeof</span>(clnt_addr));<br><br>    <span class="hljs-type">int</span> clnt_sockfd = <span class="hljs-built_in">accept</span>(sockfd, (sockaddr*)&amp;clnt_addr, &amp;clnt_addr_len);<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;new client fd %d! IP: %s Port: %d\n&quot;</span>, clnt_sockfd, <span class="hljs-built_in">inet_ntoa</span>(clnt_addr.sin_addr), <span class="hljs-built_in">ntohs</span>(clnt_addr.sin_port));<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>cpp服务器</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机网络基础3</title>
    <link href="/2022/05/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%803/"/>
    <url>/2022/05/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%803/</url>
    
    <content type="html"><![CDATA[<h3 id="arprarp协议">5. ARP/RARP协议</h3><p><strong>地址解析协议，即ARP（Address ResolutionProtocol），是根据IP地址获取物理地址的一个TCP/IP协议。</strong>主机发送信息时将包含目标IP地址的ARP请求广播到网络上的所有主机，并接收返回消息，以此确定目标的物理地址；收到返回消息后将该IP地址和物理地址存入本机ARP缓存中并保留一定时间，下次请求时直接查询ARP缓存以节约资源。地址解析协议是建立在网络中各个主机互相信任的基础上的，网络上的主机可以自主发送ARP应答消息，其他主机收到应答报文时不会检测该报文的真实性就会将其记入本机ARP缓存；由此攻击者就可以向某一主机发送伪ARP应答报文，使其发送的信息无法到达预期的主机或到达错误的主机，这就构成了一个ARP欺骗。<strong>ARP命令可用于查询本机ARP缓存中IP地址和MAC地址的对应关系、添加或删除静态对应关系等。</strong></p><p>ARP工作流程举例：</p><p><strong>MAC地址由第二层数据链路层负责，MAC地址用于在网络中唯一标识网卡</strong></p><p>主机A的IP地址为192.168.1.1，MAC地址为0A-11-22-33-44-01；</p><p>主机B的IP地址为192.168.1.2，MAC地址为0A-11-22-33-44-02；</p><p>当主机A要与主机B通信时，地址解析协议可以将主机B的IP地址（192.168.1.2）解析成主机B的MAC地址，以下为工作流程：</p><ul><li>（1）根据主机A上的路由表内容，IP确定用于访问主机B的转发IP地址是192.168.1.2。然后A主机在自己的本地ARP缓存中检查主机B的匹配MAC地址。</li><li>（2）如果主机A在ARP缓存中没有找到映射，它将询问192.168.1.2的硬件地址，从而将ARP请求帧广播到本地网络上的所有主机。源主机A的IP地址和MAC地址都包括在ARP请求中。本地网络上的每台主机都接收到ARP请求并且检查是否与自己的IP地址匹配。如果主机发现请求的IP地址与自己的IP地址不匹配，它将丢弃ARP请求。</li><li>（3）主机B确定ARP请求中的IP地址与自己的IP地址匹配，则将主机A的IP地址和MAC地址映射添加到本地ARP缓存中。</li><li>（4）主机B将包含其MAC地址的ARP回复消息直接发送回主机A。</li><li>（5）当主机A收到从主机B发来的ARP回复消息时，会用主机B的IP和MAC地址映射更新ARP缓存。本机缓存是有生存期的，生存期结束后，将再次重复上面的过程。主机B的MAC地址一旦确定，主机A就能向主机B发送IP通信了。</li></ul><p><strong>逆地址解析协议，即RARP，功能和ARP协议相对，其将局域网中某个主机的物理地址转换为IP地址</strong></p><p>，比如局域网中有一台主机只知道物理地址而不知道IP地址，那么可以通过RARP协议发出征求自身IP地址的广播请求，然后由RARP服务器负责回答。</p><p>RARP协议工作流程：</p><ul><li>（1）给主机发送一个本地的RARP广播，在此广播包中，声明自己的MAC地址并且请求任何收到此请求的RARP服务器分配一个IP地址；</li><li>（2）本地网段上的RARP服务器收到此请求后，检查其RARP列表，查找该MAC地址对应的IP地址；</li><li>（3）如果存在，RARP服务器就给源主机发送一个响应数据包并将此IP地址提供给对方主机使用；</li><li>（4）如果不存在，RARP服务器对此不做任何的响应；</li></ul><h3 id="路由选择协议">6. 路由选择协议</h3><p>常见的路由选择协议有：RIP协议、OSPF协议。</p><p><strong>RIP协议</strong>：底层是贝尔曼福特算法，它选择路由的度量标准（metric)是跳数，最大跳数是15跳，如果大于15跳，它就会丢弃数据包。</p><p><strong>OSPF协议</strong> ：Open Shortest PathFirst开放式最短路径优先，底层是迪杰斯特拉算法，是链路状态路由选择协议，它选择路由的度量标准是带宽，延迟。</p><h3 id="tcpip协议">7. TCP/IP协议</h3><p><strong>TCP/IP协议是Internet最基本的协议、Internet国际互联网络的基础，由网络层的IP协议和传输层的TCP协议组成。通俗而言：TCP负责发现传输的问题，一有问题就发出信号，要求重新传输，直到所有数据安全正确地传输到目的地。而IP是给因特网的每一台联网设备规定一个地址。</strong></p><p>IP层接收由更低层（网络接口层例如以太网设备驱动程序）发来的数据包，并把该数据包发送到更高层---TCP或UDP层；相反，IP层也把从TCP或UDP层接收来的数据包传送到更低层。IP数据包是不可靠的，因为IP并没有做任何事情来确认数据包是否按顺序发送的或者有没有被破坏，IP数据包中含有发送它的主机的地址（源地址）和接收它的主机的地址（目的地址）。</p><p>TCP是面向连接的通信协议，通过三次握手建立连接，通讯完成时要拆除连接，由于TCP是面向连接的所以只能用于端到端的通讯。TCP提供的是一种可靠的数据流服务，采用"带重传的肯定确认"技术来实现传输的可靠性。TCP还采用一种称为"滑动窗口"的方式进行流量控制，所谓窗口实际表示接收能力，用以限制发送方的发送速度。</p><p><strong>TCP报文首部格式：</strong></p><figure><imgsrc="https://www.runoob.com/wp-content/uploads/2018/09/1538030297-3779-20150904110054856-961661137.png"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p><strong>TCP协议的三次握手和四次挥手：</strong></p><figure><imgsrc="https://www.runoob.com/wp-content/uploads/2018/09/1538030297-7824-20150904110008388-1768388886.gif"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>　　<strong>注：seq</strong>:"sequance"序列号；<strong>ack</strong>:"acknowledge"确认号；<strong>SYN</strong>:"synchronize"请求同步标志；<strong>；ACK</strong>:"acknowledge"确认标志"<strong>；FIN</strong>："Finally"结束标志。</p><p><strong>TCP连接建立过程：</strong>首先Client端发送连接请求报文，Server段接受连接后回复ACK报文，并为这次连接分配资源。Client端接收到ACK报文后也向Server段发生ACK报文，并分配资源，这样TCP连接就建立了。</p><p><strong>TCP连接断开过程：</strong>假设Client端发起中断连接请求，也就是发送FIN报文。Server端接到FIN报文后，意思是说"我Client端没有数据要发给你了"，但是如果你还有数据没有发送完成，则不必急着关闭Socket，可以继续发送数据。所以你先发送ACK，"告诉Client端，你的请求我收到了，但是我还没准备好，请继续你等我的消息"。这个时候Client端就进入FIN_WAIT状态，继续等待Server端的FIN报文。当Server端确定数据已发送完成，则向Client端发送FIN报文，"告诉Client端，好了，我这边数据发完了，准备好关闭连接了"。Client端收到FIN报文后，"就知道可以关闭连接了，但是他还是不相信网络，怕Server端不知道要关闭，所以发送ACK后进入TIME_WAIT状态，如果Server端没有收到ACK则可以重传。"，Server端收到ACK后，"就知道可以断开连接了"。Client端等待了2MSL后依然没有收到回复，则证明Server端已正常关闭，那好，我Client端也可以关闭连接了。Ok，TCP连接就这样关闭了！</p><p><strong>为什么要三次握手？</strong></p><p>在只有两次"握手"的情形下，假设Client想跟Server建立连接，但是却因为中途连接请求的数据报丢失了，故Client端不得不重新发送一遍；这个时候Server端仅收到一个连接请求，因此可以正常的建立连接。但是，有时候Client端重新发送请求不是因为数据报丢失了，而是有可能数据传输过程因为网络并发量很大在某结点被阻塞了，这种情形下Server端将先后收到2次请求，并持续等待两个Client请求向他发送数据...问题就在这里，Cient端实际上只有一次请求，而Server端却有2个响应，极端的情况可能由于Client端多次重新发送请求数据而导致Server端最后建立了N多个响应在等待，因而造成极大的资源浪费！所以，"三次握手"很有必要！</p><p><strong>为什么要四次挥手？</strong></p><p>试想一下，假如现在你是客户端你想断开跟Server的所有连接该怎么做？第一步，你自己先停止向Server端发送数据，并等待Server的回复。但事情还没有完，虽然你自身不往Server发送数据了，但是因为你们之前已经建立好平等的连接了，所以此时他也有主动权向你发送数据；故Server端还得终止主动向你发送数据，并等待你的确认。其实，说白了就是保证双方的一个合约的完整执行！</p><p>使用TCP的协议：FTP（文件传输协议）、Telnet（远程登录协议）、SMTP（简单邮件传输协议）、POP3（和SMTP相对，用于接收邮件）、HTTP协议等。</p><h3 id="udp协议">8. UDP协议</h3><p><strong>UDP用户数据报协议，是面向无连接的通讯协议，UDP数据包括目的端口号和源端口号信息，由于通讯不需要连接，所以可以实现广播发送。</strong></p><p>UDP通讯时不需要接收方确认，属于不可靠的传输，可能会出现丢包现象，实际应用中要求程序员编程验证。</p><p>UDP与TCP位于同一层，但它不管数据包的顺序、错误或重发。因此，UDP不被应用于那些使用虚电路的面向连接的服务，UDP主要用于那些面向查询---应答的服务，例如NFS。相对于FTP或Telnet，这些服务需要交换的信息量较小。</p><p>每个UDP报文分UDP报头和UDP数据区两部分。报头由四个16位长（2字节）字段组成，分别说明该报文的源端口、目的端口、报文长度以及校验值。UDP报头由4个域组成，其中每个域各占用2个字节，具体如下：</p><ul><li>（1）源端口号；</li><li>（2）目标端口号；</li><li>（3）数据报长度；</li><li>（4）校验值。</li></ul><p>使用UDP协议包括：TFTP（简单文件传输协议）、SNMP（简单网络管理协议）、DNS（域名解析协议）、NFS（文件共享协议）、BOOTP（引导程序协议，是DHCP协议前身）。</p><p><strong>TCP</strong> <strong>与</strong> <strong>UDP</strong><strong>的区别：</strong>TCP是面向连接的，可靠的字节流服务；UDP是面向无连接的，不可靠的数据报服务。</p><h3 id="dns协议">9. DNS协议</h3><p>DNS是域名系统(DomainNameSystem)的缩写，该系统用于命名组织到域层次结构中的计算机和网络服务，<strong>可以简单地理解为将URL转换为IP地址</strong>。域名是由圆点分开一串单词或缩写组成的，<strong>每一个域名都对应一个惟一的IP地址</strong>，<strong>域名可以说是一个IP地址的代称，目的是为了更好的记忆IP地址。</strong>在Internet上域名与IP地址之间是一一对应的，DNS就是进行域名解析的服务器。DNS命名用于Internet等TCP/IP网络中，通过用户友好的名称查找计算机和服务。</p><h3 id="nat协议">10. NAT协议</h3><p>　　NAT网络地址转换(Network AddressTranslation)属接入广域网(WAN)技术，是一种<strong>将私有（保留）地址转化为合法IP地址的转换技术</strong>，它被广泛应用于各种类型Internet接入方式和各种类型的网络中。原因很简单，NAT不仅完美地解决了lP地址不足的问题，而且还能够有效地避免来自网络外部的攻击，隐藏并保护网络内部的计算机。</p><h3 id="dhcp协议">11. DHCP协议</h3><p>DHCP动态主机设置协议（Dynamic Host ConfigurationProtocol）是一个局域网的网络协议，使用UDP协议工作，主要有两个用途：给内部网络或网络服务供应商自动分配IP地址，给用户或者内部网络管理员作为对所有计算机作中央管理的手段。</p><h3 id="http协议">12. HTTP协议</h3><p>超文本传输协议（HTTP，HyperText TransferProtocol)是互联网上应用最为广泛的一种网络协议。所有的WWW文件都必须遵守这个标准。　　<strong>HTTP</strong><strong>协议包括哪些请求？</strong></p><p>GET：请求读取由URL所标志的信息。</p><p>POST：给服务器添加信息（如注释）。</p><p>PUT：在给定的URL下存储一个文档。</p><p>DELETE：删除给定的URL所标志的资源。</p><p>　　<strong>HTTP</strong> <strong>中，</strong> <strong>POST</strong><strong>与</strong> <strong>GET</strong> <strong>的区别</strong></p><ul><li><p>1）Get是从服务器上获取数据，Post是向服务器传送数据。</p></li><li><p>2）Get是把参数数据队列加到提交表单的Action属性所指向的URL中，值和表单内各个字段一一对应，在URL中可以看到。</p></li><li><p>3）Get传送的数据量小，不能大于2KB；Post传送的数据量较大，一般被默认为不受限制。</p></li><li><p>4）根据HTTP规范，GET用于信息获取，而且应该是安全的和幂等的。</p></li><li><p>I. 所谓 <strong>安全的</strong>意味着该操作用于获取信息而非修改信息。换句话说，GET请求一般不应产生副作用。就是说，它仅仅是获取资源信息，就像数据库查询一样，不会修改，增加数据，不会影响资源的状态。</p></li><li><ol start="2" type="I"><li><strong>幂等</strong>的意味着对同一URL的多个请求应该返回同样的结果。</li></ol></li></ul><h3 id="一个举例">13. 一个举例</h3><p>在浏览器中输入 <strong>http://www.baidu.com/</strong>后执行的全部过程。</p><p>现在假设如果我们在客户端（客户端）浏览器中输入 http://www.baidu.com，而 baidu.com为要访问的服务器（服务器），下面详细分析客户端为了访问服务器而执行的一系列关于协议的操作：</p><ul><li>1）客户端浏览器通过DNS解析到www.baidu.com的IP地址220.181.27.48，通过这个IP地址找到客户端到服务器的路径。客户端浏览器发起一个HTTP会话到220.161.27.48，然后通过TCP进行封装数据包，输入到网络层。</li><li>2）在客户端的传输层，把HTTP会话请求分成报文段，添加源和目的端口，如服务器使用80端口监听客户端的请求，客户端由系统随机选择一个端口如5000，与服务器进行交换，服务器把相应的请求返回给客户端的5000端口。然后使用IP层的IP地址查找目的端。</li><li>3）客户端的网络层不用关系应用层或者传输层的东西，主要做的是通过查找路由表确定如何到达服务器，期间可能经过多个路由器，这些都是由路由器来完成的工作，不作过多的描述，无非就是通过查找路由表决定通过那个路径到达服务器。</li><li>4）客户端的链路层，包通过链路层发送到路由器，通过邻居协议查找给定IP地址的MAC地址，然后发送ARP请求查找目的地址，如果得到回应后就可以使用ARP的请求应答交换的IP数据包现在就可以传输了，然后发送IP数据包到达服务器的地址。</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机网络基础2</title>
    <link href="/2022/05/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%802/"/>
    <url>/2022/05/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%802/</url>
    
    <content type="html"><![CDATA[<h3 id="ip地址">3. IP地址</h3><p><strong>1）网络地址</strong></p><p>IP地址由<strong>网络号（包括子网号）</strong>和<strong>主机号</strong>组成，IP地址由4段组成，每个字段是一个字节，即4个字节。最大值255。网络地址的主机号为<strong>全0</strong>，网络地址代表着整个网络。</p><p><strong>2）广播地址</strong></p><p>广播地址通常称为<strong>直接广播地址</strong>，是为了区分受限广播地址。</p><p>广播地址与网络地址的主机号正好相反，广播地址中，主机号为<strong>全1</strong>。当向某个网络的广播地址发送消息时，该网络内的所有主机都能收到该广播消息。</p><p><strong>3）组播地址</strong></p><p>D类地址就是组播地址。</p><p>先回忆下A，B，C，D类地址吧：</p><p>A类地址以0开头，<strong>第一个字节</strong>作为网络号，地址范围为：0.0.0.0~127.255.255.255；(<strong>modified<span class="citation"data-cites="2016.05.31">@2016.05.31</span></strong>)</p><p>B类地址以10开头，<strong>前两个字节</strong>作为网络号，地址范围是：128.0.0.0~191.255.255.255;</p><p>C类地址以110开头，<strong>前三个字节</strong>作为网络号，地址范围是：192.0.0.0~223.255.255.255。</p><p>D类地址以1110开头，地址范围是224.0.0.0~239.255.255.255，D类地址作为组播地址（一对多的通信）；</p><p>E类地址以1111开头，地址范围是240.0.0.0~255.255.255.255，E类地址为保留地址，供以后使用。</p><p>注：只有A,B,C有网络号和主机号之分，D类地址和E类地址没有划分网络号和主机号。</p><p><strong>4）255.255.255.255</strong></p><p>该IP地址指的是<strong>受限的广播地址</strong>。受限广播地址与一般广播地址（直接广播地址）的区别在于，受限广播地址只能用于本地网络，路由器不会转发以受限广播地址为目的地址的分组；一般广播地址既可在本地广播，也可跨网段广播。例如：主机192.168.1.1/30上的直接广播数据包后，另外一个网段192.168.1.5/30也能收到该数据报；若发送受限广播数据报，则不能收到。</p><p>注：一般的广播地址（直接广播地址）能够通过某些路由器（当然不是所有的路由器），而受限的广播地址不能通过路由器。</p><p><strong>5）0.0.0.0</strong></p><p>常用于寻找自己的IP地址，例如在我们的RARP，BOOTP和DHCP协议中，若某个未知IP地址的无盘机想要知道自己的IP地址，它就以255.255.255.255为目的地址，向本地范围（具体而言是被各个路由器屏蔽的范围内）的服务器发送IP请求分组。</p><p><strong>6）回环地址</strong></p><p>127.0.0.0/8被用作回环地址，回环地址表示本机的地址，常用于对本机的测试，用的最多的是127.0.0.1。</p><p><strong>7）A、B、C类私有地址</strong></p><p>私有地址(privateaddress)也叫专用地址，它们不会在全球使用，只具有本地意义。</p><p>A类私有地址：10.0.0.0<strong>/8</strong>，范围是：10.0.0.0~10.255.255.255（10.0.0.0/8说明他的子网掩码是255.0.0.0）</p><p>B类私有地址：172.16.0.0/12，范围是：172.16.0.0~172.31.255.255</p><p>C类私有地址：192.168.0.0/16，范围是：192.168.0.0~192.168.255.255</p><h3 id="子网掩码及网络划分">4. 子网掩码及网络划分</h3><p>随着互连网应用的不断扩大，原先的IPv4的弊端也逐渐暴露出来，即网络号占位太多，而主机号位太少，所以其能提供的主机地址也越来越稀缺，目前除了使用NAT在企业内部利用保留地址自行分配以外，通常都<strong>对一个高类别的IP地址进行再划分，以形成多个子网</strong>，提供给不同规模的用户群使用。</p><p>这里主要是为了在网络分段情况下有效地利用IP地址，通过对主机号的高位部分取作为子网号，从通常的网络位界限中扩展或压缩子网掩码，用来创建某类地址的更多子网。但创建更多的子网时，在每个子网上的可用主机地址数目会比原先减少。</p><p><strong>什么是子网掩码？</strong></p><p>子网掩码是<strong>标志两个IP地址是否同属于一个子网的</strong>，也是32位二进制地址，其每一个为1代表该位是网络位，为0代表主机位。它和IP地址一样也是使用<strong>点式十进制</strong>来表示的。如果两个IP地址在子网掩码的<strong>按位与</strong>的计算下所得结果相同，即表明它们共属于同一子网中。</p><p><strong>在计算子网掩码时，我们要注意IP地址中的保留地址，即"0"地址和广播地址，它们是指主机地址或网络地址全为" 0"或"1"时的IP地址，它们代表着本网络地址和广播地址，一般是不能被计算在内的。</strong></p><p><strong>子网掩码的计算：</strong></p><p>对于<strong>无须再划分成子网的IP地址来说，其子网掩码非常简单</strong>，即按照其定义即可写出：如某B类IP地址为10.12.3.0，无须再分割子网，则该IP地址的子网掩码255.255.0.0。如果它是一个C类地址，则其子网掩码为255.255.255.0。其它类推，不再详述。下面我们关键要介绍的是一个IP地址，还需要将其高位主机位再作为划分出的子网网络号，剩下的是每个子网的主机号，这时该如何进行每个子网的掩码计算。</p><p>下面总结一下有关子网掩码和网络划分常见的面试考题：</p><p><strong>1）利用子网数来计算</strong></p><p>在求子网掩码之前必须先搞清楚要划分的子网数目，以及每个子网内的所需主机数目。</p><ol type="1"><li>将子网数目转化为二进制来表示;</li></ol><p>如欲将B类IP地址168.195.0.0划分成27个子网：27=11011；</p><ol start="2" type="1"><li>取得该二进制的位数，为N；</li></ol><p>该二进制为五位数，N = 5</p><ol start="3" type="1"><li>取得该IP地址的<strong>类子网掩码</strong>，将其主机地址部分的的<strong>前N位置1</strong>即得出该IP地址划分子网的子网掩码。</li></ol><p>将B类地址的子网掩码255.255.0.0的主机地址前5位置 1，得到255.255.248.0</p><p><strong>2）利用主机数来计算</strong></p><p>如欲将B类IP地址168.195.0.0划分成若干子网，每个子网内有主机700台：</p><ol type="1"><li>将主机数目转化为二进制来表示；</li></ol><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">700</span>=<span class="hljs-number">1010111100</span><br></code></pre></td></tr></table></figure><ol start="2" type="1"><li>如果主机数小于或等于254（注意去掉保留的两个IP地址），则取得该主机的二进制位数，为N，这里肯定N&lt;8。如果大于254，则 N&gt;8，这就是说主机地址将占据不止8位；</li></ol><p>该二进制为十位数，N=10；</p><ol start="3" type="1"><li>使用255.255.255.255来将该类IP地址的主机地址位数全部置1，然后<strong>从后向前</strong>的将N位全部置为0，即为<strong>子网掩码值</strong>。</li></ol><p>将该B类地址的子网掩码255.255.0.0的主机地址全部置1，得到255.255.255.255，然后再从后向前将后10位置0,即为：11111111.11111111.11111100.00000000，即255.255.252.0。这就是该欲划分成主机为700台的B类IP地址168.195.0.0的子网掩码。</p><p><strong>3）还有一种题型，要你根据每个网络的主机数量进行子网地址的规划和计算子网掩码。这也可按上述原则进行计算。</strong></p><p>比如一个子网有10台主机，那么对于这个子网需要的IP地址是：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">10</span>＋<span class="hljs-number">1</span>＋<span class="hljs-number">1</span>＋<span class="hljs-number">1</span>＝<span class="hljs-number">13</span><br></code></pre></td></tr></table></figure><p><strong>注意：加的第一个1是指这个网络连接时所需的网关地址，接着的两个1分别是指网络地址和广播地址。</strong></p><p>因为13小于16（16等于2的4次方），所以主机位为4位。而256－16＝240，所以该子网掩码为255.255.255.240。</p><p>如果一个子网有14台主机，不少人常犯的错误是：依然分配具有16个地址空间的子网，而<strong>忘记了给网关分配地址</strong>。这样就错误了，因为14＋1＋1＋1＝17，17大于16，所以我们只能分配具有32个地址（32等于2的5次方）空间的子网。这时子网掩码为：255.255.255.224。</p>]]></content>
    
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机网络基础1</title>
    <link href="/2022/05/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%801/"/>
    <url>/2022/05/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%801/</url>
    
    <content type="html"><![CDATA[<p>计算机网络的核心内容就是<strong>网络协议</strong>的学习。</p><p>网络协议是问计算机网络中进行数据交换而建立的规则、标准或者说是约定的集合。因为不同用户的数据终端可能采集的字符集是不同的，两者需要通信，必须要在一定的标准上进行。目前TCP/IP协议已经成为Internet的“通用语言”。</p><h3 id="网络层次划分">1.网络层次划分</h3><p>为了使不同计算机厂家生产的计算机能够相互通信，以便在更大的范围内建立计算机网络，国际标准化组织（ISO）在1978年提出了"开放系统互联参考模型"，即著名的OSI/RM模型（OpenSystem Interconnection/ReferenceModel）。它将计算机网络体系结构的通信协议划分为七层，自下而上依次为：物理层（PhysicsLayer）、数据链路层（Data Link Layer）、网络层（NetworkLayer）、传输层（Transport Layer）、会话层（SessionLayer）、表示层（Presentation Layer）、应用层（ApplicationLayer）。其中第四层完成数据传送服务，上面三层面向用户。</p><p>除了标准的OSI七层模型以外，常见的网络层次划分还有TCP/IP四层协议以及TCP/IP五层协议。</p><figure><imgsrc="https://www.runoob.com/wp-content/uploads/2018/09/1538030296-7490-20150904094019903-1923900106.jpg"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><h3 id="osi七层网络模型">2.OSI七层网络模型</h3><p>TCP/IP协议是互联网的基础协议。不管是管是OSI七层模型还是TCP/IP的四层、五层模型，每一层都要有自己的专属协议，完成自己相应的工作以及与上下层级之间进行沟通。</p><figure><imgsrc="https://www.runoob.com/wp-content/uploads/2018/09/1538030296-8668-20150904095142060-1017190812.gif"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p><strong>1）物理层（Physical Layer）</strong></p><p>激活、维持、关闭通信端点之间的机械特性、电气特性、功能特性以及过程特性。<strong>该层为上层协议提供了一个传输数据的可靠的物理媒体。简单的说，物理层确保原始的数据可在各种物理媒体上传输。</strong>物理层记住两个重要的设备名称，==中继器（Repeater，也叫放大器）==和==集线器==。</p><p><strong>2）数据链路层（Data Link Layer）</strong></p><p>数据链路层在物理层提供的服务的基础上向网络层提供服务，其最基本的服务是将源自网络层来的数据可靠地传输到相邻节点的目标机网络层。为达到这一目的，数据链路必须具备一系列相应的功能，主要有：如何将数据组合成数据块，在数据链路层中称这种数据块为<strong>帧（frame）</strong>，帧是数据链路层的传送单位；如何控制帧在物理信道上的传输，包括如何处理传输差错，如何调节发送速率以使与接收方相匹配；以及在两个网络实体之间提供数据链路通路的建立、维持和释放的管理。数据链路层在不可靠的物理介质上提供可靠的传输。该层的作用包括：物理地址寻址、数据的成帧、流量控制、数据的检错、重发等。</p><p>有关数据链路层的重要知识点：</p><ul><li><strong>1&gt; 数据链路层为网络层提供可靠的数据传输；</strong></li><li>　　<strong>2&gt; 基本数据单位为帧；</strong></li><li>　　<strong>3&gt; 主要的协议：以太网协议；</strong></li><li>　　<strong>4&gt; 两个重要设备名称：网桥和交换机。</strong></li></ul><p><strong>3）网络层（Network Layer）</strong></p><p>网络层的目的是<strong>实现两个端系统之间的数据透明传送</strong>，具体功能包括寻址和路由选择、连接的建立、保持和终止等。它提供的服务使传输层不需要了解网络中的数据传输和交换技术。如果您想用尽量少的词来记住网络层，那就是<strong>"路径选择、路由及逻辑寻址"</strong>。</p><p>网络层中涉及众多的协议，其中包括最重要的协议，也是TCP/IP的核心协议——IP协议。IP协议非常简单，仅仅提供不可靠、无连接的传送服务。IP协议的主要功能有：无连接数据报传输、数据报路由选择和差错控制。与IP协议配套使用实现其功能的还有地址解析协议ARP、逆地址解析协议RARP、因特网报文协议ICMP、因特网组管理协议IGMP。具体的协议我们会在接下来的部分进行总结，有关网络层的重点为：</p><ul><li>　　<strong>1&gt;网络层负责对子网间的数据包进行路由选择。此外，网络层还可以实现拥塞控制、网际互连等功能；</strong></li><li>　　<strong>2&gt; 基本数据单位为IP数据报；</strong></li><li>　　<strong>3&gt; 包含的主要协议：</strong></li><li>　　<strong>IP协议（InternetProtocol，因特网互联协议）;</strong></li><li>　　<strong>ICMP协议（Internet Control MessageProtocol，因特网控制报文协议）;</strong></li><li>　　<strong>ARP协议（Address ResolutionProtocol，地址解析协议）;</strong></li><li>　　<strong>RARP协议（Reverse Address ResolutionProtocol，逆地址解析协议）。</strong></li><li>　　<strong>4&gt; 重要的设备：路由器。</strong></li></ul><p><strong>4）传输层（Transport Layer）</strong></p><p>第一个端到端，即主机到主机的层次。传输层负责将上层数据分段并提供端到端的、可靠的或不可靠的传输。此外，传输层还要处理端到端的差错控制和流量控制问题。传输层的任务是根据通信子网的特性，最佳的利用网络资源，为两个端系统的会话层之间，提供建立、维护和取消传输连接的功能，负责端到端的可靠数据传输。在这一层，信息传送的协议数据单元称为<strong>段或报文</strong>。网络层只是根据网络地址将源结点发出的数据包传送到目的结点，而传输层则负责将数据可靠地传送到相应的端口。有关网络层的重点：</p><ul><li><strong>1&gt;传输层负责将上层数据分段并提供端到端的、可靠的或不可靠的传输以及端到端的差错控制和流量控制问题；</strong></li><li><strong>2&gt; 包含的主要协议：TCP协议（Transmission ControlProtocol，传输控制协议）、UDP协议（User DatagramProtocol，用户数据报协议）；</strong></li><li><strong>3&gt; 重要设备：网关。</strong></li></ul><p><strong>5）会话层</strong></p><p>会话层管理主机之间的会话进程，即负责建立、管理、终止进程之间的会话。会话层还利用在数据中插入校验点来实现数据的同步。</p><p><strong>6）表示层</strong></p><p>表示层对上层数据或信息进行变换以保证一个主机应用层信息可以被另一个主机的应用程序理解。表示层的数据转换包括数据的加密、压缩、格式转换等。</p><p><strong>7）应用层</strong></p><p>为操作系统或网络应用程序提供访问网络服务的接口。</p><p>会话层、表示层和应用层重点：</p><ul><li><strong>1&gt; 数据传输基本单位为报文；</strong></li><li><strong>2&gt;包含的主要协议：FTP（文件传送协议）、Telnet（远程登录协议）、DNS（域名解析协议）、SMTP（邮件传送协议），POP3协议（邮局协议），HTTP协议（HyperText Transfer Protocol）。</strong></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>计算机基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>搭建ftp服务器小结</title>
    <link href="/2022/05/27/%E6%90%AD%E5%BB%BAftp%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%B0%8F%E7%BB%93/"/>
    <url>/2022/05/27/%E6%90%AD%E5%BB%BAftp%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%B0%8F%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h2 id="背景信息">背景信息</h2><p>FTP（File TransferProtocol）是一种文件传输协议，基于客户端/服务器架构，支持以下两种工作模式：</p><ul><li>主动模式：客户端向FTP服务器发送端口信息，由服务器主动连接该端口。</li><li>被动模式：FTP服务器开启并发送端口信息给客户端，由客户端连接该端口，服务器被动接受连接。</li></ul><p><strong>说明</strong>大多数FTP客户端都在局域网中，没有独立的公网IP地址，且有防火墙阻拦，主动模式下FTP服务器成功连接到客户端比较困难。因此，如无特殊需求，建议您将FTP服务器配置为被动模式。</p><p>FTP支持以下三种认证模式：</p><ul><li>匿名用户模式：任何人无需密码验证就可以直接登录到FTP服务器。这种模式最不安全，一般只用来保存不重要的公开文件，不推荐在生产环境中使用。</li><li>本地用户模式：通过Linux系统本地账号进行验证的模式，相较于匿名用户模式更安全。</li><li>虚拟用户模式：FTP服务器的专有用户。虚拟用户只能访问Linux系统为其提供的FTP服务，而不能访问Linux系统的其它资源，进一步增强了FTP服务器的安全性。</li></ul><p>本文主要介绍被动模式下，使用本地用户访问FTP服务器的配置方法。</p><p>1.修改vsftpd.conf配置文件</p><ol type="1"><li><p>运行以下命令，打开vsftpd的配置文件。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">vim /etc/vsftpd/vsftpd.conf<br></code></pre></td></tr></table></figure></li><li><p>按i进入编辑模式。</p></li><li><p>配置FTP服务器为被动模式。</p><p>具体的配置参数说明如下：</p><p><strong>注意</strong>修改和添加配置文件内的信息时，请注意格式问题。例如，==添加多余的空格会造成无法重启服务的结果==。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#除下面提及的参数，其他参数保持默认值即可。</span><br><br><span class="hljs-comment">#修改下列参数的值：</span><br><span class="hljs-comment">#禁止匿名登录FTP服务器。</span><br>anonymous_enable=NO<br><span class="hljs-comment">#允许本地用户登录FTP服务器。</span><br>local_enable=YES<br><span class="hljs-comment">#监听IPv4 sockets。</span><br>listen=YES<br><br><span class="hljs-comment">#在行首添加#注释掉以下参数：</span><br><span class="hljs-comment">#关闭监听IPv6 sockets。</span><br><span class="hljs-comment">#listen_ipv6=YES</span><br><br><span class="hljs-comment">#在配置文件的末尾添加下列参数：</span><br><span class="hljs-comment">#设置本地用户登录后所在目录。如需修改共享文件夹，修改目录即可</span><br>local_root=/var/ftp/test<br><span class="hljs-comment">#全部用户被限制在主目录。</span><br>chroot_local_user=YES<br><span class="hljs-comment">#启用例外用户名单。</span><br>chroot_list_enable=YES<br><span class="hljs-comment">#指定例外用户列表文件，列表中用户不被锁定在主目录。</span><br>chroot_list_file=/etc/vsftpd/chroot_list<br><span class="hljs-comment">#开启被动模式。</span><br>pasv_enable=YES<br>allow_writeable_chroot=YES<br><span class="hljs-comment">#本教程中为Linux实例的公网IP。</span><br>pasv_address=&lt;FTP服务器公网IP地址&gt;<br><span class="hljs-comment">#设置被动模式下，建立数据传输可使用的端口范围的最小值。</span><br><span class="hljs-comment">#建议您把端口范围设置在一段比较高的范围内，例如50000~50010，有助于提高访问FTP服务器的安全性。</span><br>pasv_min_port=&lt;port number&gt;<br><span class="hljs-comment">#设置被动模式下，建立数据传输可使用的端口范围的最大值。</span><br>pasv_max_port=&lt;port number&gt;<br></code></pre></td></tr></table></figure><p>更多参数的详细信息，请参见<ahref="https://help.aliyun.com/document_detail/92048.htm#section-t9a-ors-44c">vsftp配置文件及参数说明</a>。</p><p>4.修改完，保存退出vim。运行以下命令重启vsftpd服务即可。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs undefined">systemctl restart vsftpd.service<br></code></pre></td></tr></table></figure></li></ol><h2 id="vsftp配置文件及参数说明">vsftp配置文件及参数说明</h2><p>/etc/vsftpd目录下文件说明如下：</p><ul><li>/etc/vsftpd/vsftpd.conf是vsftpd的核心配置文件。</li><li>/etc/vsftpd/ftpusers是黑名单文件，此文件中的用户不允许访问FTP服务器。</li><li>/etc/vsftpd/user_list是白名单文件，此文件中的用户允许访问FTP服务器。</li></ul><p>配置文件vsftpd.conf参数说明如下：</p><ul><li><p>用户登录控制参数说明如下表所示。</p><table><thead><tr class="header"><th style="text-align: left;">参数</th><th style="text-align: left;">说明</th></tr></thead><tbody><tr class="odd"><td style="text-align: left;">anonymous_enable=YES</td><td style="text-align: left;">接受匿名用户</td></tr><tr class="even"><td style="text-align: left;">no_anon_password=YES</td><td style="text-align: left;">匿名用户login时不询问口令</td></tr><tr class="odd"><td style="text-align: left;">anon_root=（none）</td><td style="text-align: left;">匿名用户主目录</td></tr><tr class="even"><td style="text-align: left;">local_enable=YES</td><td style="text-align: left;">接受本地用户</td></tr><tr class="odd"><td style="text-align: left;">local_root=（none）</td><td style="text-align: left;">本地用户主目录</td></tr></tbody></table></li><li><p>用户权限控制参数说明如下表所示。</p><table><thead><tr class="header"><th style="text-align: left;">参数</th><th style="text-align: left;">说明</th></tr></thead><tbody><tr class="odd"><td style="text-align: left;">write_enable=YES</td><td style="text-align: left;">可以上传文件（全局控制）</td></tr><tr class="even"><td style="text-align: left;">local_umask=022</td><td style="text-align: left;">本地用户上传的文件权限</td></tr><tr class="odd"><td style="text-align: left;">file_open_mode=0666</td><td style="text-align: left;">上传文件的权限配合umask使用</td></tr><tr class="even"><td style="text-align: left;">anon_upload_enable=NO</td><td style="text-align: left;">匿名用户可以上传文件</td></tr><tr class="odd"><td style="text-align: left;">anon_mkdir_write_enable=NO</td><td style="text-align: left;">匿名用户可以建目录</td></tr><tr class="even"><td style="text-align: left;">anon_other_write_enable=NO</td><td style="text-align: left;">匿名用户修改删除</td></tr><tr class="odd"><td style="text-align: left;">chown_username=lightwiter</td><td style="text-align: left;">匿名上传文件所属用户名</td></tr></tbody></table></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>ftp 协议</title>
    <link href="/2022/05/26/ftp-%E5%8D%8F%E8%AE%AE/"/>
    <url>/2022/05/26/ftp-%E5%8D%8F%E8%AE%AE/</url>
    
    <content type="html"><![CDATA[<p>FTP（File TransferProtocol）是一种文件传输协议，基于客户端/服务器架构，支持以下两种工作模式：</p><ul><li>主动模式（PORT）：客户端向FTP服务器发送端口信息，由服务器主动连接该端口。</li><li>被动模式（PASV）：FTP服务器开启并发送端口信息给客户端，由客户端连接该端口，服务器被动接受连接。</li></ul><p>FTP支持以下三种认证模式：</p><ul><li>匿名用户模式：任何人无需密码验证就可以直接登录FTP服务器。该模式不安全，一般只用来传输不重要的公开文件，不推荐在生产环境中使用。</li><li>本地用户模式：通过Linux系统本地用户验证登录权限，相较于匿名用户模式更安全。</li><li>虚拟用户模式：通过虚拟用户验证登录权限，虚拟用户只能访问Linux系统为其提供的FTP服务，而不能访问Linux系统的其它资源。该模式相较于其他两种模式更加安全，如果您对服务器的数据有较高的安全性要求，建议在相关专业人员的指导下，自行配置该模式。</li></ul><p>本文主要介绍配置简单的匿名用户模式以及较为安全的本地用户模式。</p><h2 id="步骤一准备工作">步骤一：准备工作</h2><p>本文将使用FTP客户端工具FileZilla连接FTP服务器，因此您需要完成以下准备工作：</p><ol type="1"><li><p>在本地主机上，下载并安装FileZilla。</p><p>具体下载地址，请参见<ahref="https://www.filezilla.cn/download">FileZilla下载中心</a>。</p></li><li><p>重置Linux服务器的</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">root</span><br></code></pre></td></tr></table></figure><p>用户的密码。</p><p>具体操作，请参见<ahref="https://help.aliyun.com/document_detail/60055.htm#task305">管理服务器密码</a>。</p></li></ol><h2 id="步骤二安装与配置vsftpd">步骤二：安装与配置vsftpd</h2><ol type="1"><li><p>远程连接Linux服务器。</p><p>具体操作，请参见<ahref="https://help.aliyun.com/document_detail/59083.htm#multiTask1826">远程连接Linux服务器</a>。本示例中，将通过管理控制台远程连接Linux服务器，并切换至<code>root</code>用户进行后续操作。</p><p><strong>说明</strong>通过管理控制台远程连接Linux服务器时，您的身份为普通用户。如果不切换至<code>root</code>用户，运行部分命令时可能出现Error:This command has to be run under the root user.的报错。</p><ol type="1"><li><p>远程连接Linux服务器后，运行以下命令，切换至<code>root</code>用户。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs undefined">sudo su root<br></code></pre></td></tr></table></figure></li><li><p>运行以下命令，返回至<code>root</code>用户的根目录。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span><br></code></pre></td></tr></table></figure><p>完整的命令行操作示例如下图所示：<imgsrc="https://help-static-aliyun-doc.aliyuncs.com/assets/img/zh-CN/7683998161/p266415.png"alt="su root" /></p><p><strong>说明</strong>通过以上命令行操作切换至<code>root</code>用户后，如果您需要返回至普通用户，请运行<strong>exit</strong>命令。</p></li></ol></li><li><p>运行以下命令，安装vsftpd。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs undefined">yum install -y vsftpd<br></code></pre></td></tr></table></figure><p>出现如下图所示信息，表示vsftpd安装成功。<imgsrc="https://help-static-aliyun-doc.aliyuncs.com/assets/img/zh-CN/3389188161/p265287.png"alt="轻量-安装ftp" /></p></li><li><p>运行以下命令，设置FTP服务开机自启动。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">systemctl <span class="hljs-built_in">enable</span> vsftpd.service<br></code></pre></td></tr></table></figure></li><li><p>运行以下命令，启动FTP服务。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">systemctl <span class="hljs-keyword">start</span> vsftpd.service<br></code></pre></td></tr></table></figure></li><li><p>运行以下命令，查看FTP服务的端口号。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs undefined">netstat -antup | grep ftp<br></code></pre></td></tr></table></figure><p>如下图所示，可查看到FTP服务的端口号，表示服务已正常启动。<imgsrc="https://help-static-aliyun-doc.aliyuncs.com/assets/img/zh-CN/7683998161/p265294.png"alt="轻量-FTP状态" /></p></li></ol><h2id="步骤三设置ftp服务器的访问模式">步骤三：设置FTP服务器的访问模式</h2><p>您可以选择以下任一方式设置FTP服务器，建议您使用更加安全的本地用户模式。</p><ul><li><p>匿名访问模式：</p><ol type="1"><li><p>运行以下命令，修改配置文件</p><p>/etc/vsftpd/vsftpd.conf</p><p>。</p><p>如果您在安装vsftpd时，使用的是<strong>apt installvsftpd</strong>安装命令，则配置文件路径为/etc/vsftpd.conf。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">vim /etc/vsftpd/vsftpd.conf<br></code></pre></td></tr></table></figure></li><li><p>按i进入编辑模式。</p></li><li><p>分别找到匿名模式（</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">anonymous_enable</span><br></code></pre></td></tr></table></figure><p>）以及匿名上传权限（</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">anon_upload_enable</span><br></code></pre></td></tr></table></figure><p>），并确认已修改为开启状态。</p><p>不同操作系统版本中，默认的配置文件信息可能有所不同，您需要保证修改后的参数配置，如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs objectc">anonymous_enable=YES<br>anon_upload_enable=YES<br></code></pre></td></tr></table></figure></li><li><p>在文件的末尾，新增以下参数。</p><p><strong>注意</strong>复制以下参数，然后粘贴至Linux服务器的配置文件时，请注意参数不要被<code>#</code>号注释掉。同时，请注意格式问题。例如，添加多余的空格会造成无法重启服务的结果。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#开启被动模式。</span><br>pasv_enable=YES<br><span class="hljs-comment">#设置被动模式下，建立数据传输可使用的端口范围的最小值。</span><br><span class="hljs-comment">#建议您把端口范围设置在一段比较高的范围内，例如50000~50010，有助于提高访问FTP服务器的安全性。</span><br>pasv_min_port=&lt;port number&gt;<br><span class="hljs-comment">#设置被动模式下，建立数据传输可使用的端口范围的最大值。</span><br>pasv_max_port=&lt;port number&gt;<br></code></pre></td></tr></table></figure></li><li><p>按Esc退出编辑模式，然后输入<code>:wq</code>并回车，保存退出文件。</p></li><li><p>运行以下命令，更改</p><p>/var/ftp/pub</p><p>目录的权限，为FTP用户添加写权限。</p><p>/var/ftp/pub为FTP服务默认的文件目录。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">chmod</span> o+w /var/ftp/pub/<br></code></pre></td></tr></table></figure></li><li><p>运行以下命令，重启FTP服务。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs undefined">systemctl restart vsftpd.service<br></code></pre></td></tr></table></figure></li></ol></li><li><p>本地用户模式：</p><ol type="1"><li><p>运行以下命令为FTP服务创建一个Linux用户。</p><p>本示例中，该用户名为<code>ftptest</code>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs undefined">adduser ftptest<br></code></pre></td></tr></table></figure></li><li><p>运行以下命令修改</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">ftptest</span><br></code></pre></td></tr></table></figure><p>用户的密码。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs undefined">passwd ftptest<br></code></pre></td></tr></table></figure><p>运行命令后，根据命令行提示完成FTP用户的密码修改。</p></li><li><p>运行以下命令创建一个供FTP服务使用的文件目录。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">mkdir</span> /var/ftp/test<br></code></pre></td></tr></table></figure></li><li><p>运行以下命令更改/var/ftp/test目录的拥有者为</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">ftptest</span><br></code></pre></td></tr></table></figure><p>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">chown</span> -R ftptest:ftptest /var/ftp/test<br></code></pre></td></tr></table></figure></li><li><p>修改vsftpd.conf配置文件。</p><ol type="1"><li><p>运行以下命令，修改配置文件</p><p>/etc/vsftpd/vsftpd.conf</p><p>。</p><p>如果您在安装vsftpd时，使用的是<strong>apt installvsftpd</strong>安装命令，则配置文件路径为/etc/vsftpd.conf。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">vim /etc/vsftpd/vsftpd.conf<br></code></pre></td></tr></table></figure></li><li><p>按i进入编辑模式。</p></li><li><p>配置FTP服务器为被动模式。</p><p>具体的配置参数说明如下：</p><p><strong>注意</strong>复制以下参数，然后粘贴至Linux服务器的配置文件时，请注意参数不要被<code>#</code>号注释掉。同时，请注意格式问题。例如，添加多余的空格会造成无法重启服务的结果。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#除下面提及的参数，其他参数保持默认值即可。</span><br><br><span class="hljs-comment">#修改下列参数的值：</span><br><span class="hljs-comment">#禁止匿名登录FTP服务器。</span><br>anonymous_enable=NO<br><span class="hljs-comment">#允许本地用户登录FTP服务器。</span><br>local_enable=YES<br><span class="hljs-comment">#监听IPv4 sockets。</span><br>listen=YES<br><br><span class="hljs-comment">#在行首添加#注释掉以下参数：</span><br><span class="hljs-comment">#关闭监听IPv6 sockets。</span><br><span class="hljs-comment">#listen_ipv6=YES</span><br><br><span class="hljs-comment">#在配置文件的末尾添加下列参数：</span><br><span class="hljs-comment">#设置本地用户登录后所在目录。</span><br>local_root=/var/ftp/test<br><span class="hljs-comment">#全部用户被限制在主目录。</span><br>chroot_local_user=YES<br><span class="hljs-comment">#启用例外用户名单。</span><br>chroot_list_enable=YES<br><span class="hljs-comment">#指定例外用户列表文件，列表中用户不被锁定在主目录。</span><br>chroot_list_file=/etc/vsftpd/chroot_list<br><span class="hljs-comment">#开启被动模式。</span><br>pasv_enable=YES<br>allow_writeable_chroot=YES<br><span class="hljs-comment">#本示例中为Linux服务器的公网IP。</span><br>pasv_address=&lt;FTP服务器公网IP地址&gt;<br><span class="hljs-comment">#设置被动模式下，建立数据传输可使用的端口范围的最小值。</span><br><span class="hljs-comment">#建议您把端口范围设置在一段比较高的范围内，例如50000~50010，有助于提高访问FTP服务器的安全性。</span><br>pasv_min_port=&lt;port number&gt;<br><span class="hljs-comment">#设置被动模式下，建立数据传输可使用的端口范围的最大值。</span><br>pasv_max_port=&lt;port number&gt;<br></code></pre></td></tr></table></figure><p>更多参数的详细信息，请参见<ahref="https://help.aliyun.com/document_detail/60152.html#section-wx4-1bx-kln">vsftp配置文件及参数说明</a>。</p></li><li><p>按Esc退出编辑模式，然后输入<code>:wq</code>并回车，保存退出文件。</p></li></ol></li><li><p>创建</p><p>chroot_list</p><p>文件，并在文件中写入例外用户名单。</p><ol type="1"><li><p>运行以下命令，创建</p><p>chroot_list</p><p>文件。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">vim /etc/vsftpd/chroot_list<br></code></pre></td></tr></table></figure></li><li><p>按i进入编辑模式。</p></li><li><p>输入例外用户名单。此名单中的用户不会被锁定在主目录，可以访问其他目录。</p><p><strong>注意</strong>没有例外用户时，也必须创建chroot_list文件，内容可为空。</p></li><li><p>按Esc退出编辑模式，然后输入<code>:wq</code>并回车，保存退出文件。</p></li></ol></li><li><p>运行以下命令，重启FTP服务。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs undefined">systemctl restart vsftpd.service<br></code></pre></td></tr></table></figure></li></ol></li></ul><h2id="步骤四配置linux服务器的防火墙">步骤四：配置Linux服务器的防火墙</h2><p>搭建好FTP站点后，在Linux服务器的防火墙中，需要放行下列FTP端口。具体操作，请参见<ahref="https://help.aliyun.com/document_detail/59086.htm#section-zy8-x7r-9pl">添加防火墙规则</a>。</p><p>被动模式需开放21端口，以及配置文件/etc/vsftpd/vsftpd.conf中参数<code>pasv_min_port</code>和<code>pasv_max_port</code>之间的所有端口。配置详情如下表所示。</p><table><thead><tr class="header"><th style="text-align: left;">应用类型</th><th style="text-align: left;">协议</th><th style="text-align: left;">端口范围</th></tr></thead><tbody><tr class="odd"><td style="text-align: left;">FTP</td><td style="text-align: left;">TCP</td><td style="text-align: left;">21</td></tr><tr class="even"><td style="text-align: left;">自定义</td><td style="text-align: left;">TCP</td><tdstyle="text-align: left;"><code>pasv_min_port/pasv_max_port</code>。例如：50000/50010</td></tr></tbody></table><p>配置完成后，如下图所示：<imgsrc="https://help-static-aliyun-doc.aliyuncs.com/assets/img/zh-CN/7683998161/p266458.png"alt="FTP防火墙" /></p><h2id="步骤五通过ftp客户端测试连接ftp服务器">步骤五：通过FTP客户端测试连接FTP服务器</h2><ol type="1"><li><p>打开FileZilla客户端。</p></li><li><p>在顶部菜单栏，选择<strong><em>*文件*</em> &gt;*<em>站点管理器*</em></strong>。</p></li><li><p>在<strong>站点管理器</strong>对话框的左下角，单击<strong>新站点</strong>。</p></li><li><p>输入新站点的名称，并完成站点配置。</p><p><imgsrc="https://help-static-aliyun-doc.aliyuncs.com/assets/img/zh-CN/7690838161/p261708.png"alt="filezilla" />具体的配置项说明如下：</p><ul><li><p>新站点名称：您自定义的站点名称。例如<code>test-01</code>。</p></li><li><p>协议：FTP-文件传输协议。</p></li><li><p>主机：FTP服务器公网IP地址。本文中为Linux实例的公网IP地址，例如<code>121.43.XX.XX</code>。</p></li><li><p>端口：21。</p></li><li><p>登录类型：匿名。</p><p>本示例中使用FTP客户端连接匿名模式的FTP服务器。如果您需要使用FTP用户密码连接FTP服务器，则登录类型需要设置为正常，并需要配置用户和密码信息。</p></li></ul></li><li><p>单击</p><p>连接</p><p>。</p><p>连接成功后，您可以对文件进行上传、下载和删除等操作。FileZilla工具界面如下图所示。<imgsrc="https://help-static-aliyun-doc.aliyuncs.com/assets/img/zh-CN/5531787161/p261717.png"alt="filezilla" />图中各区域的信息说明如下表所示。</p><table><thead><tr class="header"><th style="text-align: left;">序号</th><th style="text-align: left;">说明</th></tr></thead><tbody><tr class="odd"><td style="text-align: left;">①</td><td style="text-align: left;">显示命令、FTP连接状态和任务执行结果。</td></tr><tr class="even"><td style="text-align: left;">②</td><td style="text-align: left;">本地区域，显示本地主机的目录信息。</td></tr><tr class="odd"><td style="text-align: left;">③</td><tdstyle="text-align: left;">远程区域，显示FTP服务器的目录信息。匿名模式下，默认目录为/pub。</td></tr><tr class="even"><td style="text-align: left;">④</td><tdstyle="text-align: left;">记录区域，可查看FTP任务的队列信息和日志信息。</td></tr></tbody></table></li></ol><h2 id="vsftp配置文件及参数说明">vsftp配置文件及参数说明</h2><p>/etc/vsftpd目录下文件说明如下：</p><ul><li>/etc/vsftpd/vsftpd.conf是vsftpd的核心配置文件。</li><li>/etc/vsftpd/ftpusers是黑名单文件，此文件中的用户不允许访问FTP服务器。</li><li>/etc/vsftpd/user_list是白名单文件，此文件中的用户允许访问FTP服务器。</li></ul><p>配置文件vsftpd.conf参数说明如下：</p><ul><li><p>用户登录控制参数说明如下表所示。</p><table><thead><tr class="header"><th style="text-align: left;">参数</th><th style="text-align: left;">说明</th></tr></thead><tbody><tr class="odd"><td style="text-align: left;">anonymous_enable=YES</td><td style="text-align: left;">接受匿名用户</td></tr><tr class="even"><td style="text-align: left;">no_anon_password=YES</td><td style="text-align: left;">匿名用户login时不询问口令</td></tr><tr class="odd"><td style="text-align: left;">anon_root=（none）</td><td style="text-align: left;">匿名用户主目录</td></tr><tr class="even"><td style="text-align: left;">local_enable=YES</td><td style="text-align: left;">接受本地用户</td></tr><tr class="odd"><td style="text-align: left;">local_root=（none）</td><td style="text-align: left;">本地用户主目录</td></tr></tbody></table></li><li><p>用户权限控制参数说明如下表所示。</p><table><thead><tr class="header"><th style="text-align: left;">参数</th><th style="text-align: left;">说明</th></tr></thead><tbody><tr class="odd"><td style="text-align: left;">write_enable=YES</td><td style="text-align: left;">可以上传文件（全局控制）</td></tr><tr class="even"><td style="text-align: left;">local_umask=022</td><td style="text-align: left;">本地用户上传的文件权限</td></tr><tr class="odd"><td style="text-align: left;">file_open_mode=0666</td><td style="text-align: left;">上传文件的权限配合umask使用</td></tr><tr class="even"><td style="text-align: left;">anon_upload_enable=NO</td><td style="text-align: left;">匿名用户可以上传文件</td></tr><tr class="odd"><td style="text-align: left;">anon_mkdir_write_enable=NO</td><td style="text-align: left;">匿名用户可以建目录</td></tr><tr class="even"><td style="text-align: left;">anon_other_write_enable=NO</td><td style="text-align: left;">匿名用户修改删除</td></tr><tr class="odd"><td style="text-align: left;">chown_username=lightwiter</td><td style="text-align: left;">匿名上传文件所属用户名</td></tr></tbody></table></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>大气光学湍流模型研究与实践-笔记</title>
    <link href="/2022/05/24/%E5%A4%A7%E6%B0%94%E5%85%89%E5%AD%A6%E6%B9%8D%E6%B5%81%E6%A8%A1%E5%9E%8B%E7%A0%94%E7%A9%B6%E4%B8%8E%E5%AE%9E%E8%B7%B5-%E7%AC%94%E8%AE%B0/"/>
    <url>/2022/05/24/%E5%A4%A7%E6%B0%94%E5%85%89%E5%AD%A6%E6%B9%8D%E6%B5%81%E6%A8%A1%E5%9E%8B%E7%A0%94%E7%A9%B6%E4%B8%8E%E5%AE%9E%E8%B7%B5-%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<p>大气光学湍流强度在垂直方向的分布，称为<strong>大气光学湍流廓线</strong>，通常记为<span class="math inline">\(C_{n}^{2}\)</span>廓线</p><p>大气相干长度 <spanclass="math inline">\(r_0\)</span>,也被称为Fried常数，表征<strong>分辨率不再受大气湍流影响的望远镜的等效口径</strong>。<spanclass="math inline">\(C_n^2\)</span>廓线直接对高度积分，就可以得到大气相干长度。<spanclass="math inline">\(r_0\)</span>进行简单的变化，就是我们经常使用的大气视宁度。<spanclass="math inline">\(ε=0.98\frac{λ}{r_0}\)</span>,<strong>大气视宁度</strong>表示大口径望远镜焦面上星象的半峰全宽。</p><p>自适应光学技术通过实时补偿大气扰动造成的波前畸变，来改善成像质量。对天文选址提出新的要求，高空湍流及其相关的参数：等晕角、大气相干时间则变得更加重要。</p><p><strong>等晕角 <spanclass="math inline">\(θ_{AO}\)</span></strong>表示在望远镜的入瞳处具有近似波前的两个星象的最大角距。高空<spanclass="math inline">\(C_n^2\)</span>值越大，等晕角的值越小。等晕角<spanclass="math inline">\(θ_{AO}\)</span>对于N个变形镜的自适应光学系统，能够归一化到<spanclass="math inline">\(θ_{N}\)</span>,它对应的改正后的等晕区的视场，能够影响覆盖天区的大小。</p><p><strong>大气相干时间 <spanclass="math inline">\(τ_{AO}\)</span></strong>表示波前保持相干时间。V(h)表示大气风速廓线。湍流强度所在位置的风速越大，大气相干时间的值越小。</p><p><strong>湍流外尺度 <span class="math inline">\(L_0\)</span>,内尺度<span class="math inline">\(l_0\)</span>。温度结构函数 <spanclass="math inline">\(C_t^2\)</span></strong>。</p><p>位温θ，位温的结构函数<spanclass="math inline">\(D_θ（l）\)</span>，其中 <spanclass="math inline">\(\overline{N}\)</span>表示位温扰动方差的耗散率，<spanclass="math inline">\(\epsilon\)</span>为湍动能耗散率。<spanclass="math inline">\(C_θ^2\)</span>表示位温结构常数。</p><p><strong>理查德森数 <spanclass="math inline">\(R_i\)</span></strong>来表示大气光学湍流的稳定程度。</p><p>目前已有许多成熟的技术设备来测量 <spanclass="math inline">\(C_{n}^{2}\)</span>廓线及其积分参数值：</p><p><strong>DIMM(Differential Image MotionMonitor)</strong>,SLODAR等通过测量波前倾斜来获取光学湍流参数；可以测量大气相干长度，或者视宁度。</p><p><strong>MASS（Multi-Aperture ScintillationSenor）</strong>,SCIDAR(Scintillation Detection andRanging)等通过测量闪烁；可以测量 <spanclass="math inline">\(C_{n}^{2}\)</span>廓线、大气相干长度、大气相干时间、等晕角。</p><p>SODAR，<strong>SNODAR（Surface layer Non-Doppler AcousticRadar）</strong>等通过向空间发射声波，通过接受回波来计算官学湍流信息。可以测量<spanclass="math inline">\(C_{n}^{2}\)</span>廓线、大气相干长度、大气相干时间、等晕角。</p><p>探空气不适合研究天文台址的光学湍流参数。目前用于计算光学湍流参数的气象模式主要有Meso-NH（Non-HydrostaticMesoscale Atmospheric Model）、==WRF（Weather Research and ForecastingMoel）==和MM5（Mesoscale Model 5）；</p><p>WRF是由美国开发的新一代中尺度非静力学天气预报模式。WRF模式分为两种，<strong>ARF（theAdvanced Research）和NMM（the Nonhydrostatic MesoscaleModel）</strong>，即==高级研究和业务预报==两种模式，水平方向采用ArakawaC网格点，垂直方向则采用地形跟随质量坐标。在时间积分方面采用三阶或者四阶的Runge-Kutta算法。WRF模式的源代码以及所需地形、气象数据都可以由NCAR和NCEP的网站下载。</p><p>英文对照</p><p>相干时间 coherent time COH_TIME</p><p>等晕角 isohalo angle ISO_ANGLE</p><p>边界层视宁度 boundary layer seeing</p><p>经纬度 Longitude and latitude</p><p>地表高度 surface height</p><p>相干长度 coherence length</p><p>自由大气视宁角 Free Atmospheric Seeing Angle</p><p>高度 high</p><p>厚度 thickness</p><p>风速 wind speed</p><p>风向 wind direction</p><p>风速梯度 wind speed gradient</p><p>温度 temperature</p><p>气温 air temperature</p><p>位温 Potential temperature</p><p>位温梯度 Potential temperature gradient</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Fortran-动态数组&amp;导出数据类型&amp;指针</title>
    <link href="/2022/05/23/Fortran-%E5%8A%A8%E6%80%81%E6%95%B0%E7%BB%84-%E5%AF%BC%E5%87%BA%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B-%E6%8C%87%E9%92%88/"/>
    <url>/2022/05/23/Fortran-%E5%8A%A8%E6%80%81%E6%95%B0%E7%BB%84-%E5%AF%BC%E5%87%BA%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B-%E6%8C%87%E9%92%88/</url>
    
    <content type="html"><![CDATA[<h2 id="动态数组">动态数组</h2><p>动态数组是一种数组，其尺寸在编译时不知道，而是在执行时才已知/确定的。</p><p>​ 动态数组的属性使用 allocatable 声明。 .</p><p>​ 例如，</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs fortran"><span class="hljs-keyword">real</span>, <span class="hljs-keyword">dimension</span> (:,:), <span class="hljs-keyword">allocatable</span> :: darray    <br></code></pre></td></tr></table></figure><p>​数组的秩，即尺寸，必须提到但是，分配内存以这样的阵列，可以使用allocate函数。</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs fortran"><span class="hljs-built_in">allocate</span> ( darray(s1,s2) )      <br></code></pre></td></tr></table></figure><p>​ 该阵列使用后，在该程序中，所创建的存储器应该使用 deallocate函数解除</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs fortran"><span class="hljs-built_in">deallocate</span> (darray)  <br></code></pre></td></tr></table></figure><p>​ <strong>示例</strong></p><p>​ 下面的例子演示了上面讨论的概念。</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs fortran"><span class="hljs-function"><span class="hljs-keyword">program</span></span> dynamic_array <br><span class="hljs-keyword">implicit</span> <span class="hljs-keyword">none</span> <br><br>   <span class="hljs-comment">!rank is 2, but size not known   </span><br>   <span class="hljs-keyword">real</span>, <span class="hljs-keyword">dimension</span> (:,:), <span class="hljs-keyword">allocatable</span> :: darray    <br>   <span class="hljs-keyword">integer</span> :: s1, s2     <br>   <span class="hljs-keyword">integer</span> :: i, j     <br>   <br>   <span class="hljs-built_in">print</span>*, <span class="hljs-string">&quot;Enter the size of the array:&quot;</span>     <br>   read*, s1, s2      <br>   <br>   <span class="hljs-comment">! allocate memory      </span><br>   <span class="hljs-built_in">allocate</span> ( darray(s1,s2) )      <br>   <br>   <span class="hljs-keyword">do</span> i = <span class="hljs-number">1</span>, s1           <br>      <span class="hljs-keyword">do</span> j = <span class="hljs-number">1</span>, s2                <br>         darray(i,j) = i*j               <br>         <span class="hljs-built_in">print</span>*, <span class="hljs-string">&quot;darray(&quot;</span>,i,<span class="hljs-string">&quot;,&quot;</span>,j,<span class="hljs-string">&quot;) = &quot;</span>, darray(i,j)           <br>      <span class="hljs-keyword">end</span> <span class="hljs-keyword">do</span>      <br>   <span class="hljs-keyword">end</span> <span class="hljs-keyword">do</span>      <br>   <br>   <span class="hljs-built_in">deallocate</span> (darray)  <br><span class="hljs-keyword">end</span> <span class="hljs-function"><span class="hljs-keyword">program</span></span> dynamic_array<br></code></pre></td></tr></table></figure><p>​ 当上述代码被编译和执行时，它产生了以下结果：</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs fortran">Enter the <span class="hljs-built_in">size</span> of the array: <span class="hljs-number">3</span>,<span class="hljs-number">4</span><br>darray( <span class="hljs-number">1</span> , <span class="hljs-number">1</span> ) = <span class="hljs-number">1.00000000</span>    <br>darray( <span class="hljs-number">1</span> , <span class="hljs-number">2</span> ) = <span class="hljs-number">2.00000000</span>    <br>darray( <span class="hljs-number">1</span> , <span class="hljs-number">3</span> ) = <span class="hljs-number">3.00000000</span>    <br>darray( <span class="hljs-number">1</span> , <span class="hljs-number">4</span> ) = <span class="hljs-number">4.00000000</span>    <br>darray( <span class="hljs-number">2</span> , <span class="hljs-number">1</span> ) = <span class="hljs-number">2.00000000</span>    <br>darray( <span class="hljs-number">2</span> , <span class="hljs-number">2</span> ) = <span class="hljs-number">4.00000000</span>    <br>darray( <span class="hljs-number">2</span> , <span class="hljs-number">3</span> ) = <span class="hljs-number">6.00000000</span>    <br>darray( <span class="hljs-number">2</span> , <span class="hljs-number">4</span> ) = <span class="hljs-number">8.00000000</span>    <br>darray( <span class="hljs-number">3</span> , <span class="hljs-number">1</span> ) = <span class="hljs-number">3.00000000</span>    <br>darray( <span class="hljs-number">3</span> , <span class="hljs-number">2</span> ) = <span class="hljs-number">6.00000000</span>    <br>darray( <span class="hljs-number">3</span> , <span class="hljs-number">3</span> ) = <span class="hljs-number">9.00000000</span>    <br>darray( <span class="hljs-number">3</span> , <span class="hljs-number">4</span> ) = <span class="hljs-number">12.0000000</span>   <br></code></pre></td></tr></table></figure><h3 id="使用data语句">使用data语句</h3><p>​ data 语句可用于初始化多个阵列，或用于阵列部分的初始化。</p><p>​ data 语句的语法是：</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs fortran"><span class="hljs-keyword">data</span> variable / list / ...<br></code></pre></td></tr></table></figure><p>​ <strong>示例</strong></p><p>​ 下面的例子演示了这一概念：</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs fortran"><span class="hljs-function"><span class="hljs-keyword">program</span></span> dataStatement<br><span class="hljs-keyword">implicit</span> <span class="hljs-keyword">none</span><br><br>   <span class="hljs-keyword">integer</span> :: a(<span class="hljs-number">5</span>), b(<span class="hljs-number">3</span>,<span class="hljs-number">3</span>), c(<span class="hljs-number">10</span>),i, j<br>   <span class="hljs-keyword">data</span> a /<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>,<span class="hljs-number">10</span>,<span class="hljs-number">11</span>/ <br>   <br>   <span class="hljs-keyword">data</span> b(<span class="hljs-number">1</span>,:) /<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>/ <br>   <span class="hljs-keyword">data</span> b(<span class="hljs-number">2</span>,:)/<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>/ <br>   <span class="hljs-keyword">data</span> b(<span class="hljs-number">3</span>,:)/<span class="hljs-number">3</span>,<span class="hljs-number">3</span>,<span class="hljs-number">3</span>/ <br>   <span class="hljs-keyword">data</span> (c(i),i=<span class="hljs-number">1</span>,<span class="hljs-number">10</span>,<span class="hljs-number">2</span>) /<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>/ <br>   <span class="hljs-keyword">data</span> (c(i),i=<span class="hljs-number">2</span>,<span class="hljs-number">10</span>,<span class="hljs-number">2</span>)/<span class="hljs-number">5</span>*<span class="hljs-number">2</span>/<br>   <br>   <span class="hljs-built_in">Print</span> *, <span class="hljs-string">&#x27;The A array:&#x27;</span><br>   <span class="hljs-keyword">do</span> j = <span class="hljs-number">1</span>, <span class="hljs-number">5</span>                <br>      <span class="hljs-built_in">print</span>*, a(j)           <br>   <span class="hljs-keyword">end</span> <span class="hljs-keyword">do</span> <br>   <br>   <span class="hljs-built_in">Print</span> *, <span class="hljs-string">&#x27;The B array:&#x27;</span><br>   <span class="hljs-keyword">do</span> i = <span class="hljs-built_in">lbound</span>(b,<span class="hljs-number">1</span>), <span class="hljs-built_in">ubound</span>(b,<span class="hljs-number">1</span>)<br>      <span class="hljs-built_in">write</span>(*,*) (b(i,j), j = <span class="hljs-built_in">lbound</span>(b,<span class="hljs-number">2</span>), <span class="hljs-built_in">ubound</span>(b,<span class="hljs-number">2</span>))<br>   <span class="hljs-keyword">end</span> <span class="hljs-keyword">do</span><br><br>   <span class="hljs-built_in">Print</span> *, <span class="hljs-string">&#x27;The C array:&#x27;</span> <br>   <span class="hljs-keyword">do</span> j = <span class="hljs-number">1</span>, <span class="hljs-number">10</span>                <br>      <span class="hljs-built_in">print</span>*, c(j)           <br>   <span class="hljs-keyword">end</span> <span class="hljs-keyword">do</span>      <br>   <br><span class="hljs-keyword">end</span> <span class="hljs-function"><span class="hljs-keyword">program</span></span> dataStatement<br></code></pre></td></tr></table></figure><p>​ 当上述代码被编译和执行时，它产生了以下结果：</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs fortran">The A array:<br><span class="hljs-number">7</span><br><span class="hljs-number">8</span><br><span class="hljs-number">9</span><br><span class="hljs-number">10</span><br><span class="hljs-number">11</span><br>The B array:<br><span class="hljs-number">1</span>  <span class="hljs-number">1</span>  <span class="hljs-number">1</span><br><span class="hljs-number">2</span>  <span class="hljs-number">2</span>  <span class="hljs-number">2</span><br><span class="hljs-number">3</span>  <span class="hljs-number">3</span>  <span class="hljs-number">3</span><br>The C array:<br><span class="hljs-number">4</span><br><span class="hljs-number">2</span><br><span class="hljs-number">5</span><br><span class="hljs-number">2</span><br><span class="hljs-number">6</span><br><span class="hljs-number">2</span><br><span class="hljs-number">7</span><br><span class="hljs-number">2</span><br><span class="hljs-number">8</span><br><span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><h3 id="使用where语句">使用where语句</h3><p>​where语句可以使用数组中的某些元素在一个表达式，根据一些逻辑条件的结果。它允许表达的执行在一个元素上，如果给定的条件为真。</p><p>​ <strong>例子</strong></p><p>​ 下面的例子演示了这一概念：</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs fortran"><span class="hljs-function"><span class="hljs-keyword">program</span></span> whereStatement<br><span class="hljs-keyword">implicit</span> <span class="hljs-keyword">none</span><br><br>   <span class="hljs-keyword">integer</span> :: a(<span class="hljs-number">3</span>,<span class="hljs-number">5</span>), i , j<br>   <br>   <span class="hljs-keyword">do</span> i = <span class="hljs-number">1</span>,<span class="hljs-number">3</span><br>      <span class="hljs-keyword">do</span> j = <span class="hljs-number">1</span>, <span class="hljs-number">5</span>                <br>         a(i,j) = j-i          <br>      <span class="hljs-keyword">end</span> <span class="hljs-keyword">do</span> <br>   <span class="hljs-keyword">end</span> <span class="hljs-keyword">do</span><br>   <br>   <span class="hljs-built_in">Print</span> *, <span class="hljs-string">&#x27;The A array:&#x27;</span><br>   <br>   <span class="hljs-keyword">do</span> i = <span class="hljs-built_in">lbound</span>(a,<span class="hljs-number">1</span>), <span class="hljs-built_in">ubound</span>(a,<span class="hljs-number">1</span>)<br>      <span class="hljs-built_in">write</span>(*,*) (a(i,j), j = <span class="hljs-built_in">lbound</span>(a,<span class="hljs-number">2</span>), <span class="hljs-built_in">ubound</span>(a,<span class="hljs-number">2</span>))<br>   <span class="hljs-keyword">end</span> <span class="hljs-keyword">do</span><br>   <br>   <span class="hljs-keyword">where</span>( a&lt;<span class="hljs-number">0</span> ) <br>      a = <span class="hljs-number">1</span> <br>   <span class="hljs-keyword">elsewhere</span><br>      a = <span class="hljs-number">5</span><br>   <span class="hljs-keyword">end</span> <span class="hljs-keyword">where</span><br>  <br>   <span class="hljs-built_in">Print</span> *, <span class="hljs-string">&#x27;The A array:&#x27;</span><br>   <span class="hljs-keyword">do</span> i = <span class="hljs-built_in">lbound</span>(a,<span class="hljs-number">1</span>), <span class="hljs-built_in">ubound</span>(a,<span class="hljs-number">1</span>)<br>      <span class="hljs-built_in">write</span>(*,*) (a(i,j), j = <span class="hljs-built_in">lbound</span>(a,<span class="hljs-number">2</span>), <span class="hljs-built_in">ubound</span>(a,<span class="hljs-number">2</span>))<br>   <span class="hljs-keyword">end</span> <span class="hljs-keyword">do</span>   <br>   <br><span class="hljs-keyword">end</span> <span class="hljs-function"><span class="hljs-keyword">program</span></span> whereStatement<br></code></pre></td></tr></table></figure><p>​ 当上述代码被编译和执行时，它产生了以下结果：</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs fortran">The A array:<br><span class="hljs-number">0</span>   <span class="hljs-number">1</span>   <span class="hljs-number">2</span>  <span class="hljs-number">3</span>  <span class="hljs-number">4</span><br>-<span class="hljs-number">1</span>  <span class="hljs-number">0</span>   <span class="hljs-number">1</span>  <span class="hljs-number">2</span>  <span class="hljs-number">3</span><br>-<span class="hljs-number">2</span>  -<span class="hljs-number">1</span>  <span class="hljs-number">0</span>  <span class="hljs-number">1</span>  <span class="hljs-number">2</span><br>The A array:<br><span class="hljs-number">5</span>   <span class="hljs-number">5</span>   <span class="hljs-number">5</span>  <span class="hljs-number">5</span>  <span class="hljs-number">5</span><br><span class="hljs-number">1</span>   <span class="hljs-number">5</span>   <span class="hljs-number">5</span>  <span class="hljs-number">5</span>  <span class="hljs-number">5</span><br><span class="hljs-number">1</span>   <span class="hljs-number">1</span>   <span class="hljs-number">5</span>  <span class="hljs-number">5</span>  <span class="hljs-number">5</span><br></code></pre></td></tr></table></figure><h2 id="导出数据类型">导出数据类型</h2><p>Fortran语言可以定义导出的数据类型。导出的数据类型也被称为一个结构，它可以包含不同类型的数据对象。</p><p>​导出的数据类型被用来代表一个记录。例如要跟踪在图书馆的书，可能希望跟踪的每本书有如下属性：</p><ul><li>​ 标题- Title</li><li>​ 作者 - Author</li><li>​ 科目 - Subject</li><li>​ 编号 - Book ID</li></ul><h2 id="定义一个导出的数据类型">定义一个导出的数据类型</h2><p>​定义一个派生数据类型，类型和端类型的语句被使用。类型语句定义了一个新的数据类型，项目不止一个成员。类型声明的格式是这样的：</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs fortran"><span class="hljs-keyword">type</span> type_name      <br>   declarations<br><span class="hljs-keyword">end</span> <span class="hljs-keyword">type</span> <br></code></pre></td></tr></table></figure><p>​ 这里是会声明书的结构方式：</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs fortran"><span class="hljs-keyword">type</span> Books<br>   <span class="hljs-keyword">character</span>(len=<span class="hljs-number">50</span>) :: title<br>   <span class="hljs-keyword">character</span>(len=<span class="hljs-number">50</span>) :: author<br>   <span class="hljs-keyword">character</span>(len=<span class="hljs-number">150</span>) :: subject<br>   <span class="hljs-keyword">integer</span> :: book_id<br><span class="hljs-keyword">end</span> <span class="hljs-keyword">type</span> Books<br></code></pre></td></tr></table></figure><h2 id="访问结构成员">访问结构成员</h2><p>​ 一个派生数据类型的对象被称为结构</p><p>​ 类型书籍(Books) 的结构像一个类型声明语句创建如下：</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs fortran"><span class="hljs-keyword">type</span>(Books) :: book1 <br></code></pre></td></tr></table></figure><p>​ 结构的组成部分可以使用该组件选择字符(%)进行访问 :</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs fortran">book1%title = <span class="hljs-string">&quot;C Programming&quot;</span><br>book1%author = <span class="hljs-string">&quot;Nuha Ali&quot;</span><br>book1%subject = <span class="hljs-string">&quot;C Programming Tutorial&quot;</span><br>book1%book_id = <span class="hljs-number">6495407</span><br></code></pre></td></tr></table></figure><p>​ <strong>请注意，</strong>％符号前后没有空格。</p><p>​ <strong>示例</strong></p><p>​ 下面的程序说明了上述概念：</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs fortran"><span class="hljs-function"><span class="hljs-keyword">program</span></span> deriveDataType<br><br>   <span class="hljs-comment">!type declaration</span><br>   <span class="hljs-keyword">type</span> Books<br>      <span class="hljs-keyword">character</span>(len=<span class="hljs-number">50</span>) :: title<br>      <span class="hljs-keyword">character</span>(len=<span class="hljs-number">50</span>) :: author<br>      <span class="hljs-keyword">character</span>(len=<span class="hljs-number">150</span>) :: subject<br>      <span class="hljs-keyword">integer</span> :: book_id<br>   <span class="hljs-keyword">end</span> <span class="hljs-keyword">type</span> Books<br>   <br>   <span class="hljs-comment">!declaring type variables</span><br>   <span class="hljs-keyword">type</span>(Books) :: book1 <br>   <span class="hljs-keyword">type</span>(Books) :: book2 <br>   <br>   <span class="hljs-comment">!accessing the components of the structure</span><br>   <br>   book1%title = <span class="hljs-string">&quot;C Programming&quot;</span><br>   book1%author = <span class="hljs-string">&quot;Nuha Ali&quot;</span><br>   book1%subject = <span class="hljs-string">&quot;C Programming Tutorial&quot;</span><br>   book1%book_id = <span class="hljs-number">6495407</span> <br>   <br>   book2%title = <span class="hljs-string">&quot;Telecom Billing&quot;</span><br>   book2%author = <span class="hljs-string">&quot;Zara Ali&quot;</span><br>   book2%subject = <span class="hljs-string">&quot;Telecom Billing Tutorial&quot;</span><br>   book2%book_id = <span class="hljs-number">6495700</span><br>  <br>   <span class="hljs-comment">!display book info</span><br>   <br>   <span class="hljs-built_in">Print</span> *, book1%title <br>   <span class="hljs-built_in">Print</span> *, book1%author <br>   <span class="hljs-built_in">Print</span> *, book1%subject <br>   <span class="hljs-built_in">Print</span> *, book1%book_id  <br>   <br>   <span class="hljs-built_in">Print</span> *, book2%title <br>   <span class="hljs-built_in">Print</span> *, book2%author <br>   <span class="hljs-built_in">Print</span> *, book2%subject <br>   <span class="hljs-built_in">Print</span> *, book2%book_id  <br><br><span class="hljs-keyword">end</span> <span class="hljs-function"><span class="hljs-keyword">program</span></span> deriveDataType<br></code></pre></td></tr></table></figure><p>​ 当上述代码被编译和执行时，它产生了以下结果：</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs fortran"><span class="hljs-comment">C Programming                                     </span><br>Nuha Ali                                          <br><span class="hljs-comment">C Programming Tutorial            </span><br>    <span class="hljs-number">6495407</span><br>Telecom Billing                                   <br>Zara Ali                                          <br>Telecom Billing Tutorial            <br>    <span class="hljs-number">6495700</span><br></code></pre></td></tr></table></figure><h2 id="结构数组">结构数组</h2><p>​ 还可以创建一个派生类型的数组：</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs fortran"><span class="hljs-keyword">type</span>(Books), <span class="hljs-keyword">dimension</span>(<span class="hljs-number">2</span>) :: list<br></code></pre></td></tr></table></figure><p>​ 数组的单个元素，可以访问如下：</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs fortran">list(<span class="hljs-number">1</span>)%title = <span class="hljs-string">&quot;C Programming&quot;</span><br>list(<span class="hljs-number">1</span>)%author = <span class="hljs-string">&quot;Nuha Ali&quot;</span><br>list(<span class="hljs-number">1</span>)%subject = <span class="hljs-string">&quot;C Programming Tutorial&quot;</span><br>list(<span class="hljs-number">1</span>)%book_id = <span class="hljs-number">6495407</span><br></code></pre></td></tr></table></figure><p>​ 下面的程序说明了这个概念：</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs fortran"><span class="hljs-function"><span class="hljs-keyword">program</span></span> deriveDataType<br><br>   <span class="hljs-comment">!type declaration</span><br>   <span class="hljs-keyword">type</span> Books<br>      <span class="hljs-keyword">character</span>(len=<span class="hljs-number">50</span>) :: title<br>      <span class="hljs-keyword">character</span>(len=<span class="hljs-number">50</span>) :: author<br>      <span class="hljs-keyword">character</span>(len=<span class="hljs-number">150</span>) :: subject<br>      <span class="hljs-keyword">integer</span> :: book_id<br>   <span class="hljs-keyword">end</span> <span class="hljs-keyword">type</span> Books<br>   <br>   <span class="hljs-comment">!declaring array of books</span><br>   <span class="hljs-keyword">type</span>(Books), <span class="hljs-keyword">dimension</span>(<span class="hljs-number">2</span>) :: list <br>    <br>   <span class="hljs-comment">!accessing the components of the structure</span><br>   <br>   list(<span class="hljs-number">1</span>)%title = <span class="hljs-string">&quot;C Programming&quot;</span><br>   list(<span class="hljs-number">1</span>)%author = <span class="hljs-string">&quot;Nuha Ali&quot;</span><br>   list(<span class="hljs-number">1</span>)%subject = <span class="hljs-string">&quot;C Programming Tutorial&quot;</span><br>   list(<span class="hljs-number">1</span>)%book_id = <span class="hljs-number">6495407</span> <br>   <br>   list(<span class="hljs-number">2</span>)%title = <span class="hljs-string">&quot;Telecom Billing&quot;</span><br>   list(<span class="hljs-number">2</span>)%author = <span class="hljs-string">&quot;Zara Ali&quot;</span><br>   list(<span class="hljs-number">2</span>)%subject = <span class="hljs-string">&quot;Telecom Billing Tutorial&quot;</span><br>   list(<span class="hljs-number">2</span>)%book_id = <span class="hljs-number">6495700</span><br>  <br>   <span class="hljs-comment">!display book info</span><br>   <br>   <span class="hljs-built_in">Print</span> *, list(<span class="hljs-number">1</span>)%title <br>   <span class="hljs-built_in">Print</span> *, list(<span class="hljs-number">1</span>)%author <br>   <span class="hljs-built_in">Print</span> *, list(<span class="hljs-number">1</span>)%subject <br>   <span class="hljs-built_in">Print</span> *, list(<span class="hljs-number">1</span>)%book_id  <br>   <br>   <span class="hljs-built_in">Print</span> *, list(<span class="hljs-number">1</span>)%title <br>   <span class="hljs-built_in">Print</span> *, list(<span class="hljs-number">2</span>)%author <br>   <span class="hljs-built_in">Print</span> *, list(<span class="hljs-number">2</span>)%subject <br>   <span class="hljs-built_in">Print</span> *, list(<span class="hljs-number">2</span>)%book_id  <br><br><span class="hljs-keyword">end</span> <span class="hljs-function"><span class="hljs-keyword">program</span></span> deriveDataType<br></code></pre></td></tr></table></figure><p>​ 当上述代码被编译和执行时，它产生了以下结果：</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs fortran"><span class="hljs-comment">C Programming                                     </span><br>Nuha Ali                                          <br><span class="hljs-comment">C Programming Tutorial               </span><br>   <span class="hljs-number">6495407</span><br><span class="hljs-comment">C Programming                                     </span><br>Zara Ali                                          <br>Telecom Billing Tutorial                                      <br>   <span class="hljs-number">6495700</span><br></code></pre></td></tr></table></figure><h2 id="指针">指针</h2><p>在大多数编程语言中，一个指针变量存储对象的内存地址。然而，在Fortran中，指针是具有不是仅仅存储存储器地址多功能性的数据对象。它包含有关特定对象的详细信息，如类型，等级，扩展和存储器地址。</p><p>​ 指针是通过分配或指针赋值的目标相关联。</p><h3 id="声明一个指针变量">声明一个指针变量</h3><p>​ 一个指针变量与指针属性声明。</p><p>​ 下面的实施例示出了声明指针变量：</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs fortran"><span class="hljs-keyword">integer</span>, <span class="hljs-keyword">pointer</span> :: p1 <span class="hljs-comment">! pointer to integer  </span><br><span class="hljs-keyword">real</span>, <span class="hljs-keyword">pointer</span>, <span class="hljs-keyword">dimension</span> (:) :: pra <span class="hljs-comment">! pointer to 1-dim real array  </span><br><span class="hljs-keyword">real</span>, <span class="hljs-keyword">pointer</span>, <span class="hljs-keyword">dimension</span> (:,:) :: pra2 <span class="hljs-comment">! pointer to 2-dim real array</span><br></code></pre></td></tr></table></figure><p>​ 指针可以指向：</p><ul><li><p>​ 动态分配的内存区域</p></li><li><p>​ 数据对象与目标属性相同类型的指针</p><h3 id="分配指针的空间">分配指针的空间</h3></li></ul><p>​ allocate语句可以分配指针对象空间。例如：</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs fortran"><span class="hljs-function"><span class="hljs-keyword">program</span></span> pointerExample<br><span class="hljs-keyword">implicit</span> <span class="hljs-keyword">none</span><br><br>   <span class="hljs-keyword">integer</span>, <span class="hljs-keyword">pointer</span> :: p1<br>   <span class="hljs-built_in">allocate</span>(p1)<br>   <br>   p1 = <span class="hljs-number">1</span><br>   <span class="hljs-built_in">Print</span> *, p1<br>   <br>   p1 = p1 + <span class="hljs-number">4</span><br>   <span class="hljs-built_in">Print</span> *, p1<br>   <br><span class="hljs-keyword">end</span> <span class="hljs-function"><span class="hljs-keyword">program</span></span> pointerExample<br></code></pre></td></tr></table></figure><p>​ 当上述代码被编译和执行时，它产生了以下结果：</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs fortran"><span class="hljs-number">1</span><br><span class="hljs-number">5</span><br></code></pre></td></tr></table></figure><p>​应该解除分配语句清空该分配的存储空间当它不再需要，并避免未使用的和不可用的存储器空间的积累。</p><h3 id="目标和关联">目标和关联</h3><p>​目标是另一个正态变量，空间预留给它。目标变量必须与目标属性进行声明。</p><p>​ 一个指针变量使用的关联操作符使目标变量相关联(=&gt;)。</p><p>​ 让我们重写前面的例子中，以说明这个概念：</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs fortran"><span class="hljs-function"><span class="hljs-keyword">program</span></span> pointerExample<br><span class="hljs-keyword">implicit</span> <span class="hljs-keyword">none</span><br><br>   <span class="hljs-keyword">integer</span>, <span class="hljs-keyword">pointer</span> :: p1<br>   <span class="hljs-keyword">integer</span>, <span class="hljs-keyword">target</span> :: t1 <br>   <br>   p1=&gt;t1<br>   p1 = <span class="hljs-number">1</span><br>   <br>   <span class="hljs-built_in">Print</span> *, p1<br>   <span class="hljs-built_in">Print</span> *, t1<br>   <br>   p1 = p1 + <span class="hljs-number">4</span><br>   <br>   <span class="hljs-built_in">Print</span> *, p1<br>   <span class="hljs-built_in">Print</span> *, t1<br>   <br>   t1 = <span class="hljs-number">8</span><br>   <br>   <span class="hljs-built_in">Print</span> *, p1<br>   <span class="hljs-built_in">Print</span> *, t1<br>   <br><span class="hljs-keyword">end</span> <span class="hljs-function"><span class="hljs-keyword">program</span></span> pointerExample<br></code></pre></td></tr></table></figure><p>​ 当上述代码被编译和执行时，它产生了以下结果：</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs fortran"><span class="hljs-number">1</span><br><span class="hljs-number">1</span><br><span class="hljs-number">5</span><br><span class="hljs-number">5</span><br><span class="hljs-number">8</span><br><span class="hljs-number">8</span><br></code></pre></td></tr></table></figure><p>​ 指针可以是：</p><ul><li>​ 未定义的</li><li>​ 关联的</li><li>​ 未关联的</li></ul><p>​在上面的程序中，我们使用associated的指针p1与目标t1时，使用=&gt;运算符。相关的函数，测试指针的关联状态。</p><p>​ 这个声明无效的关联从一个目标一个指针。</p><p>​无效非空目标，因为可能有多个指针指向同一个目标。然而空指针指也是无效的。</p><p>​ 示例 1</p><p>​ 下面的例子演示了概念：</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs fortran"><span class="hljs-function"><span class="hljs-keyword">program</span></span> pointerExample<br><span class="hljs-keyword">implicit</span> <span class="hljs-keyword">none</span><br><br>   <span class="hljs-keyword">integer</span>, <span class="hljs-keyword">pointer</span> :: p1<br>   <span class="hljs-keyword">integer</span>, <span class="hljs-keyword">target</span> :: t1 <br>   <span class="hljs-keyword">integer</span>, <span class="hljs-keyword">target</span> :: t2<br>   <br>   p1=&gt;t1<br>   p1 = <span class="hljs-number">1</span><br>   <br>   <span class="hljs-built_in">Print</span> *, p1<br>   <span class="hljs-built_in">Print</span> *, t1<br>   <br>   p1 = p1 + <span class="hljs-number">4</span><br>   <span class="hljs-built_in">Print</span> *, p1<br>   <span class="hljs-built_in">Print</span> *, t1<br>   <br>   t1 = <span class="hljs-number">8</span><br>   <span class="hljs-built_in">Print</span> *, p1<br>   <span class="hljs-built_in">Print</span> *, t1<br>   <br>   <span class="hljs-built_in">nullify</span>(p1)<br>   <span class="hljs-built_in">Print</span> *, t1<br>   <br>   p1=&gt;t2<br>   <span class="hljs-built_in">Print</span> *, <span class="hljs-built_in">associated</span>(p1)<br>   <span class="hljs-built_in">Print</span>*, <span class="hljs-built_in">associated</span>(p1, t1)<br>   <span class="hljs-built_in">Print</span>*, <span class="hljs-built_in">associated</span>(p1, t2)<br>   <br>   <span class="hljs-comment">!what is the value of p1 at present</span><br>   <span class="hljs-built_in">Print</span> *, p1<br>   <span class="hljs-built_in">Print</span> *, t2<br>   <br>   p1 = <span class="hljs-number">10</span><br>   <span class="hljs-built_in">Print</span> *, p1<br>   <span class="hljs-built_in">Print</span> *, t2<br>   <br><span class="hljs-keyword">end</span> <span class="hljs-function"><span class="hljs-keyword">program</span></span> pointerExample<br></code></pre></td></tr></table></figure><p>​ 当上述代码被编译和执行时，它产生了以下结果：</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs fortran"><span class="hljs-number">1</span><br><span class="hljs-number">1</span><br><span class="hljs-number">5</span><br><span class="hljs-number">5</span><br><span class="hljs-number">8</span><br><span class="hljs-number">8</span><br><span class="hljs-number">8</span><br>T<br>F<br>T<br><span class="hljs-number">952754640</span><br><span class="hljs-number">952754640</span><br><span class="hljs-number">10</span><br><span class="hljs-number">10</span><br></code></pre></td></tr></table></figure><p>​ 请注意，每次运行该代码时，内存地址会有所不同。</p><p>​ <strong>示例 2</strong></p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs fortran"><span class="hljs-function"><span class="hljs-keyword">program</span></span> pointerExample<br><span class="hljs-keyword">implicit</span> <span class="hljs-keyword">none</span><br><br>   <span class="hljs-keyword">integer</span>, <span class="hljs-keyword">pointer</span> :: a, b<br>   <span class="hljs-keyword">integer</span>, <span class="hljs-keyword">target</span> :: t<br>   <span class="hljs-keyword">integer</span> :: n<br>   <br>   t= <span class="hljs-number">1</span><br>   a=&gt;t<br>   t = <span class="hljs-number">2</span><br>   b =&gt; t<br>   n = a + b<br>   <br>   <span class="hljs-built_in">Print</span> *, a, b, t, n <br>   <br><span class="hljs-keyword">end</span> <span class="hljs-function"><span class="hljs-keyword">program</span></span> pointerExample<br></code></pre></td></tr></table></figure><p>​ 当上述代码被编译和执行时，它产生了以下结果：</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs fortran"><span class="hljs-number">2</span>  <span class="hljs-number">2</span>  <span class="hljs-number">2</span>  <span class="hljs-number">4</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Fortran</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Fortran-函数</title>
    <link href="/2022/05/23/Fortran-%E5%87%BD%E6%95%B0/"/>
    <url>/2022/05/23/Fortran-%E5%87%BD%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="向量和矩阵乘法函数">向量和矩阵乘法函数</h2><p><strong>下表描述了向量和矩阵乘法函数：</strong></p><table><thead><tr class="header"><th>函数</th><th>描述</th></tr></thead><tbody><tr class="odd"><td><strong>dot_product</strong>(vector_a, vector_b)</td><td>函数返回两个输入向量，它必须具有相同长度的标量积。</td></tr><tr class="even"><td><strong>matmul </strong>(matrix_a, matrix_b)</td><td>它返回两个矩阵的矩阵乘积，它必须是一致的，即具有相似大小 (m, k) 和(k, n)</td></tr></tbody></table><p>​ <strong>实例</strong></p><p>​ 下面的例子演示了内积：</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs fortran"><span class="hljs-function"><span class="hljs-keyword">program</span></span> arrayDotProduct<br><br>   <span class="hljs-keyword">real</span>, <span class="hljs-keyword">dimension</span>(<span class="hljs-number">5</span>) :: a, b<br>   <span class="hljs-keyword">integer</span>:: i, asize, bsize<br>   <br>   asize = <span class="hljs-built_in">size</span>(a)<br>   bsize = <span class="hljs-built_in">size</span>(b)<br>   <br>   <span class="hljs-keyword">do</span> i = <span class="hljs-number">1</span>, asize<br>      a(i) = i<br>   <span class="hljs-keyword">end</span> <span class="hljs-keyword">do</span><br>   <br>   <span class="hljs-keyword">do</span> i = <span class="hljs-number">1</span>, bsize<br>      b(i) = i*<span class="hljs-number">2</span><br>   <span class="hljs-keyword">end</span> <span class="hljs-keyword">do</span><br>   <br>   <span class="hljs-keyword">do</span> i = <span class="hljs-number">1</span>, asize<br>      <span class="hljs-built_in">Print</span> *, a(i)<br>   <span class="hljs-keyword">end</span> <span class="hljs-keyword">do</span><br>   <br>   <span class="hljs-keyword">do</span> i = <span class="hljs-number">1</span>, bsize<br>      <span class="hljs-built_in">Print</span> *, b(i)<br>   <span class="hljs-keyword">end</span> <span class="hljs-keyword">do</span><br>   <br>   <span class="hljs-built_in">Print</span>*, <span class="hljs-string">&#x27;Vector Multiplication: Dot Product:&#x27;</span><br>   <span class="hljs-built_in">Print</span>*, <span class="hljs-built_in">dot_product</span>(a, b)<br>   <br><span class="hljs-keyword">end</span> <span class="hljs-function"><span class="hljs-keyword">program</span></span> arrayDotProduct<br></code></pre></td></tr></table></figure><p>​ 当上述代码被编译和执行时，它产生了以下结果：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">1</span>.<span class="hljs-number">00000000</span>    <br><span class="hljs-attribute">2</span>.<span class="hljs-number">00000000</span>    <br><span class="hljs-attribute">3</span>.<span class="hljs-number">00000000</span>    <br><span class="hljs-attribute">4</span>.<span class="hljs-number">00000000</span>    <br><span class="hljs-attribute">5</span>.<span class="hljs-number">00000000</span>    <br><span class="hljs-attribute">2</span>.<span class="hljs-number">00000000</span>    <br><span class="hljs-attribute">4</span>.<span class="hljs-number">00000000</span>    <br><span class="hljs-attribute">6</span>.<span class="hljs-number">00000000</span>    <br><span class="hljs-attribute">8</span>.<span class="hljs-number">00000000</span>    <br><span class="hljs-attribute">10</span>.<span class="hljs-number">0000000</span>    <br><span class="hljs-attribute">Vector</span> Multiplication: Dot Product:<br><span class="hljs-attribute">110</span>.<span class="hljs-number">000000</span>   <br></code></pre></td></tr></table></figure><p>​ <strong>实例</strong></p><p>​ 下面的例子演示了矩阵乘法：</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs fortran"><span class="hljs-function"><span class="hljs-keyword">program</span></span> matMulProduct<br><br>   <span class="hljs-keyword">integer</span>, <span class="hljs-keyword">dimension</span>(<span class="hljs-number">3</span>,<span class="hljs-number">3</span>) :: a, b, c<br>   <span class="hljs-keyword">integer</span> :: i, j<br>    <br>   <span class="hljs-keyword">do</span> i = <span class="hljs-number">1</span>, <span class="hljs-number">3</span><br>      <span class="hljs-keyword">do</span> j = <span class="hljs-number">1</span>, <span class="hljs-number">3</span><br>         a(i, j) = i+j<br>      <span class="hljs-keyword">end</span> <span class="hljs-keyword">do</span><br>   <span class="hljs-keyword">end</span> <span class="hljs-keyword">do</span><br>   <br>   <span class="hljs-built_in">print</span> *, <span class="hljs-string">&#x27;Matrix Multiplication: A Matrix&#x27;</span><br>   <br>   <span class="hljs-keyword">do</span> i = <span class="hljs-number">1</span>, <span class="hljs-number">3</span><br>      <span class="hljs-keyword">do</span> j = <span class="hljs-number">1</span>, <span class="hljs-number">3</span><br>         <span class="hljs-built_in">print</span>*, a(i, j)<br>      <span class="hljs-keyword">end</span> <span class="hljs-keyword">do</span><br>   <span class="hljs-keyword">end</span> <span class="hljs-keyword">do</span><br>   <br>   <span class="hljs-keyword">do</span> i = <span class="hljs-number">1</span>, <span class="hljs-number">3</span><br>      <span class="hljs-keyword">do</span> j = <span class="hljs-number">1</span>, <span class="hljs-number">3</span><br>         b(i, j) = i*j<br>      <span class="hljs-keyword">end</span> <span class="hljs-keyword">do</span><br>   <span class="hljs-keyword">end</span> <span class="hljs-keyword">do</span><br>   <br>   <span class="hljs-built_in">Print</span>*, <span class="hljs-string">&#x27;Matrix Multiplication: B Matrix&#x27;</span><br>   <br>   <span class="hljs-keyword">do</span> i = <span class="hljs-number">1</span>, <span class="hljs-number">3</span><br>      <span class="hljs-keyword">do</span> j = <span class="hljs-number">1</span>, <span class="hljs-number">3</span><br>         <span class="hljs-built_in">print</span>*, b(i, j)<br>      <span class="hljs-keyword">end</span> <span class="hljs-keyword">do</span><br>   <span class="hljs-keyword">end</span> <span class="hljs-keyword">do</span><br>   <br>   c = <span class="hljs-built_in">matmul</span>(a, b)<br>   <span class="hljs-built_in">Print</span>*, <span class="hljs-string">&#x27;Matrix Multiplication: Result Matrix&#x27;</span><br>   <br>   <span class="hljs-keyword">do</span> i = <span class="hljs-number">1</span>, <span class="hljs-number">3</span><br>      <span class="hljs-keyword">do</span> j = <span class="hljs-number">1</span>, <span class="hljs-number">3</span><br>         <span class="hljs-built_in">print</span>*, c(i, j)<br>      <span class="hljs-keyword">end</span> <span class="hljs-keyword">do</span><br>   <span class="hljs-keyword">end</span> <span class="hljs-keyword">do</span><br>   <br><span class="hljs-keyword">end</span> <span class="hljs-function"><span class="hljs-keyword">program</span></span> matMulProduct<br></code></pre></td></tr></table></figure><p>​ 当上述代码被编译和执行时，它产生了以下结果：</p><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs gauss"><span class="hljs-keyword">Matrix</span> Multiplication: A <span class="hljs-keyword">Matrix</span><br><span class="hljs-number">2</span><br><span class="hljs-number">3</span><br><span class="hljs-number">4</span><br><span class="hljs-number">3</span><br><span class="hljs-number">4</span><br><span class="hljs-number">5</span><br><span class="hljs-number">4</span><br><span class="hljs-number">5</span><br><span class="hljs-number">6</span><br> <span class="hljs-keyword">Matrix</span> Multiplication: B <span class="hljs-keyword">Matrix</span><br><span class="hljs-number">1</span><br><span class="hljs-number">2</span><br><span class="hljs-number">3</span><br><span class="hljs-number">2</span><br><span class="hljs-number">4</span><br><span class="hljs-number">6</span><br><span class="hljs-number">3</span><br><span class="hljs-number">6</span><br><span class="hljs-number">9</span><br><span class="hljs-keyword">Matrix</span> Multiplication: Result <span class="hljs-keyword">Matrix</span><br><span class="hljs-number">20</span><br><span class="hljs-number">40</span><br><span class="hljs-number">60</span><br><span class="hljs-number">26</span><br><span class="hljs-number">52</span><br><span class="hljs-number">78</span><br><span class="hljs-number">32</span><br><span class="hljs-number">64</span><br><span class="hljs-number">96</span><br></code></pre></td></tr></table></figure><h2 id="还原函数">还原函数</h2><p><strong>下表描述了还原功能</strong>：</p><table><thead><tr class="header"><th>函数</th><th>描述</th></tr></thead><tbody><tr class="odd"><td><strong>all</strong>(mask, dim)</td><td>它返回一个逻辑值，指明掩码的所有关系是.true。以及只有所需的维度，如果第二个参数是给定的。</td></tr><tr class="even"><td><strong>any</strong>(mask, dim)</td><td>它返回一个逻辑值，指明掩码的任何关系是.true。以及只有所需的维度，如果第二个参数是给定的。</td></tr><tr class="odd"><td><strong>count</strong>(mask, dim)</td><td>它返回一个数字值，该值为掩码为 .true关系的数目。以及所需的维数，如果第二个参数给出。</td></tr><tr class="even"><td><strong>maxval</strong>(array, dim, mask)</td><td>它返回的数组的数组中最大的值，那些遵守于第三个参数掩码的关系，如果一个给定的，以及具有只有所需的维数，如果第二个参数dim给出的。</td></tr><tr class="odd"><td><strong>minval</strong>(array, dim, mask)</td><td>它返回数组的数组中那些遵守于第三个参数掩码的关系的最小值，如果一个给定的，以及具有仅在第二个参数dim 给出所期望的维度。</td></tr><tr class="even"><td><strong>product</strong>(array, dim, mask)</td><td>它返回该产品遵守于第三个参数掩码的关系，如果一个给定的，以及具有只有所需的维数，如果第二个参数dim 给出的所有数组的数组中的元素，。</td></tr><tr class="odd"><td><strong>sum </strong>(array, dim, mask)</td><td>它返回遵守于第三个参数掩码关系的总和，如果给定以及具有只有所需的维数，如果第二个参数dim给出的所有数组的数组中的元素。</td></tr></tbody></table><p>​ 例子</p><p>​ 下面的例子演示了这一概念：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">program</span> arrayReduction<br><br>   <span class="hljs-attribute">real</span>, dimension(<span class="hljs-number">3</span>,<span class="hljs-number">2</span>) :: a <br>   <span class="hljs-attribute">a</span> = reshape( (/<span class="hljs-number">5</span>,<span class="hljs-number">9</span>,<span class="hljs-number">6</span>,<span class="hljs-number">10</span>,<span class="hljs-number">8</span>,<span class="hljs-number">12</span>/), (/<span class="hljs-number">3</span>,<span class="hljs-number">2</span>/) ) <br>   <br>   <span class="hljs-attribute">Print</span> *, <span class="hljs-literal">all</span>(a&gt;<span class="hljs-number">5</span>)<br>   <span class="hljs-attribute">Print</span> *, any(a&gt;<span class="hljs-number">5</span>)<br>   <span class="hljs-attribute">Print</span> *, count(a&gt;<span class="hljs-number">5</span>)<br>   <span class="hljs-attribute">Print</span> *, <span class="hljs-literal">all</span>(a&gt;=<span class="hljs-number">5</span> .and. a&lt;<span class="hljs-number">10</span>)<br>  <br><span class="hljs-attribute">end</span> program arrayReduction<br></code></pre></td></tr></table></figure><p>​ 当上述代码被编译和执行时，它产生了以下结果：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs r"><span class="hljs-built_in">F</span><br><span class="hljs-built_in">T</span><br><span class="hljs-number">5</span><br><span class="hljs-built_in">F</span><br></code></pre></td></tr></table></figure><p>​ <strong>实例</strong></p><p>​ 下面的例子演示了这一概念：</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs fortran"><span class="hljs-function"><span class="hljs-keyword">program</span></span> arrayReduction<br><span class="hljs-keyword">implicit</span> <span class="hljs-keyword">none</span><br><br>   <span class="hljs-keyword">real</span>, <span class="hljs-keyword">dimension</span>(<span class="hljs-number">1</span>:<span class="hljs-number">6</span>) :: a = (/ <span class="hljs-number">21.0</span>, <span class="hljs-number">12.0</span>,<span class="hljs-number">33.0</span>, <span class="hljs-number">24.0</span>, <span class="hljs-number">15.0</span>, <span class="hljs-number">16.0</span> /)<br>   <span class="hljs-built_in">Print</span> *, <span class="hljs-built_in">maxval</span>(a)<br>   <span class="hljs-built_in">Print</span> *, <span class="hljs-built_in">minval</span>(a)<br>   <span class="hljs-built_in">Print</span> *, <span class="hljs-built_in">sum</span>(a)<br>   <span class="hljs-built_in">Print</span> *, <span class="hljs-built_in">product</span>(a)<br>   <br><span class="hljs-keyword">end</span> <span class="hljs-function"><span class="hljs-keyword">program</span></span> arrayReduction <br></code></pre></td></tr></table></figure><p>​ 当上述代码被编译和执行时，它产生了以下结果：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">33</span>.<span class="hljs-number">0000000</span>    <br><span class="hljs-attribute">12</span>.<span class="hljs-number">0000000</span>    <br><span class="hljs-attribute">121</span>.<span class="hljs-number">000000</span>    <br><span class="hljs-attribute">47900160</span>.<span class="hljs-number">0</span> <br></code></pre></td></tr></table></figure><h2 id="查询函数">查询函数</h2><p>下表描述了查询功能：</p><table><thead><tr class="header"><th>函数</th><th>描述</th></tr></thead><tbody><tr class="odd"><td><strong>allocated</strong>(array)</td><td>它是一个逻辑功能，它指示该阵列被分配。</td></tr><tr class="even"><td><strong>lbound</strong>(array, dim)</td><td>它返回的数组的维数较低的限制。如果dim(尺寸)不给出一个参数，会得到一个整数向量，如果dim计算在内，得到的整数值正好具有较低维数的限制。</td></tr><tr class="odd"><td><strong>shape</strong>(source)</td><td>它返回一个阵列源为一个整数向量的形状。</td></tr><tr class="even"><td><strong>size</strong>(array, dim)</td><td>它返回在数组元素的数目。如果dim没有给出，并在相关维数的元素个数，如果dim也包括在内。</td></tr><tr class="odd"><td><strong>ubound</strong>(array, dim)</td><td>它返回尺寸的限制。</td></tr></tbody></table><p>​ 例子</p><p>​ 下面的例子演示了这一概念：</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs fortran"><span class="hljs-function"><span class="hljs-keyword">program</span></span> arrayInquiry<br><br>   <span class="hljs-keyword">real</span>, <span class="hljs-keyword">dimension</span>(<span class="hljs-number">3</span>,<span class="hljs-number">2</span>) :: a <br>   a = <span class="hljs-built_in">reshape</span>( (/<span class="hljs-number">5</span>,<span class="hljs-number">9</span>,<span class="hljs-number">6</span>,<span class="hljs-number">10</span>,<span class="hljs-number">8</span>,<span class="hljs-number">12</span>/), (/<span class="hljs-number">3</span>,<span class="hljs-number">2</span>/) ) <br>   <br>   <span class="hljs-built_in">Print</span> *, <span class="hljs-built_in">lbound</span>(a, <span class="hljs-built_in">dim</span>=<span class="hljs-number">1</span>)<br>   <span class="hljs-built_in">Print</span> *, <span class="hljs-built_in">ubound</span>(a, <span class="hljs-built_in">dim</span>=<span class="hljs-number">1</span>)<br>   <span class="hljs-built_in">Print</span> *, <span class="hljs-built_in">shape</span>(a)<br>   <span class="hljs-built_in">Print</span> *, <span class="hljs-built_in">size</span>(a,<span class="hljs-built_in">dim</span>=<span class="hljs-number">1</span>)<br>   <br><span class="hljs-keyword">end</span> <span class="hljs-function"><span class="hljs-keyword">program</span></span> arrayInquiry<br></code></pre></td></tr></table></figure><p>​ 当上述代码被编译和执行时，它产生了以下结果：</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-number">1</span><br><span class="hljs-number">3</span><br><span class="hljs-symbol">3 </span><span class="hljs-number">2</span><br><span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><h2 id="构造函数">构造函数</h2><p>下表介绍了结构功能：</p><table><thead><tr class="header"><th>函数</th><th>描述</th></tr></thead><tbody><tr class="odd"><td><strong>merge</strong>(tsource, fsource, mask)</td><td>该功能连接两个阵列。它给出了tsource及元素，如果mask条件是.true。如果掩码的条件是.false。这两个字段tsource和fsource必须是相同的类型并具有相同的形状。其结果也就是这种类型和形状。还掩码必须具有相同的形状。</td></tr><tr class="even"><td><strong>pack</strong>(array, mask, vector)</td><td>它包一个阵列，以使用掩码的控制向量。逻辑阵列掩模的形状，具有以符合一个用于阵列，要不然掩码必须是一个标量。如果载体被包括在内，它必须是秩1与至少一样多的元素是在掩码为真，并且具有相同的类型的数组的数组(即一个向量)。如果掩码的值为.true。然后矢量代替必须的元件阵列的数量相同。</td></tr><tr class="odd"><td><strong>spread</strong>(source, dim, ncopies)</td><td>它返回相同类型作为参数源与秩增加一个阵列。参数dim和ncopies都是整数。如果ncopies是负则用零值来代替。如果source是一个标量，然后扩散变得所有具有相同值ncopies 元素的向量。参数dim指示哪个索引将被延长。它必须是范围为1和1+(源级)中，如果 source是一个标量，dim 必须是1。参数 ncopies 是在新的尺寸元素的数量。</td></tr><tr class="even"><td><strong>unpack</strong>(vector, mask, array)</td><td>它散射一个载体，掩码下的控制阵列。逻辑阵列掩模的形状具有以符合一个用于数组。阵列载体必须具有等级1(即它是一个向量)与至少一样多的元素是那些掩码内值都为true，并且还必须具有相同类型阵列。如果阵列被给定为一个标量，然后它被认为是使用相同形状的掩码，并在同一标量元素无处不在的阵列。其结果将是具有相同形状的掩码和类型相同的矢量阵列。该值将是那些从所接受的载体，而在阵列的剩余位置的旧值被保留。</td></tr></tbody></table><p>​ <strong>示例</strong></p><p>​ 下面的例子演示了这一概念：</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs fortran"><span class="hljs-function"><span class="hljs-keyword">program</span></span> arrayConstruction<br><span class="hljs-keyword">implicit</span> <span class="hljs-keyword">none</span><br>   <span class="hljs-keyword">interface</span><br>      <span class="hljs-function"><span class="hljs-keyword">subroutine</span></span> write_array (a)<br>         <span class="hljs-keyword">real</span> :: a(:,:)<br>      <span class="hljs-keyword">end</span> <span class="hljs-function"><span class="hljs-keyword">subroutine</span></span> write_array<br>      <br>      <span class="hljs-function"><span class="hljs-keyword">subroutine</span></span> write_l_array (a)<br>         <span class="hljs-keyword">logical</span> :: a(:,:)<br>      <span class="hljs-keyword">end</span> <span class="hljs-function"><span class="hljs-keyword">subroutine</span></span> write_l_array<br>   <span class="hljs-keyword">end</span> <span class="hljs-keyword">interface</span><br><br>   <span class="hljs-keyword">real</span>, <span class="hljs-keyword">dimension</span>(<span class="hljs-number">2</span>,<span class="hljs-number">3</span>) :: tsource, fsource, result<br>   <span class="hljs-keyword">logical</span>, <span class="hljs-keyword">dimension</span>(<span class="hljs-number">2</span>,<span class="hljs-number">3</span>) :: mask<br>   <br>   tsource = <span class="hljs-built_in">reshape</span>( (/ <span class="hljs-number">35</span>, <span class="hljs-number">23</span>, <span class="hljs-number">18</span>, <span class="hljs-number">28</span>, <span class="hljs-number">26</span>, <span class="hljs-number">39</span> /), &amp;<br>                    (/ <span class="hljs-number">2</span>, <span class="hljs-number">3</span> /) )<br>   fsource = <span class="hljs-built_in">reshape</span>( (/ -<span class="hljs-number">35</span>, -<span class="hljs-number">23</span>, -<span class="hljs-number">18</span>, -<span class="hljs-number">28</span>, -<span class="hljs-number">26</span>, -<span class="hljs-number">39</span> /), &amp;<br>                    (/ <span class="hljs-number">2</span>,<span class="hljs-number">3</span> /) )<br>   mask = <span class="hljs-built_in">reshape</span>( (/ .true., .false., .false., .true., &amp;<br>                 .false., .false. /), (/ <span class="hljs-number">2</span>,<span class="hljs-number">3</span> /) )<br><br>   result = <span class="hljs-built_in">merge</span>(tsource, fsource, mask)<br>   <span class="hljs-keyword">call</span> write_array(tsource)<br>   <span class="hljs-keyword">call</span> write_array(fsource)<br>   <span class="hljs-keyword">call</span> write_l_array(mask)<br>   <span class="hljs-keyword">call</span> write_array(result)<br>   <br><span class="hljs-keyword">end</span> <span class="hljs-function"><span class="hljs-keyword">program</span></span> arrayConstruction<br><br><br><br><span class="hljs-function"><span class="hljs-keyword">subroutine</span></span> write_array (a)<br><br>   <span class="hljs-keyword">real</span> :: a(:,:)<br>   <span class="hljs-keyword">do</span> i = <span class="hljs-built_in">lbound</span>(a,<span class="hljs-number">1</span>), <span class="hljs-built_in">ubound</span>(a,<span class="hljs-number">1</span>)<br>      <span class="hljs-built_in">write</span>(*,*) (a(i, j), j = <span class="hljs-built_in">lbound</span>(a,<span class="hljs-number">2</span>), <span class="hljs-built_in">ubound</span>(a,<span class="hljs-number">2</span>) )<br>   <span class="hljs-keyword">end</span> <span class="hljs-keyword">do</span><br>   <span class="hljs-keyword">return</span><br>   <br><span class="hljs-keyword">end</span> <span class="hljs-function"><span class="hljs-keyword">subroutine</span></span> write_array<br><br><br><span class="hljs-function"><span class="hljs-keyword">subroutine</span></span> write_l_array (a)<br><br>   <span class="hljs-keyword">logical</span> :: a(:,:)<br>   <span class="hljs-keyword">do</span> i = <span class="hljs-built_in">lbound</span>(a,<span class="hljs-number">1</span>), <span class="hljs-built_in">ubound</span>(a,<span class="hljs-number">1</span>)<br>      <span class="hljs-built_in">write</span>(*,*) (a(i, j), j= <span class="hljs-built_in">lbound</span>(a,<span class="hljs-number">2</span>), <span class="hljs-built_in">ubound</span>(a,<span class="hljs-number">2</span>))<br>   <span class="hljs-keyword">end</span> <span class="hljs-keyword">do</span><br>   <span class="hljs-keyword">return</span><br>   <br><span class="hljs-keyword">end</span> <span class="hljs-function"><span class="hljs-keyword">subroutine</span></span> write_l_array<br></code></pre></td></tr></table></figure><p>​ 当上述代码被编译和执行时，它产生了以下结果：</p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs dns"><span class="hljs-number">35.0000000</span>   <span class="hljs-number">18.0000000</span>   <span class="hljs-number">26.0000000</span>    <br><span class="hljs-number">23.0000000</span>   <span class="hljs-number">28.0000000</span>   <span class="hljs-number">39.0000000</span>    <br>-<span class="hljs-number">35.0000000</span>  -<span class="hljs-number">18.0000000</span>  -<span class="hljs-number">26.0000000</span>    <br>-<span class="hljs-number">23.0000000</span>  -<span class="hljs-number">28.0000000</span>  -<span class="hljs-number">39.0000000</span>    <br>T F F<br>F T F<br><span class="hljs-number">35.0000000</span>   -<span class="hljs-number">18.0000000</span>  -<span class="hljs-number">26.0000000</span>    <br></code></pre></td></tr></table></figure><h2 id="重塑函数">重塑函数</h2><p>下表描述了重塑函数：</p><table><thead><tr class="header"><th>函数</th><th>描述</th></tr></thead><tbody><tr class="odd"><td><strong>reshape</strong>(source, shape, pad, order)</td><td>它构造一个特定形状的形状，从一个给定source阵列中的元素开始的数组。如果垫不包含则soure的尺寸必须至少为产物(形状)。如果pad包括在内，它必须具有相同的类型的soure。如果order被包括，它必须使用相同的形状的形状的整数数组，值必须是一个排列(1,2,3，...，n)，其中n是在形状要素的数量，它必须小于或等于7。</td></tr></tbody></table><p>​ <strong>示例</strong></p><p>​ 下面的例子演示了这一概念：</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs fortran"><span class="hljs-function"><span class="hljs-keyword">program</span></span> arrayReshape<br><span class="hljs-keyword">implicit</span> <span class="hljs-keyword">none</span><br><br><span class="hljs-keyword">interface</span><br>   <span class="hljs-function"><span class="hljs-keyword">subroutine</span></span> write_matrix(a)<br>   <span class="hljs-keyword">real</span>, <span class="hljs-keyword">dimension</span>(:,:) :: a<br>   <span class="hljs-keyword">end</span> <span class="hljs-function"><span class="hljs-keyword">subroutine</span></span> write_matrix<br>   <span class="hljs-keyword">end</span> <span class="hljs-keyword">interface</span><br><br>   <span class="hljs-keyword">real</span>, <span class="hljs-keyword">dimension</span> (<span class="hljs-number">1</span>:<span class="hljs-number">9</span>) :: b = (/ <span class="hljs-number">21</span>, <span class="hljs-number">22</span>, <span class="hljs-number">23</span>, <span class="hljs-number">24</span>, <span class="hljs-number">25</span>, <span class="hljs-number">26</span>, <span class="hljs-number">27</span>, <span class="hljs-number">28</span>, <span class="hljs-number">29</span> /)<br>   <span class="hljs-keyword">real</span>, <span class="hljs-keyword">dimension</span> (<span class="hljs-number">1</span>:<span class="hljs-number">3</span>, <span class="hljs-number">1</span>:<span class="hljs-number">3</span>) :: c, d, e<br>   <span class="hljs-keyword">real</span>, <span class="hljs-keyword">dimension</span> (<span class="hljs-number">1</span>:<span class="hljs-number">4</span>, <span class="hljs-number">1</span>:<span class="hljs-number">4</span>) :: f, g, h<br><br>   <span class="hljs-keyword">integer</span>, <span class="hljs-keyword">dimension</span> (<span class="hljs-number">1</span>:<span class="hljs-number">2</span>) :: order1 = (/ <span class="hljs-number">1</span>, <span class="hljs-number">2</span> /)<br>   <span class="hljs-keyword">integer</span>, <span class="hljs-keyword">dimension</span> (<span class="hljs-number">1</span>:<span class="hljs-number">2</span>) :: order2 = (/ <span class="hljs-number">2</span>, <span class="hljs-number">1</span> /)<br>   <span class="hljs-keyword">real</span>, <span class="hljs-keyword">dimension</span> (<span class="hljs-number">1</span>:<span class="hljs-number">16</span>) :: pad1 = (/ -<span class="hljs-number">1</span>, -<span class="hljs-number">2</span>, -<span class="hljs-number">3</span>, -<span class="hljs-number">4</span>, -<span class="hljs-number">5</span>, -<span class="hljs-number">6</span>, -<span class="hljs-number">7</span>, -<span class="hljs-number">8</span>, &amp;<br>                                 &amp; -<span class="hljs-number">9</span>, -<span class="hljs-number">10</span>, -<span class="hljs-number">11</span>, -<span class="hljs-number">12</span>, -<span class="hljs-number">13</span>, -<span class="hljs-number">14</span>, -<span class="hljs-number">15</span>, -<span class="hljs-number">16</span> /)<br><br>   c = <span class="hljs-built_in">reshape</span>( b, (/ <span class="hljs-number">3</span>, <span class="hljs-number">3</span> /) )<br>   <span class="hljs-keyword">call</span> write_matrix(c)<br><br>   d = <span class="hljs-built_in">reshape</span>( b, (/ <span class="hljs-number">3</span>, <span class="hljs-number">3</span> /), order = order1)<br>   <span class="hljs-keyword">call</span> write_matrix(d)<br><br>   e = <span class="hljs-built_in">reshape</span>( b, (/ <span class="hljs-number">3</span>, <span class="hljs-number">3</span> /), order = order2)<br>   <span class="hljs-keyword">call</span> write_matrix(e)<br><br>   f = <span class="hljs-built_in">reshape</span>( b, (/ <span class="hljs-number">4</span>, <span class="hljs-number">4</span> /), <span class="hljs-keyword">pad</span> = pad1)<br>   <span class="hljs-keyword">call</span> write_matrix(f)<br><br>   g = <span class="hljs-built_in">reshape</span>( b, (/ <span class="hljs-number">4</span>, <span class="hljs-number">4</span> /), <span class="hljs-keyword">pad</span> = pad1, order = order1)<br>   <span class="hljs-keyword">call</span> write_matrix(g)<br><br>   h = <span class="hljs-built_in">reshape</span>( b, (/ <span class="hljs-number">4</span>, <span class="hljs-number">4</span> /), <span class="hljs-keyword">pad</span> = pad1, order = order2)<br>   <span class="hljs-keyword">call</span> write_matrix(h)<br><br><span class="hljs-keyword">end</span> <span class="hljs-function"><span class="hljs-keyword">program</span></span> arrayReshape<br><br><br><span class="hljs-function"><span class="hljs-keyword">subroutine</span></span> write_matrix(a)<br>   <span class="hljs-keyword">real</span>, <span class="hljs-keyword">dimension</span>(:,:) :: a<br>   <span class="hljs-built_in">write</span>(*,*)<br>   <br>   <span class="hljs-keyword">do</span> i = <span class="hljs-built_in">lbound</span>(a,<span class="hljs-number">1</span>), <span class="hljs-built_in">ubound</span>(a,<span class="hljs-number">1</span>)<br>      <span class="hljs-built_in">write</span>(*,*) (a(i,j), j = <span class="hljs-built_in">lbound</span>(a,<span class="hljs-number">2</span>), <span class="hljs-built_in">ubound</span>(a,<span class="hljs-number">2</span>))<br>   <span class="hljs-keyword">end</span> <span class="hljs-keyword">do</span><br><span class="hljs-keyword">end</span> <span class="hljs-function"><span class="hljs-keyword">subroutine</span></span> write_matrix<br></code></pre></td></tr></table></figure><p>​ 当上述代码被编译和执行时，它产生了以下结果：</p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs dns"><span class="hljs-number">21.0000000</span>  <span class="hljs-number">24.0000000</span>  <span class="hljs-number">27.0000000</span>    <br><span class="hljs-number">22.0000000</span>  <span class="hljs-number">25.0000000</span>  <span class="hljs-number">28.0000000</span>    <br><span class="hljs-number">23.0000000</span>  <span class="hljs-number">26.0000000</span>  <span class="hljs-number">29.0000000</span>    <br><br><span class="hljs-number">21.0000000</span>  <span class="hljs-number">24.0000000</span>  <span class="hljs-number">27.0000000</span>    <br><span class="hljs-number">22.0000000</span>  <span class="hljs-number">25.0000000</span>  <span class="hljs-number">28.0000000</span>    <br><span class="hljs-number">23.0000000</span>  <span class="hljs-number">26.0000000</span>  <span class="hljs-number">29.0000000</span>    <br><br><span class="hljs-number">21.0000000</span>  <span class="hljs-number">22.0000000</span>  <span class="hljs-number">23.0000000</span>    <br><span class="hljs-number">24.0000000</span>  <span class="hljs-number">25.0000000</span>  <span class="hljs-number">26.0000000</span>    <br><span class="hljs-number">27.0000000</span>  <span class="hljs-number">28.0000000</span>  <span class="hljs-number">29.0000000</span>    <br><br><span class="hljs-number">21.0000000</span>  <span class="hljs-number">25.0000000</span>  <span class="hljs-number">29.0000000</span>   -<span class="hljs-number">4.00000000</span>    <br><span class="hljs-number">22.0000000</span>  <span class="hljs-number">26.0000000</span>  -<span class="hljs-number">1.00000000</span>  -<span class="hljs-number">5.00000000</span>    <br><span class="hljs-number">23.0000000</span>  <span class="hljs-number">27.0000000</span>  -<span class="hljs-number">2.00000000</span>  -<span class="hljs-number">6.00000000</span>    <br><span class="hljs-number">24.0000000</span>  <span class="hljs-number">28.0000000</span>  -<span class="hljs-number">3.00000000</span>  -<span class="hljs-number">7.00000000</span>    <br><br><span class="hljs-number">21.0000000</span>  <span class="hljs-number">25.0000000</span>  <span class="hljs-number">29.0000000</span>   -<span class="hljs-number">4.00000000</span>    <br><span class="hljs-number">22.0000000</span>  <span class="hljs-number">26.0000000</span>  -<span class="hljs-number">1.00000000</span>  -<span class="hljs-number">5.00000000</span>    <br><span class="hljs-number">23.0000000</span>  <span class="hljs-number">27.0000000</span>  -<span class="hljs-number">2.00000000</span>  -<span class="hljs-number">6.00000000</span>    <br><span class="hljs-number">24.0000000</span>  <span class="hljs-number">28.0000000</span>  -<span class="hljs-number">3.00000000</span>  -<span class="hljs-number">7.00000000</span>    <br><br><span class="hljs-number">21.0000000</span>  <span class="hljs-number">22.0000000</span>  <span class="hljs-number">23.0000000</span>   <span class="hljs-number">24.0000000</span>    <br><span class="hljs-number">25.0000000</span>  <span class="hljs-number">26.0000000</span>  <span class="hljs-number">27.0000000</span>   <span class="hljs-number">28.0000000</span>    <br><span class="hljs-number">29.0000000</span>  -<span class="hljs-number">1.00000000</span> -<span class="hljs-number">2.00000000</span>  -<span class="hljs-number">3.00000000</span>    <br>-<span class="hljs-number">4.00000000</span> -<span class="hljs-number">5.00000000</span> -<span class="hljs-number">6.00000000</span>  -<span class="hljs-number">7.00000000</span>  <br></code></pre></td></tr></table></figure><h2 id="操作函数">操作函数</h2><p>处理函数平移功能。移位函数返回一个数组不变的形状，但移动元素。</p><table><thead><tr class="header"><th>函数</th><th>描述</th></tr></thead><tbody><tr class="odd"><td><strong>cshift</strong>(array, shift, dim)</td><td>它执行循环移位由移位置的左边，如果移位是正和到右侧，如果它是负的。如果阵列是一个矢量移位正在做以自然的方式中，如果它是一个较高级的阵列则移是沿着维数dim的所有部分。若dim缺少它被认为是1，在其它情况下它必须是1和n(其中n等于阵列的等级)之间的标量整数。该参数换档是一个标量整数或秩n-1个整数的数组和形状相同的阵列中，除沿维数dim(在较低级的，因为它被移除)。不同的部分，因此可以转移在各个方向上，并与各种数目的位置。</td></tr><tr class="even"><td><strong>eoshift</strong>(array, shift, boundary, dim)</td><td>这是端关闭的转变。它执行向左移动，如果移位是正和到右侧，如果它是负的。相反的元素移出新元素均取自边界。如果阵列是一个矢量移位正在做以自然的方式中，如果它是一个较高级的阵列，在所有各节中的移位是以及该维度暗淡。若dim丢失，它被认为是1，但在其它情况下，它为1和n(其中n等于阵列的秩)之间有一个标量的整数值。该参数换档是一个标量整数，如果阵列具有秩1，在其他情况下，它可以是一个标量整数或秩n-1和形状相同的阵列排列的与除沿维数dim的整数数组(其被取出因为较低级的)。</td></tr><tr class="odd"><td><strong>transpose </strong>(matrix)</td><td>其转置矩阵，这是秩2的阵列它取代了的行和列矩阵。</td></tr></tbody></table><p>​ <strong>示例</strong></p><p>​ 下面的例子演示了这一概念：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">program</span> arrayShift<br><span class="hljs-attribute">implicit</span> none<br><br>   <span class="hljs-attribute">real</span>, dimension(<span class="hljs-number">1</span>:<span class="hljs-number">6</span>) :: a = (/ <span class="hljs-number">21</span>.<span class="hljs-number">0</span>, <span class="hljs-number">22</span>.<span class="hljs-number">0</span>, <span class="hljs-number">23</span>.<span class="hljs-number">0</span>, <span class="hljs-number">24</span>.<span class="hljs-number">0</span>, <span class="hljs-number">25</span>.<span class="hljs-number">0</span>, <span class="hljs-number">26</span>.<span class="hljs-number">0</span> /)<br>   <span class="hljs-attribute">real</span>, dimension(<span class="hljs-number">1</span>:<span class="hljs-number">6</span>) :: x, y<br>   <span class="hljs-attribute">write</span>(*,<span class="hljs-number">10</span>) a<br>   <br>   <span class="hljs-attribute">x</span> = cshift ( a, shift = <span class="hljs-number">2</span>)<br>   <span class="hljs-attribute">write</span>(*,<span class="hljs-number">10</span>) x<br>   <br>   <span class="hljs-attribute">y</span> = cshift (a, shift = -<span class="hljs-number">2</span>)<br>   <span class="hljs-attribute">write</span>(*,<span class="hljs-number">10</span>) y<br>   <br>   <span class="hljs-attribute">x</span> = eoshift ( a, shift = <span class="hljs-number">2</span>)<br>   <span class="hljs-attribute">write</span>(*,<span class="hljs-number">10</span>) x<br>   <br>   <span class="hljs-attribute">y</span> = eoshift ( a, shift = -<span class="hljs-number">2</span>)<br>   <span class="hljs-attribute">write</span>(*,<span class="hljs-number">10</span>) y<br>   <br>   <span class="hljs-attribute">10</span> format(<span class="hljs-number">1</span>x,<span class="hljs-number">6</span>f6.<span class="hljs-number">1</span>)<br><br><span class="hljs-attribute">end</span> program arrayShift<br></code></pre></td></tr></table></figure><p>​ 当上述代码被编译和执行时，它产生了以下结果：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">21</span>.<span class="hljs-number">0</span>  <span class="hljs-number">22</span>.<span class="hljs-number">0</span>  <span class="hljs-number">23</span>.<span class="hljs-number">0</span>  <span class="hljs-number">24</span>.<span class="hljs-number">0</span>  <span class="hljs-number">25</span>.<span class="hljs-number">0</span>  <span class="hljs-number">26</span>.<span class="hljs-number">0</span><br><span class="hljs-attribute">23</span>.<span class="hljs-number">0</span>  <span class="hljs-number">24</span>.<span class="hljs-number">0</span>  <span class="hljs-number">25</span>.<span class="hljs-number">0</span>  <span class="hljs-number">26</span>.<span class="hljs-number">0</span>  <span class="hljs-number">21</span>.<span class="hljs-number">0</span>  <span class="hljs-number">22</span>.<span class="hljs-number">0</span><br><span class="hljs-attribute">25</span>.<span class="hljs-number">0</span>  <span class="hljs-number">26</span>.<span class="hljs-number">0</span>  <span class="hljs-number">21</span>.<span class="hljs-number">0</span>  <span class="hljs-number">22</span>.<span class="hljs-number">0</span>  <span class="hljs-number">23</span>.<span class="hljs-number">0</span>  <span class="hljs-number">24</span>.<span class="hljs-number">0</span><br><span class="hljs-attribute">23</span>.<span class="hljs-number">0</span>  <span class="hljs-number">24</span>.<span class="hljs-number">0</span>  <span class="hljs-number">25</span>.<span class="hljs-number">0</span>  <span class="hljs-number">26</span>.<span class="hljs-number">0</span>   <span class="hljs-number">0</span>.<span class="hljs-number">0</span>   <span class="hljs-number">0</span>.<span class="hljs-number">0</span><br><span class="hljs-attribute">0</span>.<span class="hljs-number">0</span>    <span class="hljs-number">0</span>.<span class="hljs-number">0</span>  <span class="hljs-number">21</span>.<span class="hljs-number">0</span>  <span class="hljs-number">22</span>.<span class="hljs-number">0</span>  <span class="hljs-number">23</span>.<span class="hljs-number">0</span>  <span class="hljs-number">24</span>.<span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p>​ <strong>示例</strong></p><p>​ 下面的例子演示了转置矩阵：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">program matrixTranspose<br>implicit none<br><br>   <span class="hljs-keyword">interface</span><br>      <span class="hljs-symbol">subroutine</span> <span class="hljs-symbol">write_matrix</span>(<span class="hljs-symbol">a</span>)<br>         <span class="hljs-symbol">integer</span>, <span class="hljs-symbol">dimension</span>(:,:) :: <span class="hljs-symbol">a</span><br>      <span class="hljs-symbol">end</span> <span class="hljs-symbol">subroutine</span> <span class="hljs-symbol">write_matrix</span><br>   <span class="hljs-symbol">end</span> <span class="hljs-symbol">interface</span><br><br>   <span class="hljs-symbol">integer</span>, <span class="hljs-symbol">dimension</span>(<span class="hljs-symbol">3</span>,<span class="hljs-symbol">3</span>) :: <span class="hljs-symbol">a</span>, <span class="hljs-symbol">b</span><br>   <span class="hljs-symbol">integer</span> :: <span class="hljs-symbol">i</span>, <span class="hljs-symbol">j</span><br>    <br>   <span class="hljs-symbol">do</span> <span class="hljs-symbol">i</span> = <span class="hljs-symbol">1</span>, <span class="hljs-symbol">3</span><br>      <span class="hljs-symbol">do</span> <span class="hljs-symbol">j</span> = <span class="hljs-symbol">1</span>, <span class="hljs-symbol">3</span><br>         <span class="hljs-symbol">a</span>(<span class="hljs-symbol">i</span>, <span class="hljs-symbol">j</span>) = <span class="hljs-symbol">i</span><br>      <span class="hljs-symbol">end</span> <span class="hljs-symbol">do</span><br>   <span class="hljs-symbol">end</span> <span class="hljs-symbol">do</span><br>   <br>   <span class="hljs-symbol">print</span> *, &#x27;<span class="hljs-symbol">Matrix</span> <span class="hljs-symbol">Transpose</span>: <span class="hljs-symbol">A</span> <span class="hljs-symbol">Matrix</span>&#x27;<br>   <br>   <span class="hljs-symbol">call</span> <span class="hljs-symbol">write_matrix</span>(<span class="hljs-symbol">a</span>)<br>   <span class="hljs-symbol">b</span> = <span class="hljs-symbol">transpose</span>(<span class="hljs-symbol">a</span>)<br>   <span class="hljs-symbol">print</span> *, &#x27;<span class="hljs-symbol">Transposed</span> <span class="hljs-symbol">Matrix</span>:&#x27;<br>   <br>   <span class="hljs-symbol">call</span> <span class="hljs-symbol">write_matrix</span>(<span class="hljs-symbol">b</span>)<br><span class="hljs-symbol">end</span> <span class="hljs-symbol">program</span> <span class="hljs-symbol">matrixTranspose</span><br><br><br><span class="hljs-symbol">subroutine</span> <span class="hljs-symbol">write_matrix</span>(<span class="hljs-symbol">a</span>)<br><br>   <span class="hljs-symbol">integer</span>, <span class="hljs-symbol">dimension</span>(:,:) :: <span class="hljs-symbol">a</span><br>   <span class="hljs-symbol">write</span>(*,*)<br>   <br>   <span class="hljs-symbol">do</span> <span class="hljs-symbol">i</span> = <span class="hljs-symbol">lbound</span>(<span class="hljs-symbol">a</span>,<span class="hljs-symbol">1</span>), <span class="hljs-symbol">ubound</span>(<span class="hljs-symbol">a</span>,<span class="hljs-symbol">1</span>)<br>      <span class="hljs-symbol">write</span>(*,*) (<span class="hljs-symbol">a</span>(<span class="hljs-symbol">i</span>,<span class="hljs-symbol">j</span>), <span class="hljs-symbol">j</span> = <span class="hljs-symbol">lbound</span>(<span class="hljs-symbol">a</span>,<span class="hljs-symbol">2</span>), <span class="hljs-symbol">ubound</span>(<span class="hljs-symbol">a</span>,<span class="hljs-symbol">2</span>))<br>   <span class="hljs-symbol">end</span> <span class="hljs-symbol">do</span><br>   <br><span class="hljs-symbol">end</span> <span class="hljs-symbol">subroutine</span> <span class="hljs-symbol">write_matrix</span><br></code></pre></td></tr></table></figure><p>​ 当上述代码被编译和执行时，它产生了以下结果：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">Matrix</span> Transpose: A Matrix<br><br><span class="hljs-attribute">1</span>  <span class="hljs-number">1</span>  <span class="hljs-number">1</span><br><span class="hljs-attribute">2</span>  <span class="hljs-number">2</span>  <span class="hljs-number">2</span><br><span class="hljs-attribute">3</span>  <span class="hljs-number">3</span>  <span class="hljs-number">3</span><br><span class="hljs-attribute">Transposed</span> Matrix:<br><br><span class="hljs-attribute">1</span>  <span class="hljs-number">2</span>  <span class="hljs-number">3</span><br><span class="hljs-attribute">1</span>  <span class="hljs-number">2</span>  <span class="hljs-number">3</span><br><span class="hljs-attribute">1</span>  <span class="hljs-number">2</span>  <span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><h2 id="位置函数">位置函数</h2><p>下表描述了位置函数：</p><table><thead><tr class="header"><th>函数</th><th>描述</th></tr></thead><tbody><tr class="odd"><td><strong>maxloc</strong>(array, mask)</td><td>它返回数组中的最大元素的位置上，如果掩码仅包含那些其中满足条件的掩码，则返回位置，其结果是一个整数向量。</td></tr><tr class="even"><td><strong>minloc</strong>(array, mask)</td><td>它返回数组的数组中的最小元素的位置，如果掩码仅包含那些其中满足条件的掩码，则返回位置，其结果是一个整数向量。</td></tr></tbody></table><p>​ <strong>示例</strong></p><p>​ 下面的例子演示了这一概念：</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs fortran"><span class="hljs-function"><span class="hljs-keyword">program</span></span> arrayLocation<br><span class="hljs-keyword">implicit</span> <span class="hljs-keyword">none</span><br><br>   <span class="hljs-keyword">real</span>, <span class="hljs-keyword">dimension</span>(<span class="hljs-number">1</span>:<span class="hljs-number">6</span>) :: a = (/ <span class="hljs-number">21.0</span>, <span class="hljs-number">12.0</span>,<span class="hljs-number">33.0</span>, <span class="hljs-number">24.0</span>, <span class="hljs-number">15.0</span>, <span class="hljs-number">16.0</span> /)<br>   <span class="hljs-built_in">Print</span> *, <span class="hljs-built_in">maxloc</span>(a)<br>   <span class="hljs-built_in">Print</span> *, <span class="hljs-built_in">minloc</span>(a)<br>   <br><span class="hljs-keyword">end</span> <span class="hljs-function"><span class="hljs-keyword">program</span></span> arrayLocation   <br></code></pre></td></tr></table></figure><p>​ 当上述代码被编译和执行时，它产生了以下结果：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs">3<br>2<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Fortran</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Fortran-子程序</title>
    <link href="/2022/05/23/Fortran-%E5%AD%90%E7%A8%8B%E5%BA%8F/"/>
    <url>/2022/05/23/Fortran-%E5%AD%90%E7%A8%8B%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<p>Fortran 语言中的子程序事实上和其他编程语言的函数有点类似（后面会提到Fortran本身也支持函数）：<strong>把需要重复使用的某些代码都集中成一个子程序，调用时可以给子程序初始化一些变量值从而获得不同的结果</strong>。比如说数值微分或者微分方程组的解法一类的数值计算代码就可以写成子程序的形式。</p><h2 id="定义和调用">定义和调用</h2><p>子程序的一般结构如下所示：</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs Fortran"><span class="hljs-comment">!!! 不带初始化变量的子程序</span><br><span class="hljs-function"><span class="hljs-keyword">subroutine</span></span> subr1<br>    <span class="hljs-keyword">implicit</span> <span class="hljs-keyword">none</span><br>    <span class="hljs-keyword">real</span> a, b<br>    <span class="hljs-keyword">integer</span> i<br>    ......<br>    ......<br><span class="hljs-keyword">end</span> <span class="hljs-function"><span class="hljs-keyword">subroutine</span></span> subr1<br></code></pre></td></tr></table></figure><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs fortran"><span class="hljs-comment">!!! 带初始化变量的子程序</span><br><span class="hljs-function"><span class="hljs-keyword">subroutine</span></span> subr2(x, m, y, n)<br>    <span class="hljs-keyword">implicit</span> <span class="hljs-keyword">none</span><br>    <span class="hljs-keyword">real</span> x, y, a, b, z(<span class="hljs-number">10</span>)<br>    <span class="hljs-keyword">integer</span> m, n, i, k<br>    ......<br>    ......<br><span class="hljs-keyword">end</span> <span class="hljs-function"><span class="hljs-keyword">subroutine</span></span> subr2<br></code></pre></td></tr></table></figure><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs fortran"><span class="hljs-comment">!!! 调用子程序</span><br><span class="hljs-keyword">real</span> z<br><span class="hljs-keyword">integer</span> m<br><span class="hljs-keyword">call</span> subr1<br>m = <span class="hljs-number">21</span><br><span class="hljs-keyword">call</span> subr2(<span class="hljs-number">10.0</span>, <span class="hljs-number">100</span>, z, m*<span class="hljs-number">5</span>+<span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure><p>子程序是以 <code>subroutine</code> 开头、以<code>end subroutine</code>结尾，其中<strong>第一行与一般主程序一样需要添加一行<code>implicit none</code> 的声明</strong>。</p><h5 id="小提示">小提示</h5><p><strong>值得注意</strong>的是，子程序可以在主程序中被任意调用若干次，但同时也是依赖主程序存在的，即<strong>只有子程序的代码无法被执行</strong>。</p><p>从上面的例子可以看出，无论是初始化还是没初始化变量，子程序都可以在主程序中被调用执行。只不过带初始化变量的子程序应该在被调用时给定相应的变量，否则无法正常被调用。</p><p>如下所示是一个完整包含主程序和子程序的代码示例。主程序是以<code>program</code> 开头、以 <code>end program</code>结尾的代码片段。子程序代码不被包含在主程序代码片段中，但与主程序在同一文件中。</p><h5 id="小提示-1">小提示</h5><p><strong>子程序可以位于主程序代码片段之前或之后，不会影响在主程序中的正常调用</strong>。</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs fortran"><span class="hljs-function"><span class="hljs-keyword">program</span></span> stest1<br>    <span class="hljs-keyword">implicit</span> <span class="hljs-keyword">none</span><br>    <span class="hljs-keyword">real</span> x, y<br>    x = <span class="hljs-number">5.0</span><br>    y = <span class="hljs-number">100.0</span><br>    <span class="hljs-keyword">call</span> subr(x, y, <span class="hljs-number">10</span>)<br>    <span class="hljs-built_in">print</span> *, x, y<br><span class="hljs-keyword">end</span> <span class="hljs-function"><span class="hljs-keyword">program</span></span> stest1<br><br><span class="hljs-function"><span class="hljs-keyword">subroutine</span></span> subr(x, y, n)<br>    <span class="hljs-keyword">implicit</span> <span class="hljs-keyword">none</span><br>    <span class="hljs-keyword">real</span> x, y<br>    <span class="hljs-keyword">integer</span> n<br>    x = n<br>    y = y*x<br><span class="hljs-keyword">end</span> <span class="hljs-function"><span class="hljs-keyword">subroutine</span></span> subr<br></code></pre></td></tr></table></figure><p>子程序的调用和主程序的执行顺序是：<strong>主程序 → 子程序 →主程序</strong>。</p><p>由于<strong>子程序被调用时实际上不会与其他正在被执行的子程序相互干扰</strong>，所以可以在一个主程序中重复调用同一子程序。如果在子程序中需要根据某个条件判断中断退出，可以如下所示利用<code>if</code> 语句和 <code>return</code> 关键字来返回主程序。</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs fortran"><span class="hljs-function"><span class="hljs-keyword">subroutine</span></span> subr(x, y, m, n)<br>    <span class="hljs-keyword">implicit</span> <span class="hljs-keyword">none</span><br>    <span class="hljs-keyword">real</span> x, y<br>    <span class="hljs-keyword">integer</span> m, n<br>    ......<br>    <span class="hljs-keyword">if</span> (m &lt; n) <span class="hljs-keyword">return</span><br>    ......<br><span class="hljs-keyword">end</span> <span class="hljs-function"><span class="hljs-keyword">subroutine</span></span> subr<br></code></pre></td></tr></table></figure><h2 id="局部变量">局部变量</h2><h3 id="子程序变量的局部性">子程序变量的局部性</h3><p>子程序中定义的<strong>局部变量和参数独立于主程序</strong>。也就是说，当我们在主程序和子程序中同时定义<strong>相同名称的变量</strong>时，其实它们之间也是不同的。只有当我们在调用子程序时使用主程序中同名的变量对参数进行赋值时，主程序和子程序的同名变量才会具有相同的值。</p><p>如下面的示例 1 所示，编译执行的结果并非是期待的 10.0 和 30.0。</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs fortran"><span class="hljs-comment">!!! 示例 1</span><br><span class="hljs-function"><span class="hljs-keyword">program</span></span> stest1<br>    <span class="hljs-keyword">implicit</span> <span class="hljs-keyword">none</span><br>    <span class="hljs-keyword">real</span> x, y<br>    x = <span class="hljs-number">10.0</span><br>    y = <span class="hljs-number">30.0</span><br>    <span class="hljs-keyword">call</span> subr1<br><span class="hljs-keyword">end</span> <span class="hljs-function"><span class="hljs-keyword">program</span></span> stest1<br><br><span class="hljs-function"><span class="hljs-keyword">subroutine</span></span> subr1<br>    <span class="hljs-keyword">implicit</span> <span class="hljs-keyword">none</span><br>    <span class="hljs-keyword">real</span> x, y<br>    <span class="hljs-built_in">print</span> *, x, y<br><span class="hljs-keyword">end</span> <span class="hljs-function"><span class="hljs-keyword">subroutine</span></span> subr1<br><br><span class="hljs-comment">!!! 执行结果</span><br>&gt;&gt;&gt;    <span class="hljs-number">2.80259693E-45</span>   <span class="hljs-number">0.00000000</span><br></code></pre></td></tr></table></figure><p>当我们修改为带初始化变量的子程序时，如示例 2所示，编译执行的结果和期待的一样。</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs fortran"><span class="hljs-comment">!!! 示例 2</span><br><span class="hljs-function"><span class="hljs-keyword">program</span></span> stest2<br>    <span class="hljs-keyword">implicit</span> <span class="hljs-keyword">none</span><br>    <span class="hljs-keyword">real</span> x, y<br>    x = <span class="hljs-number">10.0</span><br>    y = <span class="hljs-number">30.0</span><br>    <span class="hljs-keyword">call</span> subr2(x, y)<br><span class="hljs-keyword">end</span> <span class="hljs-function"><span class="hljs-keyword">program</span></span> stest2<br><br><span class="hljs-function"><span class="hljs-keyword">subroutine</span></span> subr2(x, y)<br>    <span class="hljs-keyword">implicit</span> <span class="hljs-keyword">none</span><br>    <span class="hljs-keyword">real</span> x, y<br>    <span class="hljs-built_in">print</span> *, x, y<br><span class="hljs-keyword">end</span> <span class="hljs-function"><span class="hljs-keyword">subroutine</span></span> subr2<br><br><span class="hljs-comment">!!! 执行结果</span><br>&gt;&gt;&gt;    <span class="hljs-number">10.0000000</span>       <span class="hljs-number">30.0000000</span><br></code></pre></td></tr></table></figure><p>这两个例子的对比再一次证明了子程序中定义的变量所具有的局部性，<strong>必须通过参数传递的方式才能与主程序同名变量保持一样的初始化值</strong>。同样地，这种局部性也会让主程序的变量值不会因为子程序的同名变量值发生改变而改变。</p><p>有人可能会有疑问，如果子程序中的参数使用的变量名与主程序的变量名不一致，调用能不能成功呢？当然是能够成功的。如下所示，将示例2 中子程序原来的参数 x 和 y 换成 a 和 b，依然可以输出正确结果。</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs fortran"><span class="hljs-function"><span class="hljs-keyword">subroutine</span></span> subr2(a, b)<br>    <span class="hljs-keyword">implicit</span> <span class="hljs-keyword">none</span><br>    <span class="hljs-keyword">real</span> a, b<br>    <span class="hljs-built_in">print</span> *, a, b<br><span class="hljs-keyword">end</span> <span class="hljs-function"><span class="hljs-keyword">subroutine</span></span> subr2<br><br><span class="hljs-comment">!!! 执行结果</span><br>&gt;&gt;&gt;    <span class="hljs-number">10.0000000</span>       <span class="hljs-number">30.0000000</span><br></code></pre></td></tr></table></figure><h3 id="类型声明的一致性">类型声明的一致性</h3><p>主程序中调用带初始化变量的子程序时，需要注意使用相同类型的变量来给子程序初始化参数，否则就会报错。如示例3 中所示，子程序中所定义的参数 x 和 y 为实数、参数 m 和 n为整数。主程序中调用时传递的变量值也是对应的实数和整数，具体如下表所示。</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs fortran"><span class="hljs-comment">!!! 示例 3</span><br><span class="hljs-function"><span class="hljs-keyword">program</span></span> stest3<br>    <span class="hljs-keyword">implicit</span> <span class="hljs-keyword">none</span><br>    <span class="hljs-keyword">real</span> z<br>    <span class="hljs-keyword">integer</span> n<br>    z = <span class="hljs-number">200.0</span><br>    n = <span class="hljs-number">21</span><br>    <span class="hljs-keyword">call</span> subr3(<span class="hljs-number">10.0</span>, z**<span class="hljs-number">2</span>, <span class="hljs-number">100</span>, n*<span class="hljs-number">5</span>+<span class="hljs-number">1</span>)<br><span class="hljs-keyword">end</span> <span class="hljs-function"><span class="hljs-keyword">program</span></span> stest3<br><br><span class="hljs-function"><span class="hljs-keyword">subroutine</span></span> subr3(x, y, m, n)<br>    <span class="hljs-keyword">implicit</span> <span class="hljs-keyword">none</span><br>    <span class="hljs-keyword">real</span> x, y<br>    <span class="hljs-keyword">integer</span> m, n<br>    <span class="hljs-built_in">print</span> *, x, y, m, n<br><span class="hljs-keyword">end</span> <span class="hljs-function"><span class="hljs-keyword">subroutine</span></span> subr3<br></code></pre></td></tr></table></figure><table><thead><tr class="header"><th>调用语句</th><th>子程序语句</th><th>数值类型</th></tr></thead><tbody><tr class="odd"><td>10.0</td><td>x</td><td>实数</td></tr><tr class="even"><td>z**2</td><td>y</td><td>实数</td></tr><tr class="odd"><td>100</td><td>m</td><td>整数</td></tr><tr class="even"><td>n*5+1</td><td>n</td><td>整数</td></tr></tbody></table><h3 id="子程序的返回值">子程序的返回值</h3><p>刚才提到的子程序中定义的变量是局部变量，不会干扰主程序中的其他变量，但是如果我们想要把子程序计算的结果返回给主程序呢？在其他的编程语言中，可能大部分是使用<code>return</code>加变量名的方式来将子程序中的变量传递回主程序。<strong>在 Fortran中，子程序会将参数变量全部返回给主程序，可以认为是地址引用</strong>。如果主程序调用子程序时<strong>用一个算式传递变量给子程序，那么可以认为是值引用</strong>。</p><p>如下面的示例 4 所示，主程序中调用子程序时最后的变量 p就是要保存返回值的变量。从执行结果也可以看出，变量 x 和 y并没有受到子程序的影响，只有变量 p 带着子程序的变量 z的值正确返回了。因为这里 x+y 作为子程序中的 x 存在，而 x+y这个变量实际上在主程序中不存在，所以是值引用。</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs fortran"><span class="hljs-comment">!!! 示例 4</span><br><span class="hljs-function"><span class="hljs-keyword">program</span></span> stest4<br>    <span class="hljs-keyword">implicit</span> <span class="hljs-keyword">none</span><br>    <span class="hljs-keyword">real</span> x, y, p<br>    x = <span class="hljs-number">10.0</span><br>    y = <span class="hljs-number">30.0</span><br>    <span class="hljs-keyword">call</span> subr4(x+y, <span class="hljs-number">20.0</span>, p)<br>    <span class="hljs-built_in">print</span> *, x, y, p<br><span class="hljs-keyword">end</span> <span class="hljs-function"><span class="hljs-keyword">program</span></span> stest4<br><br><span class="hljs-function"><span class="hljs-keyword">subroutine</span></span> subr4(x, y, z)<br>    <span class="hljs-keyword">implicit</span> <span class="hljs-keyword">none</span><br>    <span class="hljs-keyword">real</span> x, y, z<br>    z = x*y<br><span class="hljs-keyword">end</span> <span class="hljs-function"><span class="hljs-keyword">subroutine</span></span> subr4<br><br><span class="hljs-comment">!!! 执行结果</span><br>&gt;&gt;&gt;   <span class="hljs-number">10.0000000</span>       <span class="hljs-number">30.0000000</span>       <span class="hljs-number">800.000000</span><br></code></pre></td></tr></table></figure><h5 id="小提示-2">小提示</h5><p><strong>值引用</strong>和<strong>地址引用</strong>的定义：值引用是指引用值而不引用原来的变量或者存储器中对应的地址，地址引用是指引用原来的变量或者存储器中对应的地址。<strong>值引用</strong>和<strong>地址引用</strong>的区别：前者不会因子程序的操作而发生改变，后者可能会因子程序的操作而发生改变。如果我们仅仅是为了传递某个值给子程序作为输入，可以采用值引用，从而避免对于主程序的干扰。如果我们希望子程序的操作改变变量的值，可以采用地址引用。</p><h2 id="数组变量">数组变量</h2><h3 id="数组作为子程序参数">数组作为子程序参数</h3><p>如果主程序想要用数组变量或数组变量的某个位置的值为调用的子程序赋值，Fortran也是完全支持的。如下所示，第一行是用数组变量初始化子程序参数，第二行是用数组变量a 中编号为 1 的元素初始化子程序参数。</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs fortran"><span class="hljs-keyword">call</span> sub(a)<br><span class="hljs-keyword">call</span> sub(a(<span class="hljs-number">1</span>))<br></code></pre></td></tr></table></figure><p>上面第一行调用方式对应的主程序和子程序可以类似于下面的示例5。主程序和子程序中分别将 a 和 x 都定义为长度为 10的一维数组，并在子程序中使用循环的方式依次为数组 x的每个元素赋值。最后，赋好值的数组 x也会返回给主程序。从执行结果看到，输出结果为期待的 a(3) 值。</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs fortran"><span class="hljs-comment">!!! 示例 5</span><br><span class="hljs-function"><span class="hljs-keyword">program</span></span> stest5<br>    <span class="hljs-keyword">implicit</span> <span class="hljs-keyword">none</span><br>    <span class="hljs-keyword">real</span> a(<span class="hljs-number">10</span>)<br>    <span class="hljs-keyword">call</span> sub(a)<br>    <span class="hljs-built_in">print</span> *, a(<span class="hljs-number">3</span>)<br><span class="hljs-keyword">end</span> <span class="hljs-function"><span class="hljs-keyword">program</span></span> stest5<br><br><span class="hljs-function"><span class="hljs-keyword">subroutine</span></span> sub(x)<br>    <span class="hljs-keyword">implicit</span> <span class="hljs-keyword">none</span><br>    <span class="hljs-keyword">real</span> x(<span class="hljs-number">10</span>)<br>    <span class="hljs-keyword">integer</span> i<br>    <span class="hljs-keyword">do</span> i = <span class="hljs-number">1</span>, <span class="hljs-number">10</span><br>        x(i) = i<br>    <span class="hljs-keyword">enddo</span><br><span class="hljs-keyword">end</span> <span class="hljs-function"><span class="hljs-keyword">subroutine</span></span> sub<br><br><span class="hljs-comment">!!! 执行结果</span><br>&gt;&gt;&gt;   <span class="hljs-number">3.00000000</span><br></code></pre></td></tr></table></figure><p>如果我们在调用时写成了<code>call sub(a(1))</code>，那会怎么样呢？实际上还是会得到一样的结果。</p><h3 id="数组变量的顺序对应">数组变量的顺序对应</h3><p>如果将 <code>a(1)</code> 修改为 <code>a(3)</code> 并保持数组 a的长度为 10，即数组 a 和数组 x不从第一个元素开始对应，那么源代码将无法被编译，如示例 5的变种一所示。</p><p>要想在这种情况下还能正常编译，我们就必须扩充数组 a 的长度至少为12。这样一来，子程序中要赋值的数都能正确存入数组 x并返回给主程序的数组变量 a，如示例 5 的变种二所示。</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs fortran"><span class="hljs-comment">!!! 示例 5 的变种一</span><br><span class="hljs-function"><span class="hljs-keyword">program</span></span> stest5<br>    <span class="hljs-keyword">implicit</span> <span class="hljs-keyword">none</span><br>    <span class="hljs-keyword">real</span> a(<span class="hljs-number">10</span>)<br>    <span class="hljs-keyword">call</span> sub(a(<span class="hljs-number">3</span>))<br>    <span class="hljs-built_in">print</span> *, a(<span class="hljs-number">3</span>)<br><span class="hljs-keyword">end</span> <span class="hljs-function"><span class="hljs-keyword">program</span></span> stest5<br><br><span class="hljs-function"><span class="hljs-keyword">subroutine</span></span> sub(x)<br>    <span class="hljs-keyword">implicit</span> <span class="hljs-keyword">none</span><br>    <span class="hljs-keyword">real</span> x(<span class="hljs-number">10</span>)<br>    <span class="hljs-keyword">integer</span> i<br>    <span class="hljs-keyword">do</span> i = <span class="hljs-number">1</span>, <span class="hljs-number">10</span><br>        x(i) = i<br>    <span class="hljs-keyword">enddo</span><br><span class="hljs-keyword">end</span> <span class="hljs-function"><span class="hljs-keyword">subroutine</span></span> sub <br><br><span class="hljs-comment">!!! 执行结果</span><br>&gt;&gt;&gt; Error: Actual argument <span class="hljs-keyword">contains</span> too few elements for dummy argument <span class="hljs-string">&#x27;x&#x27;</span> (<span class="hljs-number">8</span>/<span class="hljs-number">10</span>) at (<span class="hljs-number">1</span>)<br><br><span class="hljs-comment">!!! 示例 5 的变种二</span><br><span class="hljs-function"><span class="hljs-keyword">program</span></span> stest5<br>    <span class="hljs-keyword">implicit</span> <span class="hljs-keyword">none</span><br>    <span class="hljs-keyword">real</span> a(<span class="hljs-number">12</span>)<br>    <span class="hljs-keyword">call</span> sub(a(<span class="hljs-number">3</span>))<br>    <span class="hljs-built_in">print</span> *, a(<span class="hljs-number">3</span>)<br><span class="hljs-keyword">end</span> <span class="hljs-function"><span class="hljs-keyword">program</span></span> stest5<br><br><span class="hljs-function"><span class="hljs-keyword">subroutine</span></span> sub(x)<br>    <span class="hljs-keyword">implicit</span> <span class="hljs-keyword">none</span><br>    <span class="hljs-keyword">real</span> x(<span class="hljs-number">10</span>)<br>    <span class="hljs-keyword">integer</span> i<br>    <span class="hljs-keyword">do</span> i = <span class="hljs-number">1</span>, <span class="hljs-number">10</span><br>        x(i) = i<br>    <span class="hljs-keyword">enddo</span><br><span class="hljs-keyword">end</span> <span class="hljs-function"><span class="hljs-keyword">subroutine</span></span> sub <br><br><span class="hljs-comment">!!! 执行结果</span><br>&gt;&gt;&gt;   <span class="hljs-number">1.00000000</span><br></code></pre></td></tr></table></figure><p>其实，<strong>在子程序中也可以不定义数组的长度，将长度设置为<code>*</code></strong>。</p><p>如下示例 6 所示，子程序的功能是将数组 a 中的前 n 个元素复制给数组b。</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs fortran"><span class="hljs-comment">!!! 示例 6</span><br><span class="hljs-function"><span class="hljs-keyword">subroutine</span></span> copy(a, b, n)<br>    <span class="hljs-keyword">implicit</span> <span class="hljs-keyword">none</span><br>    <span class="hljs-keyword">real</span> a(*), b(*)<br>    <span class="hljs-keyword">integer</span> n, i<br>    <span class="hljs-keyword">do</span> i = i, n<br>        b(i) = a(i)<br>    <span class="hljs-keyword">enddo</span><br><span class="hljs-keyword">end</span> <span class="hljs-function"><span class="hljs-keyword">subroutine</span></span> copy<br></code></pre></td></tr></table></figure><h3 id="二维数组变量">二维数组变量</h3><p>当然，除了一维数组，我们也可能会想在<strong>主程序中传递二维数组给子程序，但是<code>a(*, *)</code>的写法在 Fortran中是不支持的</strong>。因此，我们需要把二维数组的维度也传递给子程序。</p><p>如下示例 7 所示，数组 a 和 b 为二维数组，m 和 n是它们的维度。子程序中使用数组变量名和给定的维度定义出二维数组。示例 7的主程序定义了四个二维数组及它们的维度大小，调用子程序时不仅传递了数组本身，也传递了维度大小。而子程序采用了两个for 循环叠加的方式来交替给二维数组中的每一行每一列的元素赋值。</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs fortran"><span class="hljs-comment">!!! 示例 7</span><br><span class="hljs-function"><span class="hljs-keyword">program</span></span> stest1<br>    <span class="hljs-keyword">implicit</span> <span class="hljs-keyword">none</span><br>    <span class="hljs-keyword">real</span> a(<span class="hljs-number">10</span>, <span class="hljs-number">20</span>), b(<span class="hljs-number">10</span>, <span class="hljs-number">20</span>), c(<span class="hljs-number">100</span>, <span class="hljs-number">200</span>), d(<span class="hljs-number">100</span>, <span class="hljs-number">200</span>)<br>    ......<br>    <span class="hljs-keyword">call</span> copy2d(a, b, <span class="hljs-number">10</span>, <span class="hljs-number">20</span>)<br>    <span class="hljs-keyword">call</span> copy2d(c, d, <span class="hljs-number">100</span>, <span class="hljs-number">200</span>)<br><span class="hljs-keyword">end</span> <span class="hljs-function"><span class="hljs-keyword">program</span></span> stest1<br><br><span class="hljs-function"><span class="hljs-keyword">subroutine</span></span> copy2d(a, b, m, n)<br>    <span class="hljs-keyword">implicit</span> <span class="hljs-keyword">none</span><br>    <span class="hljs-keyword">real</span> a(m, n), b(m, n)<br>    <span class="hljs-keyword">integer</span> m, n, i, j<br>    <span class="hljs-keyword">do</span> j = i, n<br>        <span class="hljs-keyword">do</span> i = i, m<br>            b(i, j) = a(i, j)<br>        <span class="hljs-keyword">enddo</span><br>    <span class="hljs-keyword">enddo</span><br><span class="hljs-keyword">end</span> <span class="hljs-function"><span class="hljs-keyword">subroutine</span></span> copy2d<br></code></pre></td></tr></table></figure><p>数组 a(m, n) 的定义表示数组的行号是从 1 到 m、列号是从 1 到n。如果想要行号和列号从 0 开始，则应该将数组定义为 a(0:m-1,0:n-1)。一维数组时可以定义为 a(0:*)。</p><h2 id="函数副程序">函数副程序</h2><p><strong>函数副程序，这个称呼不一定十分准确，实际上就是其他编程语言中常用的函数</strong>。在某种程度上，函数只是子程序的替代，但是对于Fortran来说，函数必须将函数名作为变量进行声明，并将计算的结果赋给这个函数名同名变量。一个完整的例子如下示例8 所示。</p><h5 id="小提示-3">小提示</h5><p><strong>函数副程序只能返回一个结果，而子程序可以返回多个结果</strong>。所以如果只是用来计算某个公式或者求解某个结果，可以优先采用函数副程序。如果需要同时返回多个变量，则优先采用子程序。</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs fortran"><span class="hljs-comment">!!! 示例 8</span><br><span class="hljs-function"><span class="hljs-keyword">function</span></span> square(x)<br>    <span class="hljs-keyword">implicit</span> <span class="hljs-keyword">none</span><br>    <span class="hljs-keyword">real</span> square, x         <span class="hljs-comment">! 声明函数名同名变量</span><br>    square = x*x           <span class="hljs-comment">! 将计算结果赋给函数名同名变量</span><br><span class="hljs-keyword">end</span> <span class="hljs-function"><span class="hljs-keyword">function</span></span> square<br><br><span class="hljs-function"><span class="hljs-keyword">program</span></span> ftest1<br>    <span class="hljs-keyword">implicit</span> <span class="hljs-keyword">none</span><br>    <span class="hljs-keyword">real</span> x, y, square      <span class="hljs-comment">! 声明使用的函数名同名变量</span><br>    x = <span class="hljs-number">4.0</span><br>    y = <span class="hljs-number">3.0</span>*square(x+<span class="hljs-number">1.0</span>) + <span class="hljs-number">50.5</span><br>    <span class="hljs-built_in">print</span> *, x, y<br><span class="hljs-keyword">end</span> <span class="hljs-function"><span class="hljs-keyword">program</span></span> ftest1<br><br><span class="hljs-comment">!!! 执行结果</span><br>&gt;&gt;&gt;   <span class="hljs-number">4.00000000</span>       <span class="hljs-number">125.500000</span><br></code></pre></td></tr></table></figure><h5 id="小提示-4">小提示</h5><p>Fortran中的函数使用需要严格遵守函数名同名变量在主程序和函数中的相同类型声明，否则就无法通过编译。</p><h2 id="全局变量">全局变量</h2><p>虽然我们在不同的子程序中使用同名的局部变量不会相互影响，但是有的时候也希望一些变量能在不同的子程序中共享使用，这类变量我们可以称之为<strong>全局变量</strong>。</p><p>Fortran 语言中全局变量必须使用 <code>module</code>的方式单独定义。当在主程序或子程序中需要使用这些已定义的全局变量时，首先要使用<code>use &lt;module 名&gt;</code> 来声明引用，并且该声明应在<code>implicit none</code> 之前。如下所示，定义了两个整数类型的变量 nmin和 nmax，以及实数类型的变量 tinitial 和 二维数组 amatrix。</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs fortran"><span class="hljs-keyword">module</span> data1<br>    <span class="hljs-keyword">integer</span> nmin, nmax<br>    <span class="hljs-keyword">real</span> tinitial, amatrix(<span class="hljs-number">20</span>, <span class="hljs-number">30</span>)<br><span class="hljs-keyword">end</span> <span class="hljs-keyword">module</span> data1<br></code></pre></td></tr></table></figure><p>示例 9是一个完整的全局变量定义和使用的例子。可以看到，子程序并没有声明任何参数，而是利用定义的全局变量xais 和 yais来从主程序中传递值到子程序中。这里的程序执行顺序是：<strong>主程序 →调用子程序 → 子程序中的打印 → 子程序修改 yais 变量 → 主程序中的打印 →程序结束</strong>。所以最终的执行结果的第一行是子程序中打印还未修改的两个全局变量，而第二行是主程序中打印已被子程序修改的两个全局变量，符合预期效果。</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs fortran"><span class="hljs-comment">!!! 示例 9</span><br><span class="hljs-keyword">module</span> global<br>    <span class="hljs-keyword">real</span> xais, yais<br><span class="hljs-keyword">end</span> <span class="hljs-keyword">module</span> global<br><br><span class="hljs-function"><span class="hljs-keyword">program</span></span> stest4<br>    <span class="hljs-keyword">use</span> global<br>    <span class="hljs-keyword">implicit</span> <span class="hljs-keyword">none</span><br>    xais = <span class="hljs-number">5.0</span><br>    yais = <span class="hljs-number">100.0</span><br>    <span class="hljs-keyword">call</span> subr4<br>    <span class="hljs-built_in">print</span> *, xais, yais<br><span class="hljs-keyword">end</span> <span class="hljs-function"><span class="hljs-keyword">program</span></span> stest4<br><br><span class="hljs-function"><span class="hljs-keyword">subroutine</span></span> subr4<br>    <span class="hljs-keyword">use</span> global<br>    <span class="hljs-keyword">implicit</span> <span class="hljs-keyword">none</span><br>    <span class="hljs-built_in">print</span> *, xais, yais<br>    yais = <span class="hljs-number">25.0</span><br><span class="hljs-keyword">end</span> <span class="hljs-function"><span class="hljs-keyword">subroutine</span></span> subr4<br><br><span class="hljs-comment">!!! 执行结果</span><br>&gt;&gt;&gt;   <span class="hljs-number">5.00000000</span>       <span class="hljs-number">100.000000</span>    <br>&gt;&gt;&gt;   <span class="hljs-number">5.00000000</span>       <span class="hljs-number">25.0000000</span><br></code></pre></td></tr></table></figure><h5 id="小提示-5">小提示</h5><p>有的时候子程序中可能并不需要 module中定义的所有全局变量，只想引入几个有关的全局变量。在 Fortran语言中可以用 <code>only</code>的语法来限定引入的全局变量，如下所示。</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs fortran"><span class="hljs-keyword">use</span> 模块名, <span class="hljs-keyword">only</span> : 变量<span class="hljs-number">1</span>, 变量<span class="hljs-number">2</span>, ...<br><span class="hljs-keyword">use</span> global, <span class="hljs-keyword">only</span> : yaxsis<br></code></pre></td></tr></table></figure><h2 id="混合嵌套调用">混合嵌套调用</h2><p>一般地，子程序或者函数的参数都是一些来自主程序的局部变量，那么子程序中调用函数是否也需要在参数中进行声明呢？是的，子程序如果想要使用某个函数，需要将函数名作为参数引用。</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs fortran"><span class="hljs-comment">!!! 示例 10</span><br><span class="hljs-function"><span class="hljs-keyword">subroutine</span></span> subrout(subr, xmin, xmax, n)<br>    <span class="hljs-keyword">implicit</span> <span class="hljs-keyword">none</span><br>    <span class="hljs-keyword">real</span> xmin, xmax, dx, y<br>    <span class="hljs-keyword">integer</span> n, i<br>    dx = (xmax - xmin)/n<br>    <span class="hljs-keyword">do</span> i = <span class="hljs-number">0</span>, n<br>        <span class="hljs-keyword">call</span> subr(dx*i+xmin, y)<br>        <span class="hljs-built_in">print</span> *, i, y<br>    <span class="hljs-keyword">enddo</span><br><span class="hljs-keyword">end</span> <span class="hljs-function"><span class="hljs-keyword">subroutine</span></span> subrout<br><br><span class="hljs-function"><span class="hljs-keyword">subroutine</span></span> funcout(fun, xmin, xmax, n)<br>    <span class="hljs-keyword">implicit</span> <span class="hljs-keyword">none</span><br>    <span class="hljs-keyword">real</span> fun, xmin, xmax, x, dx, y<br>    <span class="hljs-keyword">integer</span> n, i<br>    dx = (xmax-xmin)/n<br>    <span class="hljs-keyword">do</span> i = <span class="hljs-number">0</span>, n<br>        x = dx*i + xmin<br>        y = func(x)**<span class="hljs-number">3</span><br>        <span class="hljs-built_in">print</span> *, x, y<br>    <span class="hljs-keyword">enddo</span><br><span class="hljs-keyword">end</span> <span class="hljs-function"><span class="hljs-keyword">subroutine</span></span> funcout<br><br><span class="hljs-function"><span class="hljs-keyword">subroutine</span></span> sub(x, y)<br>    <span class="hljs-keyword">implicit</span> <span class="hljs-keyword">none</span><br>    <span class="hljs-keyword">real</span> y, x<br>    y = <span class="hljs-number">2</span>*<span class="hljs-built_in">sin</span>(x) + <span class="hljs-built_in">cos</span>(x**<span class="hljs-number">2</span>)<br><span class="hljs-keyword">end</span> <span class="hljs-function"><span class="hljs-keyword">subroutine</span></span> sub<br><br><span class="hljs-function"><span class="hljs-keyword">function</span></span> fun(x)<br>    <span class="hljs-keyword">implicit</span> <span class="hljs-keyword">none</span><br>    <span class="hljs-keyword">real</span> fun, x<br>    fun = <span class="hljs-built_in">sin</span>(x)**<span class="hljs-number">3</span><br><span class="hljs-keyword">end</span> <span class="hljs-function"><span class="hljs-keyword">function</span></span> fun<br><br><span class="hljs-function"><span class="hljs-keyword">program</span></span> test_func<br>    <span class="hljs-keyword">implicit</span> <span class="hljs-keyword">none</span><br>    <span class="hljs-keyword">real</span>, <span class="hljs-keyword">external</span> :: fun<br>    <span class="hljs-keyword">external</span> sub<br>    <span class="hljs-keyword">call</span> subrout(sub, <span class="hljs-number">0.0</span>, <span class="hljs-number">3.0</span>, <span class="hljs-number">10</span>)<br>    <span class="hljs-keyword">call</span> funcout(fun, <span class="hljs-number">0.0</span>, <span class="hljs-number">3.0</span>, <span class="hljs-number">10</span>)<br><span class="hljs-keyword">end</span> <span class="hljs-function"><span class="hljs-keyword">program</span></span> test_func<br><br><span class="hljs-comment">!!! 执行结果</span><br>&gt;&gt;&gt;        <span class="hljs-number">0</span>   <span class="hljs-number">1.00000000</span>    <br>           <span class="hljs-number">1</span>   <span class="hljs-number">1.58699322</span>    <br>           <span class="hljs-number">2</span>   <span class="hljs-number">2.06518173</span>    <br>           <span class="hljs-number">3</span>   <span class="hljs-number">2.25615215</span>    <br>           <span class="hljs-number">4</span>   <span class="hljs-number">1.99450183</span>    <br>           <span class="hljs-number">5</span>   <span class="hljs-number">1.36681640</span>    <br>           <span class="hljs-number">6</span>  <span class="hljs-number">0.952533364</span>    <br>           <span class="hljs-number">7</span>   <span class="hljs-number">1.42861772</span>    <br>           <span class="hljs-number">8</span>   <span class="hljs-number">2.21715832</span>    <br>           <span class="hljs-number">9</span>   <span class="hljs-number">1.38931477</span>    <br>          <span class="hljs-number">10</span> -<span class="hljs-number">0.628890276</span>    <br>   <span class="hljs-number">0.00000000</span>       <span class="hljs-number">0.00000000</span>    <br>  <span class="hljs-number">0.300000012</span>       <span class="hljs-number">1.71903503E-05</span><br>  <span class="hljs-number">0.600000024</span>       <span class="hljs-number">5.83394058E-03</span><br>  <span class="hljs-number">0.900000036</span>      <span class="hljs-number">0.111042053</span>    <br>   <span class="hljs-number">1.20000005</span>      <span class="hljs-number">0.530770957</span>    <br>   <span class="hljs-number">1.50000000</span>      <span class="hljs-number">0.977679431</span>    <br>   <span class="hljs-number">1.80000007</span>      <span class="hljs-number">0.787805617</span>    <br>   <span class="hljs-number">2.10000014</span>      <span class="hljs-number">0.266100109</span>    <br>   <span class="hljs-number">2.40000010</span>       <span class="hljs-number">2.92694476E-02</span><br>   <span class="hljs-number">2.70000005</span>       <span class="hljs-number">4.75692534E-04</span><br>   <span class="hljs-number">3.00000000</span>       <span class="hljs-number">2.21971472E-08</span><br></code></pre></td></tr></table></figure><p>上面的示例 10是子程序和函数副程序的混合嵌套使用的一个范例，上述代码的主要结构如下所示：在主程序<code>test_func</code> 中调用子程序 <code>subrout</code> 和<code>funcout</code>，再由子程序 <code>subrout</code> 调用子程序<code>sub</code> 以及子程序 <code>funcout</code> 调用函数副程序<code>fun</code>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">test_func（主程序）<br>├── subrout（子程序）<br>│   └── sub（子程序）<br>└── funcout（子程序）<br>    └── fun（函数副程序）<br></code></pre></td></tr></table></figure><h5 id="小提示-6">小提示</h5><p>这里比较重要的是，在主程序中需要对递归调用的子程序和函数副程序进行声明。主程序中的递归子程序调用声明只需要<code>external</code>加上子程序名即可，而主程序中的递归函数副程序调用声明需要同时定义函数变量和函数名，因此写为<code>real, external ::</code> 加上函数副程序名。</p><p>当然在直接调用函数副程序 <code>fun</code> 的子程序<code>funcout</code> 中也需要定义函数同名变量，写为<code>real fun</code>。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Fortran</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Fortran-条件与循环语句</title>
    <link href="/2022/05/23/Fortran-%E6%9D%A1%E4%BB%B6%E4%B8%8E%E5%BE%AA%E7%8E%AF%E8%AF%AD%E5%8F%A5/"/>
    <url>/2022/05/23/Fortran-%E6%9D%A1%E4%BB%B6%E4%B8%8E%E5%BE%AA%E7%8E%AF%E8%AF%AD%E5%8F%A5/</url>
    
    <content type="html"><![CDATA[<h2 id="循环语句">循环语句</h2><p>Fortran 语言中的循环语句与其他高级编程语言中的 For 循环、while循环有点类似，但也略有不同。</p><h3 id="do-循环">do 循环</h3><p>Fortran 的最简单的循环语句称为 do 语句，其形式如下所示：</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs fortran"><span class="hljs-comment">!!! 不设置步长，默认为 1</span><br><span class="hljs-keyword">do</span> 整数型变量 = 起始值, 结束值<br>    ......<br>    ......<br><span class="hljs-keyword">enddo</span> <br></code></pre></td></tr></table></figure><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs fortran"><span class="hljs-comment">!!! 示例 1</span><br><span class="hljs-keyword">integer</span> a(<span class="hljs-number">10</span>)<br><span class="hljs-keyword">do</span> n = <span class="hljs-number">1</span>, <span class="hljs-number">10</span>      <span class="hljs-comment">! 计算 1，2，3，4，5，6，7，8，9，10</span><br>    a(n) = n<br><span class="hljs-keyword">enddo</span><br><br><span class="hljs-comment">!!! 设置步长，可以设置正整数和负整数，不能为 0</span><br><span class="hljs-keyword">do</span> 整数型变量 = 初始值, 结束值, 步长<br>    ......<br>    ......<br><span class="hljs-keyword">enddo</span><br><br><span class="hljs-comment">!!! 示例 2</span><br><span class="hljs-keyword">integer</span> a(<span class="hljs-number">5</span>)<br><span class="hljs-keyword">do</span> n = <span class="hljs-number">1</span>, <span class="hljs-number">10</span>, <span class="hljs-number">2</span>   <span class="hljs-comment">! 计算 1，3，5，7，9</span><br>    a(<span class="hljs-built_in">nint</span>(n/<span class="hljs-number">2</span>)) = n<br><span class="hljs-keyword">enddo</span><br><br><span class="hljs-comment">!!! 示例 3</span><br><span class="hljs-keyword">integer</span> a(<span class="hljs-number">5</span>)<br><span class="hljs-keyword">do</span> n = <span class="hljs-number">10</span>, <span class="hljs-number">1</span>, -<span class="hljs-number">2</span>   <span class="hljs-comment">! 计算 10，8，6，4，2</span><br>    a(n/<span class="hljs-number">2</span>) = n<br><span class="hljs-keyword">enddo</span><br></code></pre></td></tr></table></figure><h5 id="小提示">小提示</h5><p>在使用 do循环语句的时候，我们需要注意在<strong>结束循环语句后循环条件变量 n仍然存在</strong>。如果后续计算中还<strong>使用到了相同变量，务必要进行重新初始化赋值</strong>，否则可能造成数据上的污染。我们可以拿示例3 举个例子，当循环结束后，n 的值其实为 0 (不是 2)。虽然此时的 n值并不满足循环继续的条件，但是已经完成了对步长的迭代计算，所以如果后续还是使用相同的变量n，我们期待的 n 初始值与循环结束后的 n值就可能不一样。<strong>建议在将某个变量设置为循环条件变量之后，循环外尽量不要使用同一个变量</strong>，从而避免这一可能存在的干扰。</p><p>do 循环语句实际上也<strong>可以存在嵌套，即一个 do循环语句包含了其他的 do 循环语句</strong>，如下示例 4所示。其中需要注意的是，在多重 do循环语句中，循环语句的<strong>条件变量不要使用相同的</strong>，否则很可能出现了我们意料之外的问题。建议同一个do 循环嵌套语句中使用不同的条件变量。如果不在同一个 do循环嵌套语句中，使用相同的条件变量产生问题的可能性比较小。</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs fortran"><span class="hljs-comment">!!! 示例 4</span><br><span class="hljs-keyword">integer</span> a(<span class="hljs-number">10</span>)<br><span class="hljs-keyword">integer</span> b(<span class="hljs-number">10</span>, <span class="hljs-number">5</span>)<br><span class="hljs-keyword">do</span> n = <span class="hljs-number">1</span>, <span class="hljs-number">10</span><br>    a(n) = n<br>    <span class="hljs-keyword">do</span> m = <span class="hljs-number">1</span>, <span class="hljs-number">10</span>, <span class="hljs-number">2</span><br>        b(n, <span class="hljs-built_in">nint</span>(m/<span class="hljs-number">2</span>)) = a(n) + m<br>    <span class="hljs-keyword">enddo</span><br><span class="hljs-keyword">enddo</span><br></code></pre></td></tr></table></figure><h5 id="小提示-1">小提示</h5><p>其实在 do循环中所指定的条件变量的初始值、结束值及步长也可以用已有值的变量来代替，如下所示。</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs fortran"><span class="hljs-keyword">integer</span> m, <span class="hljs-built_in">sum</span><br>m = <span class="hljs-number">10</span><br><span class="hljs-built_in">sum</span> = <span class="hljs-number">0</span><br><span class="hljs-keyword">do</span> n = <span class="hljs-number">1</span>, m<br>    <span class="hljs-built_in">sum</span> = <span class="hljs-built_in">sum</span> + n<br><span class="hljs-keyword">enddo</span><br></code></pre></td></tr></table></figure><h3 id="while-循环">while 循环</h3><p>通过上面的内容，不难发现上述的 do 循环确实看起来有点像 C、C++ 中的For 循环，那么 Fortran 语言中是否也存在 while循环呢？答案是<strong>当然了</strong>，其形式如下所示。</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs fortran"><span class="hljs-keyword">do</span> <span class="hljs-keyword">while</span> (条件)<br>   ......<br>    ......<br><span class="hljs-keyword">enddo</span><br></code></pre></td></tr></table></figure><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs fortran"><span class="hljs-comment">!!! 示例 5</span><br><span class="hljs-comment">!!! 计算并输出 10，9，8，7，6，5，4，3，2，1 的平方</span><br><span class="hljs-keyword">integer</span> n<br>n = <span class="hljs-number">10</span><br><span class="hljs-keyword">do</span> <span class="hljs-keyword">while</span> (n &gt; <span class="hljs-number">0</span>)   <br>    <span class="hljs-built_in">print</span> *, n**<span class="hljs-number">2</span><br>    n = n - <span class="hljs-number">1</span><br><span class="hljs-keyword">enddo</span><br></code></pre></td></tr></table></figure><p>我们可以从示例 5 中发现，while 循环其实就是变化后的 do 循环。do循环中判断条件紧跟着 do字符串，当符合条件时进入循环体内部继续执行，否则跳出循环。while 循环中将do 循环的初始值放置在了循环语句的前面进行声明，while循环的条件中只有对于结束值的声明，而原来 do循环的步长自增或自减操作则放置在了循环体中。这里有一点不同的是，如果自增或自减语句被放置在循环体的第一行，那么最后的执行结果就与do 循环的不一致了。这是因为 <strong>do循环实际上是在循环体执行完成后执行的步长自增或自减操作，而 while循环中则可以自行设置自增或自减操作在循环体中的位置</strong>。</p><h2 id="条件语句">条件语句</h2><p>Fortran语言中的条件语句可以分为<strong>有条件</strong>和<strong>无条件</strong>两种。我们所熟知的if 语句就是有条件的，而无条件的则是类似于汇编语言的 goto 语句、exit语句、cycle 语句，甚至还有无条件 do 循环语句。</p><h3 id="if-语句">if 语句</h3><p>if语句最简单的方式就是，将条件判断语句与执行语句放在同一行，如下所示。这也是因为执行语句比较短，放置在同一行反而代码更加美观。当然一般来说执行语句可能不是一行，甚至是多分支、多重的，因此也有单分支if 语句、双分支 if 语句、多重 if 语句，如下所示。</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs fortran"><span class="hljs-comment">!!! 最简单的 if 语句</span><br><span class="hljs-keyword">if</span> (条件) 执行语句<br><br></code></pre></td></tr></table></figure><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs fortran"><span class="hljs-comment">!!! 示例 6</span><br><span class="hljs-keyword">integer</span> n<br><span class="hljs-keyword">integer</span> i<br>n = <span class="hljs-number">10</span><br>i = -<span class="hljs-number">4</span><br><span class="hljs-keyword">if</span> (i &lt; <span class="hljs-number">0</span>) n = <span class="hljs-number">5</span><br><span class="hljs-built_in">print</span> *, n<br><br><br><span class="hljs-comment">!!! 单分支 if 语句</span><br><span class="hljs-keyword">if</span> (条件) <span class="hljs-keyword">then</span><br>    ......<br>    ......<br><span class="hljs-keyword">endif</span><br><br><span class="hljs-comment">!!! 示例 7</span><br><span class="hljs-keyword">if</span> (i &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">then</span><br>    n = <span class="hljs-number">5</span><br><span class="hljs-keyword">endif</span><br><span class="hljs-built_in">print</span> *, n<br><br><br><span class="hljs-comment">!!! 双分支 if 语句 (一般)</span><br><span class="hljs-keyword">if</span> (条件) <span class="hljs-keyword">then</span><br>    ......<br><span class="hljs-keyword">else</span><br>    ......<br><span class="hljs-keyword">endif</span><br><br><span class="hljs-comment">!!! 示例 8</span><br><span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span>) <span class="hljs-keyword">then</span><br>    n = <span class="hljs-number">8</span><br><span class="hljs-keyword">else</span><br>    n = <span class="hljs-number">5</span><br><span class="hljs-keyword">endif</span><br><span class="hljs-built_in">print</span> *, n<br><br><br><span class="hljs-comment">!!! 多重 if 语句</span><br><span class="hljs-keyword">if</span> (条件 <span class="hljs-number">1</span>) <span class="hljs-keyword">then</span><br>    .....<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (条件 <span class="hljs-number">2</span>) <span class="hljs-keyword">then</span><br>        ......<br>    <span class="hljs-keyword">else</span><br>        .....<br>    <span class="hljs-keyword">endif</span><br><span class="hljs-keyword">endif</span><br><br><span class="hljs-comment">!!! 示例 9</span><br><span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span>) <span class="hljs-keyword">then</span><br>    n = <span class="hljs-number">8</span><br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (i &gt; -<span class="hljs-number">2</span>) <span class="hljs-keyword">then</span><br>        n = <span class="hljs-number">6</span><br>    <span class="hljs-keyword">else</span><br>        n = <span class="hljs-number">5</span><br>    <span class="hljs-keyword">endif</span><br><span class="hljs-keyword">endif</span><br><span class="hljs-built_in">print</span> *, n<br></code></pre></td></tr></table></figure><p>在使用条件语句对条件变量进行比较判断时，除了我们常用的<code>&gt;</code>、<code>&lt;</code>之外，也有其他比较符号可以使用，如下表所示。</p><table><thead><tr class="header"><th>比较条件符号</th><th>含义</th><th>示例</th></tr></thead><tbody><tr class="odd"><td>==</td><td>左边等于右边</td><td>n == 10</td></tr><tr class="even"><td>/=</td><td>左边不等于右边</td><td>n /= 10</td></tr><tr class="odd"><td>&gt;</td><td>左边大于右边</td><td>n &gt; 10</td></tr><tr class="even"><td>&gt;=</td><td>左边大于或等于右边</td><td>n &gt;=10</td></tr><tr class="odd"><td>&lt;</td><td>左边小于右边</td><td>n &lt; 10</td></tr><tr class="even"><td>&lt;=</td><td>左边小于或等于右边</td><td>n &lt;= 10</td></tr></tbody></table><h5 id="小提示-2">小提示</h5><p>这里需要注意一点，如果我们想要<strong>比较左右两边是否相等，不是使用<code>=</code>，而是使用<code>==</code></strong>。其实这一点也比较容易理解，<code>=</code>的含义是将等号右边的值或者计算结果赋值给左边的变量，为了加以区分，比较左右两边时则使用<code>==</code>。另外，根据使用其他高级编程语言的经验来看，<code>==</code>是恒等于的意思，即左右两边不仅值相等、类型也相等，这不正是最稳妥的比较是否相等的方式吗？</p><p>当我们使用条件语句的时候还有一类使用场景，就是<strong>判断一个变量值是否在一个区间，即存在一个下限值和一个上限值</strong>。如果使用我们上述的if 语句恐怕只有多重 if语句才能满足我们的需求了，但是这代码写起来可能有点显得多余，毕竟我们在逻辑上是想要同时判断变量值与上下限值的大小。所以Fortran 语言的 if 语句中也<strong>存在逻辑运算符<code>.and.</code>、<code>.or.</code> 和<code>.not.</code></strong>，具体如下表所示。</p><table><thead><tr class="header"><th>逻辑运算符</th><th>含义</th></tr></thead><tbody><tr class="odd"><td>条件 1 .and. 条件 2</td><td>同时满足条件 1 和条件 2</td></tr><tr class="even"><td>条件 1 .or. 条件 2</td><td>满足条件 1 和条件 2 之一即可</td></tr><tr class="odd"><td>.not. 条件</td><td>不满足条件，即满足条件的相反条件</td></tr></tbody></table><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs fortran"><span class="hljs-comment">!!! 示例 10</span><br><span class="hljs-keyword">if</span> (i &lt; <span class="hljs-number">0</span> .and. i &gt; -<span class="hljs-number">2</span>) <span class="hljs-keyword">then</span><br>    n = <span class="hljs-number">5</span><br><span class="hljs-keyword">else</span><br>    n = <span class="hljs-number">10</span><br><span class="hljs-keyword">endif</span><br></code></pre></td></tr></table></figure><h5 id="小提示-3">小提示</h5><p>我们在其他高级编程语言中可能已经习惯了类似于<strong><code>-2 &lt; n &lt; 0</code> </strong>这样的写法，有的时候在Fortran 语言中也会不自觉地写成这样。但是在 Fortran语言中这种<strong>写法是不被支持的</strong>，我们需要使用逻辑运算符<code>.and.</code> 来把上下限值判断连接起来，而不能写在一起。</p><h2 id="无条件语句">无条件语句</h2><p>无条件语句一般来说与条件语句的作用是不相同的，主要是为了程序可以跳转、中途退出，但也有类似于do 循环这样的，只不过还是需要 if语句来帮助完成跳出循环的判断。<strong>无条件语句有 goto 语句、exit语句、 cycle 语句三种</strong>。</p><h3 id="goto-语句">goto 语句</h3><p>如下所示，这里的 goto 语句的用法与汇编语言的 goto语句有点类似，<strong>指定一个行号即可无条件跳转到该行执行</strong>。如果是像下面这样<strong>调用goto语句的行在跳转到的行之前，那么它们之间的行都会被完全忽略</strong>。如示例11 所示，<code>a = 15</code> 的赋值语句会被忽略所以 a 的值是在 goto语句执行之前赋的值 10；同理，<code>b = 11</code> 的赋值语句在 goto语句和跳转行之间会被忽略，跳转行的 <code>b = 20</code> 生效。如示例 12所示，当 goto 语句跳转到它之前行执行时，就会造成无限循环，每次执行到goto 语句就会又跳转到前面，这样 goto 语句后面的命令都不会被执行。</p><h5 id="小提示-4">小提示</h5><p>我们在使用 goto语句时对跳转的行一定要非常注意，一不小心很容易造成死循环。建议使用 goto语句的时候跳转到其后的行，杜绝跳转到前面的行。</p><p>为了提高代码可读性，我们<strong>不想将 goto语句跳转的行直接指向一个操作或者命令，这时我们就可以用 continue来代替跳转行</strong>，如示例 13 所示。</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs fortran"><span class="hljs-keyword">goto</span> 行号<br><br>行号 操作或命令<br><br><span class="hljs-comment">!!! 示例 11</span><br>   a = <span class="hljs-number">10</span><br>   <span class="hljs-keyword">goto</span> <span class="hljs-number">8</span><br>   b = <span class="hljs-number">11</span><br>   a = <span class="hljs-number">15</span><br><span class="hljs-number">8</span>  b = <span class="hljs-number">20</span><br>   <span class="hljs-built_in">print</span> *, a, b  <span class="hljs-comment">! 此处输出 a 的值为 10，b 的值为 20</span><br><br><span class="hljs-comment">!!! 示例 12</span><br><br><span class="hljs-number">8</span> a = <span class="hljs-number">10</span><br>  b = <span class="hljs-number">11</span><br>  a = a + b<br>  <span class="hljs-keyword">goto</span> <span class="hljs-number">8</span><br>  b = b - a       <span class="hljs-comment">! 永远不会被执行</span><br>  <span class="hljs-built_in">print</span> *, a, b   <span class="hljs-comment">! 永远不会被执行</span><br><br><span class="hljs-comment">!!! 示例 13</span><br><span class="hljs-number">8</span> <span class="hljs-keyword">continue</span><br>  a = <span class="hljs-number">10</span><br>  b = <span class="hljs-number">11</span><br>  a = a + b<br>  <span class="hljs-keyword">goto</span> <span class="hljs-number">8</span><br></code></pre></td></tr></table></figure><h3 id="exit-语句">exit 语句</h3><p>当我们在使用 do循环语句时，如果<strong>想要在某个与循环条件无关的条件满足时提前退出循环，就要使用if 语句和 exit 语句的组合</strong>了。如示例 14 所示，当 sum 的值超过 10时循环就会被提前终止。由于 <code>1+2+3+4=10</code>，所以 i 加到 5才会使得 sum 值超过 10，此时的 sum 则为 <code>1+2+3+4+5=15</code>，而 i也因为提前退出循环而不会执行自增操作，所以此时输出的 i 值为最后的5。如果将原来的 exit 语句换成 goto 语句，并将 goto语句指向的跳转行设为循环外的下一行，则最后的效果也是一样的，如示例 15所示。</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs fortran"><span class="hljs-comment">!!! 示例 14</span><br><span class="hljs-built_in">sum</span> = <span class="hljs-number">0</span><br><span class="hljs-keyword">do</span> i = <span class="hljs-number">1</span>, <span class="hljs-number">10</span><br>    <span class="hljs-built_in">sum</span> = <span class="hljs-built_in">sum</span> + i<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">sum</span> &gt; <span class="hljs-number">10</span>) <span class="hljs-keyword">exit</span><br><span class="hljs-keyword">enddo</span><br><span class="hljs-built_in">print</span> *, i, <span class="hljs-built_in">sum</span>      <span class="hljs-comment">! 输出 i 的值为 5，sum 的值为 15</span><br><br><span class="hljs-comment">!!! 示例 15</span><br>    <span class="hljs-built_in">sum</span> = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">do</span> i = <span class="hljs-number">1</span>, <span class="hljs-number">10</span><br>        <span class="hljs-built_in">sum</span> = <span class="hljs-built_in">sum</span> + i<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">sum</span> &gt; <span class="hljs-number">10</span>) <span class="hljs-keyword">goto</span> <span class="hljs-number">8</span><br>    <span class="hljs-keyword">enddo</span><br><span class="hljs-number">8</span>   <span class="hljs-built_in">print</span> *, i, <span class="hljs-built_in">sum</span>  <span class="hljs-comment">! 输出 i 的值仍为 5，sum 的值仍为 15</span><br></code></pre></td></tr></table></figure><h3 id="cycle-语句">cycle 语句</h3><p>cycle 语句与 exit语句正好表示了<strong>相反</strong>的意思，它指示程序在<strong>满足条件时继续执行循环、不满足条件时跳出循环</strong>。如示例16 所示，这个 cycle 语句的效果与示例 14、15 的完全一致。</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs fortran"><span class="hljs-comment">!!! 示例 16</span><br><span class="hljs-built_in">sum</span> = <span class="hljs-number">0</span><br><span class="hljs-keyword">do</span> i = <span class="hljs-number">1</span>, <span class="hljs-number">10</span><br>    <span class="hljs-built_in">sum</span> = <span class="hljs-built_in">sum</span> + i<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">sum</span> &lt;= <span class="hljs-number">10</span>) <span class="hljs-keyword">cycle</span><br><span class="hljs-keyword">enddo</span><br><span class="hljs-built_in">print</span> *, i, <span class="hljs-built_in">sum</span>      <span class="hljs-comment">! 输出 i 的值仍为 5，sum 的值仍为 15</span><br></code></pre></td></tr></table></figure><p>Copy</p><h3 id="多重循环下的-exit-与-goto-语句">多重循环下的 exit 与 goto语句</h3><p>一般来说在复杂的行列式计算中经常会遇到多重循环，这与以上 goto 和 exit语句的场景稍显不同。goto语句的跳转行因为可以指定任何一行，所以不会被多重循环影响，可以直接跳转到多重循环之外或者某一重循环之中的某一行，如示例17 所示。而<strong>exit语句如果还是按照上面的用法每次只能退出一重循环，碰到需要同时退出多重循环时就比较麻烦</strong>。所以Fortran 语言为了尽量避免这一问题，就给 exit 语句添加一种<strong>类似于goto 语句指示跳转行的方法 <code>exit out</code></strong>，如示例 18所示。</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs fortran"><span class="hljs-comment">!!! 示例 17</span><br>    <span class="hljs-built_in">sum</span> = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">do</span> i = <span class="hljs-number">1</span>, <span class="hljs-number">10</span><br>        <span class="hljs-keyword">do</span> j = <span class="hljs-number">1</span>, <span class="hljs-number">10</span><br>            <span class="hljs-built_in">sum</span> = <span class="hljs-built_in">sum</span> + i + j<br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">sum</span> &gt; <span class="hljs-number">10</span>) go <span class="hljs-number">10</span><br>        <span class="hljs-keyword">enddo</span><br>    <span class="hljs-keyword">enddo</span><br><span class="hljs-number">10</span>  <span class="hljs-built_in">print</span> *, i, j, <span class="hljs-built_in">sum</span>   <span class="hljs-comment">! 输出 i 的值为 1，j 的值为 4，sum 的值为 11</span><br><br><span class="hljs-comment">!!! 示例 18</span><br><span class="hljs-built_in">sum</span> = <span class="hljs-number">0</span><br><span class="hljs-keyword">out</span>: <span class="hljs-keyword">do</span> i = <span class="hljs-number">1</span>, <span class="hljs-number">10</span><br>        <span class="hljs-keyword">do</span> j = <span class="hljs-number">1</span>, <span class="hljs-number">10</span><br>            <span class="hljs-built_in">sum</span> = <span class="hljs-built_in">sum</span> + i + j<br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">sum</span> &gt; <span class="hljs-number">10</span>) <span class="hljs-keyword">exit</span> <span class="hljs-keyword">out</span><br>        <span class="hljs-keyword">enddo</span><br>     <span class="hljs-keyword">enddo</span> <span class="hljs-keyword">out</span><br><span class="hljs-built_in">print</span> *, i, j, <span class="hljs-built_in">sum</span>       <span class="hljs-comment">! 输出 i 的值为 1，j 的值为 4，sum 的值为 11 </span><br></code></pre></td></tr></table></figure><h5 id="小提示-5">小提示</h5><p>这里需要注意的是，<strong>当使用 <code>exit out</code> 方法时，out是对应于循环的一个别名，需要同时在 do 前和 enddo 后添加 out的声明</strong>。当然，这里的别名也可以使用其他符合规则的字符串，只要不与同一个代码文件中的其他别名或变量名等相同即可。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Fortran</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Fortran 基础知识</title>
    <link href="/2022/05/23/Fortran-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    <url>/2022/05/23/Fortran-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
    
    <content type="html"><![CDATA[<h2 id="主函数">主函数</h2><p>一个完整的Fortran代码，一般来说，<strong>以<code>program code_name</code> 开始，以<code>end program code_name</code>结束的首末声明</strong>，<strong>变量声明</strong>以及<strong>需要执行的命令或者操作</strong>三个部分组成。通用的Fortran 代码文件的文件后缀可以是<code>.f90</code>、<code>.f</code>、<code>.g95</code>等等，但通常为了统一和适应不同版本的 Fortran 编译环境<strong>建议采用<code>.f90</code> 后缀</strong>。和 C、C++ 语言比较类似，Fortran代码也是通过编译执行。比如对如下所示的示例代码执行<strong><code>gfortran code_name.f90 -o code_name</code></strong>即可生成可执行程序 <code>code_name</code>，再执行<strong><code>./code_name</code> </strong>则会输出代码执行结果如下。</p><p>code_name.f90</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs fortran"><span class="hljs-function"><span class="hljs-keyword">program</span></span> code_name<br>    <span class="hljs-keyword">implicit</span> <span class="hljs-keyword">none</span><br>    <span class="hljs-keyword">real</span> x, y, z<br>    x = <span class="hljs-number">2</span><br>    y = <span class="hljs-number">3</span><br>    z = x + y * <span class="hljs-number">5</span><br>    <span class="hljs-built_in">print</span> *, x, y<br>    <span class="hljs-built_in">print</span> *, <span class="hljs-string">&#x27;z = &#x27;</span>, z <br><span class="hljs-keyword">end</span> <span class="hljs-function"><span class="hljs-keyword">program</span></span> code_name<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">  2.00000000       3.00000000    <br>z =    17.0000000<br></code></pre></td></tr></table></figure><p>上面给出的示例代码中有一行<code>implicit none</code>，明明本来的代码已经符合三个部分了，为什么要多加这一行呢？这是因为在旧Fortran 中存在隐式类型声明，为了规避在 Fortran 95以后的版本中可能出现错误，特意在每个开头声明之后都加上这么一行。这样我们在写代码的过程中如果使用到了未提前声明或者打错字符的变量名，编译程序就会报错告知我们。这对于形成良好的代码习惯和增强代码可维护性有很大的帮助，因此此行声明必不可少。</p><h2 id="运算符">运算符</h2><p>Fortran语言和别的高级编程语言一样，都拥有完整的运算符，包括简单的加减乘除、复杂的乘方等运算。如下表所示是Fortran语言中的运算符的写法和使用方法，其中运算符的计算优先顺序与数学计算中一致：<strong>乘方运算&gt; 乘除运算 &gt; 加减运算</strong>。</p><h2 id="数据类型与变量声明">数据类型与变量声明</h2><p>Fortran语言的数据类型比较简单，没有像其他高级编程语言那样分得那么细，主要分为<strong>整数型</strong>和<strong>实数型</strong>两个大类。整数型的计算与C、C++、Python中有点类似，整数与整数的商还是一个整数。<strong>即使当不整除的时候，为了保持结果和参与运算的变量类型一致Fortran编译器会只取正常数学运算结果的整数部分</strong>。实数型其实与数学意义上的实数是一致的，既<strong>包括整数也包括小数</strong>，所以当不整除的除法中的两个变量<strong>有一个为实数型</strong>时，Fortran编译器会将两个变量类型对应成实数型并<strong>计算出正常的带小数的结果</strong>。</p><p><strong>所有变量都要在使用之前声明类型</strong>，所以<strong>当属于同一种类型时我们可以按照下面那样写在同一行</strong>，不同变量之间用逗号分隔开。为了代码美观，<strong>建议在逗号与后一个变量名之间留一个空格</strong>。</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs fortran"><span class="hljs-comment">!!! 两个整数型相除</span><br><span class="hljs-keyword">integer</span> x, y<br>x = <span class="hljs-number">2</span><br>y = <span class="hljs-number">3</span><br><span class="hljs-built_in">print</span> *, x/y   <span class="hljs-comment">! 结果为 0</span><br><span class="hljs-built_in">print</span> *, y/x   <span class="hljs-comment">! 结果为 1</span><br><br><span class="hljs-comment">!!! 被除数为实数型，除数为整数型</span><br><span class="hljs-keyword">real</span> m <br><span class="hljs-keyword">integer</span> n <br>m = <span class="hljs-number">10</span><br>n = <span class="hljs-number">3</span><br><span class="hljs-built_in">print</span> *, m/n   <span class="hljs-comment">! 结果为  3.33333325</span><br><br><span class="hljs-comment">!!! 被除数为整数型，除数为实数型</span><br><span class="hljs-keyword">integer</span> m <br><span class="hljs-keyword">real</span> n <br>m = <span class="hljs-number">10</span><br>n = <span class="hljs-number">3</span><br><span class="hljs-built_in">print</span> *, m/n   <span class="hljs-comment">! 结果为  3.33333325</span><br><br><span class="hljs-comment">!!! 被除数和除数均为实数型</span><br><span class="hljs-keyword">real</span> m, n<br>m = <span class="hljs-number">10</span><br>n = <span class="hljs-number">3</span><br><span class="hljs-built_in">print</span> *, m/n   <span class="hljs-comment">! 结果为  3.33333325</span><br></code></pre></td></tr></table></figure><p>实际上，Fortran语言除了整数型和实数型两个大类之外，还有一些小类，比如说<strong>复数类型、布尔类型、字符串类型</strong>。因为操作系统一般使用实数型或者复数类型时都<strong>默认采用单精度</strong>，如果需要使用双精度则需要特殊声明。所有数据类型总结如下：</p><table><thead><tr class="header"><th>数据类型</th><th>标识符</th><th>示例</th></tr></thead><tbody><tr class="odd"><td>整数型</td><td>integer</td><td>2</td></tr><tr class="even"><td>实数型</td><td>real</td><td>2.0</td></tr><tr class="odd"><td>双精度实数型</td><td>double precision</td><td>2.0</td></tr><tr class="even"><td>复数型</td><td>complex</td><td>(1.0, 2.0)</td></tr><tr class="odd"><td>双精度复数型</td><td>complex(kind(0d0))</td><td>(1.0, 2.0)</td></tr><tr class="even"><td>布尔型</td><td>logical</td><td>true/false</td></tr><tr class="odd"><td>字符串型</td><td>character</td><td>"Text"</td></tr></tbody></table><h5 id="小提示">小提示</h5><p>这里有一点值得十分注意：一个 Fortran文件的<strong>变量声明必须在最开始</strong>，如果多个变量声明行之间掺杂了其他的操作行或者命令行，则<strong>后续的变量声明将会无效</strong>，在编译的过程中就会直接报错。</p><h2 id="数学函数">数学函数</h2><p>Fortran既然是为数值计算而生的，那么自然就包含了对初等数学函数和数据类型变化函数的完整支持。如下表所示为有关初等数学函数的写法和用法。</p><table><thead><tr class="header"><th>写法</th><th>函数名称</th><th>数学表达</th><th>必要条件</th><th>函数值的范围</th></tr></thead><tbody><tr class="odd"><td>sqrt(x)</td><td>平方根</td><td><em>x</em></td><td>x <em>x</em>≧0</td><td></td></tr><tr class="even"><td>sin(x)</td><td>正弦函数</td><td>xsin<em>x</em></td><td></td><td></td></tr><tr class="odd"><td>cos(x)</td><td>余弦函数</td><td>xcos<em>x</em></td><td></td><td></td></tr><tr class="even"><td>tan(x)</td><td>正切函数</td><td>xtan<em>x</em></td><td></td><td></td></tr><tr class="odd"><td>asin(x)</td><td>反正弦函数</td><td>^{-1}xsin−1<em>x</em></td><td>-1x −1≦<em>x</em>≦1</td><td>- f −2<em>π</em>≦<em>f</em>≦2<em>π</em></td></tr><tr class="even"><td>acos(x)</td><td>反余弦函数</td><td>^{-1}xcos−1<em>x</em></td><td>-1x −1≦<em>x</em>≦1</td><td>0 f ≦<em>f</em>≦<em>π</em></td></tr><tr class="odd"><td>atan(x)</td><td>反正切函数</td><td>^{-1}xtan−1<em>x</em></td><td></td><td>- &lt; f &lt; −2<em>π</em>&lt;<em>f</em>&lt;2<em>π</em></td></tr><tr class="even"><td>atan2(y, x)</td><td>反正切函数</td><td>^{-1}(y/x)tan−1(<em>y</em>/<em>x</em>)</td><td></td><td>-&lt; f &lt; −<em>π</em>&lt;<em>f</em>&lt;<em>π</em></td></tr><tr class="odd"><td>exp(x)</td><td>指数函数</td><td>e^x*e**x*</td><td></td><td></td></tr><tr class="even"><td>log(x)</td><td>对数函数</td><td>_{e}xlog*e**x*</td><td>x &gt; 0<em>x</em>&gt;0</td><td></td></tr><tr class="odd"><td>log10(x)</td><td>常用对数函数</td><td>_{10}xlog10<em>x</em></td><td>x &gt; 0<em>x</em>&gt;0</td><td></td></tr><tr class="even"><td>sinh(x)</td><td>双曲正弦函数</td><td>xsinh<em>x</em></td><td></td><td></td></tr><tr class="odd"><td>cosh(x)</td><td>双曲余弦函数</td><td>xcosh<em>x</em></td><td></td><td></td></tr><tr class="even"><td>tanh(x)</td><td>双曲正切函数</td><td>xtanh<em>x</em></td><td></td><td></td></tr></tbody></table><p>下表为有关数据类型变化函数的写法和用法。</p><table><thead><tr class="header"><th>写法</th><th>函数名称</th><th>输入类型</th><th>输出类型</th><th>函数的含义</th></tr></thead><tbody><tr class="odd"><td>real(n)</td><td>实数化</td><td>整数</td><td>实数</td><td>变成实数型</td></tr><tr class="even"><td>abs(n)</td><td>绝对值</td><td>整数</td><td>整数</td><td>n<em>n</em> 的绝对值</td></tr><tr class="odd"><td>mod(m, n)</td><td>求余</td><td>2个整数</td><td>整数</td><td>m<em>m</em> 对 n<em>n</em> 求余</td></tr><tr class="even"><td>int(x)</td><td>整数化</td><td>实数</td><td>整数</td><td>变成整数型(去尾)</td></tr><tr class="odd"><td>nint(x)</td><td>整数化</td><td>实数</td><td>整数</td><td>变成整数型(四舍五入)</td></tr><tr class="even"><td>sign(x, s)</td><td>符号变更</td><td>实数</td><td>实数</td><td>s , x ; s &lt; 0, -xs<em>≧0,∣</em>x<em>∣;</em>s<em>&lt;0,−∣</em>x*∣</td></tr><tr class="odd"><td>abs(x)</td><td>绝对值</td><td>实数或复数</td><td>实数</td><td>x<em>x</em> 的绝对值</td></tr><tr class="even"><td>mod(x, y)</td><td>求余</td><td>2个实数</td><td>实数</td><td>x<em>x</em> 对 y<em>y</em> 求余</td></tr><tr class="odd"><td>real(z)</td><td>复数的实部</td><td>复数</td><td>实数</td><td>z<em>z</em> 的实部</td></tr><tr class="even"><td>imag(z)</td><td>复数的虚部</td><td>复数</td><td>实数</td><td>z<em>z</em> 的虚部</td></tr><tr class="odd"><td>cmplx(x, y)</td><td>复数化</td><td>两个实数</td><td>复数</td><td>x+iy<em>x</em>+*i**y*</td></tr><tr class="even"><td>conjg(z)</td><td>共轭复数</td><td>复数</td><td>复数</td><td>z<em>z</em> 的共轭复数</td></tr></tbody></table><h2 id="打印输出">打印输出</h2><p>Fortran 的打印输出其实已经在前面的示例代码中已经提到了，就是所谓的<code>print</code> 语句。<strong><code>print</code> 语句必须紧接着<code>*</code></strong>，其含义是按照标准格式输出，如果缺失这个的话在编译时就会报出<code>Error: Expected comma in I/O list at (1)</code>的错误。正确的打印输出示例代码如下：</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs fortran"><span class="hljs-keyword">integer</span> n<br>n = <span class="hljs-number">2</span><br><span class="hljs-built_in">print</span> *, <span class="hljs-number">1</span>+<span class="hljs-number">2</span>, n, n-<span class="hljs-number">1</span>, n/<span class="hljs-number">1</span>, n**<span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><p>输出结果如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">3           2           1           2           <br></code></pre></td></tr></table></figure><p>如果需要和其他高级编程语言那样<strong>在输出的过程中加入字符串到其中</strong>，则按如下设置：</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs fortran"><span class="hljs-keyword">real</span> m<br>m = <span class="hljs-number">5</span><br><span class="hljs-built_in">print</span> *, <span class="hljs-string">&#x27;m = &#x27;</span>, m, <span class="hljs-string">&#x27;  m*2 = &#x27;</span>, m*<span class="hljs-number">2</span><br><span class="hljs-built_in">print</span> *, <span class="hljs-string">&#x27;m = &#x27;</span>,m, <span class="hljs-string">&#x27;  m*2 = &#x27;</span>,m*<span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><p>输出结果如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">m =    5.00000000       m*2 =    10.0000000<br>m =    5.00000000       m*2 =    10.0000000<br></code></pre></td></tr></table></figure><p>根据以上输出结果我们可以看出，<code>m</code> 与 <code>=</code>之间的一个空格与实际输出时是一致的，而输出变量 <code>m</code>时不管与前一个逗号之间是否有空格，输出结果都不会发生改变，都存在超过一个以上的空格。实际上，这也是Fortran编译器为了能够区分输出内容，而特意在标准输出时对逗号分割的内容上添加这样的空格。不过为了代码阅读上的美观，建议在代码编写时还是保持变量与逗号之间的一个空格。</p><h5 id="小提示-1">小提示</h5><p>这里输出字符串的时候引用字符串的符号<strong>可以使用<code>'</code>，也可以使用<code>"</code></strong>。本质上没有什么区别，只是需要成对使用，不然就会报错。</p><h2 id="数组">数组</h2><h3 id="数组的定义">数组的定义</h3><p>前面我们所介绍的有关数据类型基本上能够涵盖一般的日常使用，但是对于科研人员来说，矩阵、行列式等等才是计算过程中不可缺少的数据类型。为此，Fortran也有了数组一样的数据类型来支持这一需求。如下所示，我们可以直接采用原有的整数型、实数型和复数型定义数组。<strong>当括号中只有一个数字时，表示是一维数组；当括号中有逗号分割的两个数字时，表示是二维数组；三维数组以此类推</strong>。二维数组可以用于表示我们所熟知的矩阵、行列式等数据类型。</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs fortran"><span class="hljs-keyword">integer</span> m(<span class="hljs-number">10</span>)         <span class="hljs-comment">! 长度为 10 的整数型数组</span><br><span class="hljs-keyword">real</span> x(<span class="hljs-number">20</span>), y(<span class="hljs-number">4</span>, <span class="hljs-number">5</span>)   <span class="hljs-comment">! 长度为 20 的实数型数组， 4 行 x 5 列的二维实数型数组</span><br><span class="hljs-keyword">complex</span> matrix(<span class="hljs-number">5</span>, <span class="hljs-number">5</span>)  <span class="hljs-comment">! 5 行 x 5 列的二维复数型数组</span><br></code></pre></td></tr></table></figure><h5 id="小提示-2">小提示</h5><p>这里需要注意的是，在定义数组的时候<strong>不仅可以用正整数，也可以用负整数和0</strong>。比如 <code>real n(-3:5)</code> 表示定义一个长度为 9、序号从-3 到 5 (包括 0)的一维数组，<code>real m(-2:1, 0:4)</code> 表示定义一个3 行 x 4 列、行序号从 -2 到 0、列序号从 1 到 4的二维数组。一般来说，为了与实际数学运算中的理解保持一致，建议采用正整数来定义数组更加方便。</p><h3 id="数组元素的选取">数组元素的选取</h3><p>既然定义了数组，那么我们就需要有对于数组的增加、选择这样的基本操作。<strong>Fortran数组中的序号是从 1 开始的，即写作n(1)</strong>，这点与其他高级编程语言略有不同，不过符合人类的数学认识。因此如下所示，当定义一个长度为10 的数组 n 时，数组 n 的最后一个元素就是n(10)。在实际的存储中，我们能够很容易理解一维数组是按照 1 到 10的顺序从左往右排列的，但是在二维数组中又会是怎么样呢？是行优先还是列优先呢？一般来说，在我们接触过的高级编程语言中几乎都是行优先的，即先存储第一行再存储第二行，以此类推。但是，在Fortran 中则是<strong>列优先</strong>的，也就是说 Fortran的二维数组<strong>存储时会先存储第一列再存储第二列</strong>，再以此类推。</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs fortran"><span class="hljs-keyword">real</span> n(<span class="hljs-number">10</span>)     <span class="hljs-comment">! n(1) ~ n(10)</span><br><span class="hljs-keyword">real</span> m(<span class="hljs-number">4</span>, <span class="hljs-number">4</span>)   <span class="hljs-comment">! m(1, 1) m(2, 1) m(3, 1) ... m(4, 4)</span><br></code></pre></td></tr></table></figure><h5 id="小提示-3">小提示</h5><p>如果我们在使用数组 n的过程中忘记了加上序号，那么程序<strong>默认就会对整个数组的全部元素进行操作</strong>，而非像其他高级编程语言可能会指向数组的第一个元素。</p><p>当我们想要去选取数组中的某一个元素时，可以直接通过对应的序号进行选取。但是如果想要选多个元素或者某一行、某一列时，这就有点不同了。比如说，现在有一个长度为10 的一维数组 n，我们想要获取到从第 3 个元素到第 5 个元素的 3个元素，<strong>应该使用 <code>:</code>来将序号的上下限分隔开同时选中，即 n(3:5)</strong>。如果有一个 3 行 x 4列 的二维数组 m，我们想要获取到第 2 行到第 3 行的所有元素，则应该使用m(2:3, 1:4) 来选取。</p><h2 id="跨行与注释">跨行与注释</h2><p>有的时候我们编写的<strong>计算式可能会比较长</strong>，这个时候为了代码和公式的高可阅读性，我们通常采用Fortran语言所提供的跨行功能。比如说如下所示的原打印输出，就可以在<strong>中途使用<code>&amp;</code>符号来声明下一行是前一行的后续</strong>，这样的执行结果是一致的。</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs fortran"><span class="hljs-built_in">print</span> *, zhang, qian, sun, li, zhou, wu, zhen, wang<br><br><span class="hljs-comment">!!! 可以换成</span><br><span class="hljs-built_in">print</span> *, zhang, qian, sun, li &amp;<br>       , zhou, wu, zhen, wang<br></code></pre></td></tr></table></figure><p>上面的例子是变量的跨行输出，如果是一个长字符串，也是可以使用一样的方式的，<strong>只是需要在中断的前一行末尾和下一行开头同时加上<code>&amp;</code> 符号</strong>，如下所示。</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs fortran"><span class="hljs-built_in">print</span> *, <span class="hljs-string">&#x27;Fortran is so good for the scientific calculation.&#x27;</span><br><br><span class="hljs-comment">!!! 可以换成</span><br><span class="hljs-built_in">print</span> *, <span class="hljs-string">&#x27;Fortran is so good &amp;</span><br><span class="hljs-string">          &amp;for the scientific calculation.&#x27;</span><br></code></pre></td></tr></table></figure><p>我们之前在定义变量的时候已经提过，为了代码整洁性可能会同时将同一类型的变量放置在同一行，之间用逗号分割即可。如果是在给变量赋值的时候，是不是也能够将赋值式放置在同一行呢？原则上来说，<strong>如果赋值式比较短的话，是可以将多行赋值式缩短在同一行的</strong>，它们之间使用<code>;</code>进行连接。这里值得注意的是，<strong>最后一个赋值式后面一定不要多加<code>;</code></strong>，如下所示。</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs fortran"><span class="hljs-comment">!!! 修改前</span><br>x = <span class="hljs-number">3</span><br>y = <span class="hljs-number">4</span><br>z = <span class="hljs-number">5</span><br><br><span class="hljs-comment">!!! 修改后</span><br>x = <span class="hljs-number">3</span>; y = <span class="hljs-number">4</span>; z = <span class="hljs-number">5</span><br></code></pre></td></tr></table></figure><p>Fortran语言中的注释其实在上面的内容中也已经接触到了，<strong><code>!</code>之后的内容将会被 Fortran 编译器认为是注释内容</strong>。一般来说，一个<code>!</code>的注释其实就已经足够了，但是为了区分行注释与行末注释，建议在<strong>行注释的时候使用三个<code>!</code></strong>，而在<strong>行末注释时使用一个<code>!</code></strong>。当然如果存在相邻多行同时进行注释，或者在一个可视窗口内有多个行末注释，建议协调成同一列以增强代码整洁性。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Fortran</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++ 多态</title>
    <link href="/2022/05/22/C++/"/>
    <url>/2022/05/22/C++/</url>
    
    <content type="html"><![CDATA[<p>​有了虚函数，基类指针指向基类对象时就使用基类的成员（包括成员函数和成员变量），指向派生类对象时就使用派生类的成员。换句话说，基类指针可以按照基类的方式来做事，也可以按照派生类的方式来做事，它有多种形态，或者说有多种表现方式，我们将这种现象称为<strong>多态（Polymorphism）</strong>。</p><p>​C++提供多态的目的是：可以通过基类指针对所有派生类（包括直接派生和间接派生）的成员变量和成员函数进行“全方位”的访问，尤其是成员函数。如果没有多态，我们只能访问成员变量。</p><p>​除了指针，<strong>引用也可以实现多态</strong>。不过引用不像指针灵活，指针可以随时改变指向，而引用只能指代固定的对象，在多态性方面缺乏表现力，所以以后我们再谈及多态时一般是说指针。</p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
