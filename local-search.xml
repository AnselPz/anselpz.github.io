<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>计算机网络基础3</title>
    <link href="/2022/05/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%803/"/>
    <url>/2022/05/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%803/</url>
    
    <content type="html"><![CDATA[<h3 id="arprarp协议">5. ARP/RARP协议</h3><p><strong>地址解析协议，即ARP（Address ResolutionProtocol），是根据IP地址获取物理地址的一个TCP/IP协议。</strong>主机发送信息时将包含目标IP地址的ARP请求广播到网络上的所有主机，并接收返回消息，以此确定目标的物理地址；收到返回消息后将该IP地址和物理地址存入本机ARP缓存中并保留一定时间，下次请求时直接查询ARP缓存以节约资源。地址解析协议是建立在网络中各个主机互相信任的基础上的，网络上的主机可以自主发送ARP应答消息，其他主机收到应答报文时不会检测该报文的真实性就会将其记入本机ARP缓存；由此攻击者就可以向某一主机发送伪ARP应答报文，使其发送的信息无法到达预期的主机或到达错误的主机，这就构成了一个ARP欺骗。<strong>ARP命令可用于查询本机ARP缓存中IP地址和MAC地址的对应关系、添加或删除静态对应关系等。</strong></p><p>ARP工作流程举例：</p><p><strong>MAC地址由第二层数据链路层负责，MAC地址用于在网络中唯一标识网卡</strong></p><p>主机A的IP地址为192.168.1.1，MAC地址为0A-11-22-33-44-01；</p><p>主机B的IP地址为192.168.1.2，MAC地址为0A-11-22-33-44-02；</p><p>当主机A要与主机B通信时，地址解析协议可以将主机B的IP地址（192.168.1.2）解析成主机B的MAC地址，以下为工作流程：</p><ul><li>（1）根据主机A上的路由表内容，IP确定用于访问主机B的转发IP地址是192.168.1.2。然后A主机在自己的本地ARP缓存中检查主机B的匹配MAC地址。</li><li>（2）如果主机A在ARP缓存中没有找到映射，它将询问192.168.1.2的硬件地址，从而将ARP请求帧广播到本地网络上的所有主机。源主机A的IP地址和MAC地址都包括在ARP请求中。本地网络上的每台主机都接收到ARP请求并且检查是否与自己的IP地址匹配。如果主机发现请求的IP地址与自己的IP地址不匹配，它将丢弃ARP请求。</li><li>（3）主机B确定ARP请求中的IP地址与自己的IP地址匹配，则将主机A的IP地址和MAC地址映射添加到本地ARP缓存中。</li><li>（4）主机B将包含其MAC地址的ARP回复消息直接发送回主机A。</li><li>（5）当主机A收到从主机B发来的ARP回复消息时，会用主机B的IP和MAC地址映射更新ARP缓存。本机缓存是有生存期的，生存期结束后，将再次重复上面的过程。主机B的MAC地址一旦确定，主机A就能向主机B发送IP通信了。</li></ul><p><strong>逆地址解析协议，即RARP，功能和ARP协议相对，其将局域网中某个主机的物理地址转换为IP地址</strong></p><p>，比如局域网中有一台主机只知道物理地址而不知道IP地址，那么可以通过RARP协议发出征求自身IP地址的广播请求，然后由RARP服务器负责回答。</p><p>RARP协议工作流程：</p><ul><li>（1）给主机发送一个本地的RARP广播，在此广播包中，声明自己的MAC地址并且请求任何收到此请求的RARP服务器分配一个IP地址；</li><li>（2）本地网段上的RARP服务器收到此请求后，检查其RARP列表，查找该MAC地址对应的IP地址；</li><li>（3）如果存在，RARP服务器就给源主机发送一个响应数据包并将此IP地址提供给对方主机使用；</li><li>（4）如果不存在，RARP服务器对此不做任何的响应；</li></ul><h3 id="路由选择协议">6. 路由选择协议</h3><p>常见的路由选择协议有：RIP协议、OSPF协议。</p><p><strong>RIP协议</strong>：底层是贝尔曼福特算法，它选择路由的度量标准（metric)是跳数，最大跳数是15跳，如果大于15跳，它就会丢弃数据包。</p><p><strong>OSPF协议</strong> ：Open Shortest PathFirst开放式最短路径优先，底层是迪杰斯特拉算法，是链路状态路由选择协议，它选择路由的度量标准是带宽，延迟。</p><h3 id="tcpip协议">7. TCP/IP协议</h3><p><strong>TCP/IP协议是Internet最基本的协议、Internet国际互联网络的基础，由网络层的IP协议和传输层的TCP协议组成。通俗而言：TCP负责发现传输的问题，一有问题就发出信号，要求重新传输，直到所有数据安全正确地传输到目的地。而IP是给因特网的每一台联网设备规定一个地址。</strong></p><p>IP层接收由更低层（网络接口层例如以太网设备驱动程序）发来的数据包，并把该数据包发送到更高层---TCP或UDP层；相反，IP层也把从TCP或UDP层接收来的数据包传送到更低层。IP数据包是不可靠的，因为IP并没有做任何事情来确认数据包是否按顺序发送的或者有没有被破坏，IP数据包中含有发送它的主机的地址（源地址）和接收它的主机的地址（目的地址）。</p><p>TCP是面向连接的通信协议，通过三次握手建立连接，通讯完成时要拆除连接，由于TCP是面向连接的所以只能用于端到端的通讯。TCP提供的是一种可靠的数据流服务，采用"带重传的肯定确认"技术来实现传输的可靠性。TCP还采用一种称为"滑动窗口"的方式进行流量控制，所谓窗口实际表示接收能力，用以限制发送方的发送速度。</p><p><strong>TCP报文首部格式：</strong></p><figure><imgsrc="https://www.runoob.com/wp-content/uploads/2018/09/1538030297-3779-20150904110054856-961661137.png"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p><strong>TCP协议的三次握手和四次挥手：</strong></p><figure><imgsrc="https://www.runoob.com/wp-content/uploads/2018/09/1538030297-7824-20150904110008388-1768388886.gif"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>　　<strong>注：seq</strong>:"sequance"序列号；<strong>ack</strong>:"acknowledge"确认号；<strong>SYN</strong>:"synchronize"请求同步标志；<strong>；ACK</strong>:"acknowledge"确认标志"<strong>；FIN</strong>："Finally"结束标志。</p><p><strong>TCP连接建立过程：</strong>首先Client端发送连接请求报文，Server段接受连接后回复ACK报文，并为这次连接分配资源。Client端接收到ACK报文后也向Server段发生ACK报文，并分配资源，这样TCP连接就建立了。</p><p><strong>TCP连接断开过程：</strong>假设Client端发起中断连接请求，也就是发送FIN报文。Server端接到FIN报文后，意思是说"我Client端没有数据要发给你了"，但是如果你还有数据没有发送完成，则不必急着关闭Socket，可以继续发送数据。所以你先发送ACK，"告诉Client端，你的请求我收到了，但是我还没准备好，请继续你等我的消息"。这个时候Client端就进入FIN_WAIT状态，继续等待Server端的FIN报文。当Server端确定数据已发送完成，则向Client端发送FIN报文，"告诉Client端，好了，我这边数据发完了，准备好关闭连接了"。Client端收到FIN报文后，"就知道可以关闭连接了，但是他还是不相信网络，怕Server端不知道要关闭，所以发送ACK后进入TIME_WAIT状态，如果Server端没有收到ACK则可以重传。"，Server端收到ACK后，"就知道可以断开连接了"。Client端等待了2MSL后依然没有收到回复，则证明Server端已正常关闭，那好，我Client端也可以关闭连接了。Ok，TCP连接就这样关闭了！</p><p><strong>为什么要三次握手？</strong></p><p>在只有两次"握手"的情形下，假设Client想跟Server建立连接，但是却因为中途连接请求的数据报丢失了，故Client端不得不重新发送一遍；这个时候Server端仅收到一个连接请求，因此可以正常的建立连接。但是，有时候Client端重新发送请求不是因为数据报丢失了，而是有可能数据传输过程因为网络并发量很大在某结点被阻塞了，这种情形下Server端将先后收到2次请求，并持续等待两个Client请求向他发送数据...问题就在这里，Cient端实际上只有一次请求，而Server端却有2个响应，极端的情况可能由于Client端多次重新发送请求数据而导致Server端最后建立了N多个响应在等待，因而造成极大的资源浪费！所以，"三次握手"很有必要！</p><p><strong>为什么要四次挥手？</strong></p><p>试想一下，假如现在你是客户端你想断开跟Server的所有连接该怎么做？第一步，你自己先停止向Server端发送数据，并等待Server的回复。但事情还没有完，虽然你自身不往Server发送数据了，但是因为你们之前已经建立好平等的连接了，所以此时他也有主动权向你发送数据；故Server端还得终止主动向你发送数据，并等待你的确认。其实，说白了就是保证双方的一个合约的完整执行！</p><p>使用TCP的协议：FTP（文件传输协议）、Telnet（远程登录协议）、SMTP（简单邮件传输协议）、POP3（和SMTP相对，用于接收邮件）、HTTP协议等。</p><h3 id="udp协议">8. UDP协议</h3><p><strong>UDP用户数据报协议，是面向无连接的通讯协议，UDP数据包括目的端口号和源端口号信息，由于通讯不需要连接，所以可以实现广播发送。</strong></p><p>UDP通讯时不需要接收方确认，属于不可靠的传输，可能会出现丢包现象，实际应用中要求程序员编程验证。</p><p>UDP与TCP位于同一层，但它不管数据包的顺序、错误或重发。因此，UDP不被应用于那些使用虚电路的面向连接的服务，UDP主要用于那些面向查询---应答的服务，例如NFS。相对于FTP或Telnet，这些服务需要交换的信息量较小。</p><p>每个UDP报文分UDP报头和UDP数据区两部分。报头由四个16位长（2字节）字段组成，分别说明该报文的源端口、目的端口、报文长度以及校验值。UDP报头由4个域组成，其中每个域各占用2个字节，具体如下：</p><ul><li>（1）源端口号；</li><li>（2）目标端口号；</li><li>（3）数据报长度；</li><li>（4）校验值。</li></ul><p>使用UDP协议包括：TFTP（简单文件传输协议）、SNMP（简单网络管理协议）、DNS（域名解析协议）、NFS（文件共享协议）、BOOTP（引导程序协议，是DHCP协议前身）。</p><p><strong>TCP</strong> <strong>与</strong> <strong>UDP</strong><strong>的区别：</strong>TCP是面向连接的，可靠的字节流服务；UDP是面向无连接的，不可靠的数据报服务。</p><h3 id="dns协议">9. DNS协议</h3><p>DNS是域名系统(DomainNameSystem)的缩写，该系统用于命名组织到域层次结构中的计算机和网络服务，<strong>可以简单地理解为将URL转换为IP地址</strong>。域名是由圆点分开一串单词或缩写组成的，<strong>每一个域名都对应一个惟一的IP地址</strong>，<strong>域名可以说是一个IP地址的代称，目的是为了更好的记忆IP地址。</strong>在Internet上域名与IP地址之间是一一对应的，DNS就是进行域名解析的服务器。DNS命名用于Internet等TCP/IP网络中，通过用户友好的名称查找计算机和服务。</p><h3 id="nat协议">10. NAT协议</h3><p>　　NAT网络地址转换(Network AddressTranslation)属接入广域网(WAN)技术，是一种<strong>将私有（保留）地址转化为合法IP地址的转换技术</strong>，它被广泛应用于各种类型Internet接入方式和各种类型的网络中。原因很简单，NAT不仅完美地解决了lP地址不足的问题，而且还能够有效地避免来自网络外部的攻击，隐藏并保护网络内部的计算机。</p><h3 id="dhcp协议">11. DHCP协议</h3><p>DHCP动态主机设置协议（Dynamic Host ConfigurationProtocol）是一个局域网的网络协议，使用UDP协议工作，主要有两个用途：给内部网络或网络服务供应商自动分配IP地址，给用户或者内部网络管理员作为对所有计算机作中央管理的手段。</p><h3 id="http协议">12. HTTP协议</h3><p>超文本传输协议（HTTP，HyperText TransferProtocol)是互联网上应用最为广泛的一种网络协议。所有的WWW文件都必须遵守这个标准。　　<strong>HTTP</strong><strong>协议包括哪些请求？</strong></p><p>GET：请求读取由URL所标志的信息。</p><p>POST：给服务器添加信息（如注释）。</p><p>PUT：在给定的URL下存储一个文档。</p><p>DELETE：删除给定的URL所标志的资源。</p><p>　　<strong>HTTP</strong> <strong>中，</strong> <strong>POST</strong><strong>与</strong> <strong>GET</strong> <strong>的区别</strong></p><ul><li><p>1）Get是从服务器上获取数据，Post是向服务器传送数据。</p></li><li><p>2）Get是把参数数据队列加到提交表单的Action属性所指向的URL中，值和表单内各个字段一一对应，在URL中可以看到。</p></li><li><p>3）Get传送的数据量小，不能大于2KB；Post传送的数据量较大，一般被默认为不受限制。</p></li><li><p>4）根据HTTP规范，GET用于信息获取，而且应该是安全的和幂等的。</p></li><li><p>I. 所谓 <strong>安全的</strong>意味着该操作用于获取信息而非修改信息。换句话说，GET请求一般不应产生副作用。就是说，它仅仅是获取资源信息，就像数据库查询一样，不会修改，增加数据，不会影响资源的状态。</p></li><li><ol start="2" type="I"><li><strong>幂等</strong>的意味着对同一URL的多个请求应该返回同样的结果。</li></ol></li></ul><h3 id="一个举例">13. 一个举例</h3><p>在浏览器中输入 <strong>http://www.baidu.com/</strong>后执行的全部过程。</p><p>现在假设如果我们在客户端（客户端）浏览器中输入 http://www.baidu.com，而 baidu.com为要访问的服务器（服务器），下面详细分析客户端为了访问服务器而执行的一系列关于协议的操作：</p><ul><li>1）客户端浏览器通过DNS解析到www.baidu.com的IP地址220.181.27.48，通过这个IP地址找到客户端到服务器的路径。客户端浏览器发起一个HTTP会话到220.161.27.48，然后通过TCP进行封装数据包，输入到网络层。</li><li>2）在客户端的传输层，把HTTP会话请求分成报文段，添加源和目的端口，如服务器使用80端口监听客户端的请求，客户端由系统随机选择一个端口如5000，与服务器进行交换，服务器把相应的请求返回给客户端的5000端口。然后使用IP层的IP地址查找目的端。</li><li>3）客户端的网络层不用关系应用层或者传输层的东西，主要做的是通过查找路由表确定如何到达服务器，期间可能经过多个路由器，这些都是由路由器来完成的工作，不作过多的描述，无非就是通过查找路由表决定通过那个路径到达服务器。</li><li>4）客户端的链路层，包通过链路层发送到路由器，通过邻居协议查找给定IP地址的MAC地址，然后发送ARP请求查找目的地址，如果得到回应后就可以使用ARP的请求应答交换的IP数据包现在就可以传输了，然后发送IP数据包到达服务器的地址。</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机网络基础2</title>
    <link href="/2022/05/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%802/"/>
    <url>/2022/05/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%802/</url>
    
    <content type="html"><![CDATA[<h3 id="ip地址">3. IP地址</h3><p><strong>1）网络地址</strong></p><p>IP地址由<strong>网络号（包括子网号）</strong>和<strong>主机号</strong>组成，IP地址由4段组成，每个字段是一个字节，即4个字节。最大值255。网络地址的主机号为<strong>全0</strong>，网络地址代表着整个网络。</p><p><strong>2）广播地址</strong></p><p>广播地址通常称为<strong>直接广播地址</strong>，是为了区分受限广播地址。</p><p>广播地址与网络地址的主机号正好相反，广播地址中，主机号为<strong>全1</strong>。当向某个网络的广播地址发送消息时，该网络内的所有主机都能收到该广播消息。</p><p><strong>3）组播地址</strong></p><p>D类地址就是组播地址。</p><p>先回忆下A，B，C，D类地址吧：</p><p>A类地址以0开头，<strong>第一个字节</strong>作为网络号，地址范围为：0.0.0.0~127.255.255.255；(<strong>modified<span class="citation"data-cites="2016.05.31">@2016.05.31</span></strong>)</p><p>B类地址以10开头，<strong>前两个字节</strong>作为网络号，地址范围是：128.0.0.0~191.255.255.255;</p><p>C类地址以110开头，<strong>前三个字节</strong>作为网络号，地址范围是：192.0.0.0~223.255.255.255。</p><p>D类地址以1110开头，地址范围是224.0.0.0~239.255.255.255，D类地址作为组播地址（一对多的通信）；</p><p>E类地址以1111开头，地址范围是240.0.0.0~255.255.255.255，E类地址为保留地址，供以后使用。</p><p>注：只有A,B,C有网络号和主机号之分，D类地址和E类地址没有划分网络号和主机号。</p><p><strong>4）255.255.255.255</strong></p><p>该IP地址指的是<strong>受限的广播地址</strong>。受限广播地址与一般广播地址（直接广播地址）的区别在于，受限广播地址只能用于本地网络，路由器不会转发以受限广播地址为目的地址的分组；一般广播地址既可在本地广播，也可跨网段广播。例如：主机192.168.1.1/30上的直接广播数据包后，另外一个网段192.168.1.5/30也能收到该数据报；若发送受限广播数据报，则不能收到。</p><p>注：一般的广播地址（直接广播地址）能够通过某些路由器（当然不是所有的路由器），而受限的广播地址不能通过路由器。</p><p><strong>5）0.0.0.0</strong></p><p>常用于寻找自己的IP地址，例如在我们的RARP，BOOTP和DHCP协议中，若某个未知IP地址的无盘机想要知道自己的IP地址，它就以255.255.255.255为目的地址，向本地范围（具体而言是被各个路由器屏蔽的范围内）的服务器发送IP请求分组。</p><p><strong>6）回环地址</strong></p><p>127.0.0.0/8被用作回环地址，回环地址表示本机的地址，常用于对本机的测试，用的最多的是127.0.0.1。</p><p><strong>7）A、B、C类私有地址</strong></p><p>私有地址(privateaddress)也叫专用地址，它们不会在全球使用，只具有本地意义。</p><p>A类私有地址：10.0.0.0<strong>/8</strong>，范围是：10.0.0.0~10.255.255.255（10.0.0.0/8说明他的子网掩码是255.0.0.0）</p><p>B类私有地址：172.16.0.0/12，范围是：172.16.0.0~172.31.255.255</p><p>C类私有地址：192.168.0.0/16，范围是：192.168.0.0~192.168.255.255</p><h3 id="子网掩码及网络划分">4. 子网掩码及网络划分</h3><p>随着互连网应用的不断扩大，原先的IPv4的弊端也逐渐暴露出来，即网络号占位太多，而主机号位太少，所以其能提供的主机地址也越来越稀缺，目前除了使用NAT在企业内部利用保留地址自行分配以外，通常都<strong>对一个高类别的IP地址进行再划分，以形成多个子网</strong>，提供给不同规模的用户群使用。</p><p>这里主要是为了在网络分段情况下有效地利用IP地址，通过对主机号的高位部分取作为子网号，从通常的网络位界限中扩展或压缩子网掩码，用来创建某类地址的更多子网。但创建更多的子网时，在每个子网上的可用主机地址数目会比原先减少。</p><p><strong>什么是子网掩码？</strong></p><p>子网掩码是<strong>标志两个IP地址是否同属于一个子网的</strong>，也是32位二进制地址，其每一个为1代表该位是网络位，为0代表主机位。它和IP地址一样也是使用<strong>点式十进制</strong>来表示的。如果两个IP地址在子网掩码的<strong>按位与</strong>的计算下所得结果相同，即表明它们共属于同一子网中。</p><p><strong>在计算子网掩码时，我们要注意IP地址中的保留地址，即"0"地址和广播地址，它们是指主机地址或网络地址全为" 0"或"1"时的IP地址，它们代表着本网络地址和广播地址，一般是不能被计算在内的。</strong></p><p><strong>子网掩码的计算：</strong></p><p>对于<strong>无须再划分成子网的IP地址来说，其子网掩码非常简单</strong>，即按照其定义即可写出：如某B类IP地址为10.12.3.0，无须再分割子网，则该IP地址的子网掩码255.255.0.0。如果它是一个C类地址，则其子网掩码为255.255.255.0。其它类推，不再详述。下面我们关键要介绍的是一个IP地址，还需要将其高位主机位再作为划分出的子网网络号，剩下的是每个子网的主机号，这时该如何进行每个子网的掩码计算。</p><p>下面总结一下有关子网掩码和网络划分常见的面试考题：</p><p><strong>1）利用子网数来计算</strong></p><p>在求子网掩码之前必须先搞清楚要划分的子网数目，以及每个子网内的所需主机数目。</p><ol type="1"><li>将子网数目转化为二进制来表示;</li></ol><p>如欲将B类IP地址168.195.0.0划分成27个子网：27=11011；</p><ol start="2" type="1"><li>取得该二进制的位数，为N；</li></ol><p>该二进制为五位数，N = 5</p><ol start="3" type="1"><li>取得该IP地址的<strong>类子网掩码</strong>，将其主机地址部分的的<strong>前N位置1</strong>即得出该IP地址划分子网的子网掩码。</li></ol><p>将B类地址的子网掩码255.255.0.0的主机地址前5位置 1，得到255.255.248.0</p><p><strong>2）利用主机数来计算</strong></p><p>如欲将B类IP地址168.195.0.0划分成若干子网，每个子网内有主机700台：</p><ol type="1"><li>将主机数目转化为二进制来表示；</li></ol><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">700</span>=<span class="hljs-number">1010111100</span><br></code></pre></td></tr></table></figure><ol start="2" type="1"><li>如果主机数小于或等于254（注意去掉保留的两个IP地址），则取得该主机的二进制位数，为N，这里肯定N&lt;8。如果大于254，则 N&gt;8，这就是说主机地址将占据不止8位；</li></ol><p>该二进制为十位数，N=10；</p><ol start="3" type="1"><li>使用255.255.255.255来将该类IP地址的主机地址位数全部置1，然后<strong>从后向前</strong>的将N位全部置为0，即为<strong>子网掩码值</strong>。</li></ol><p>将该B类地址的子网掩码255.255.0.0的主机地址全部置1，得到255.255.255.255，然后再从后向前将后10位置0,即为：11111111.11111111.11111100.00000000，即255.255.252.0。这就是该欲划分成主机为700台的B类IP地址168.195.0.0的子网掩码。</p><p><strong>3）还有一种题型，要你根据每个网络的主机数量进行子网地址的规划和计算子网掩码。这也可按上述原则进行计算。</strong></p><p>比如一个子网有10台主机，那么对于这个子网需要的IP地址是：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">10</span>＋<span class="hljs-number">1</span>＋<span class="hljs-number">1</span>＋<span class="hljs-number">1</span>＝<span class="hljs-number">13</span><br></code></pre></td></tr></table></figure><p><strong>注意：加的第一个1是指这个网络连接时所需的网关地址，接着的两个1分别是指网络地址和广播地址。</strong></p><p>因为13小于16（16等于2的4次方），所以主机位为4位。而256－16＝240，所以该子网掩码为255.255.255.240。</p><p>如果一个子网有14台主机，不少人常犯的错误是：依然分配具有16个地址空间的子网，而<strong>忘记了给网关分配地址</strong>。这样就错误了，因为14＋1＋1＋1＝17，17大于16，所以我们只能分配具有32个地址（32等于2的5次方）空间的子网。这时子网掩码为：255.255.255.224。</p>]]></content>
    
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机网络基础1</title>
    <link href="/2022/05/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%801/"/>
    <url>/2022/05/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%801/</url>
    
    <content type="html"><![CDATA[<p>计算机网络的核心内容就是<strong>网络协议</strong>的学习。</p><p>网络协议是问计算机网络中进行数据交换而建立的规则、标准或者说是约定的集合。因为不同用户的数据终端可能采集的字符集是不同的，两者需要通信，必须要在一定的标准上进行。目前TCP/IP协议已经成为Internet的“通用语言”。</p><h3 id="网络层次划分">1.网络层次划分</h3><p>为了使不同计算机厂家生产的计算机能够相互通信，以便在更大的范围内建立计算机网络，国际标准化组织（ISO）在1978年提出了"开放系统互联参考模型"，即著名的OSI/RM模型（OpenSystem Interconnection/ReferenceModel）。它将计算机网络体系结构的通信协议划分为七层，自下而上依次为：物理层（PhysicsLayer）、数据链路层（Data Link Layer）、网络层（NetworkLayer）、传输层（Transport Layer）、会话层（SessionLayer）、表示层（Presentation Layer）、应用层（ApplicationLayer）。其中第四层完成数据传送服务，上面三层面向用户。</p><p>除了标准的OSI七层模型以外，常见的网络层次划分还有TCP/IP四层协议以及TCP/IP五层协议。</p><figure><imgsrc="https://www.runoob.com/wp-content/uploads/2018/09/1538030296-7490-20150904094019903-1923900106.jpg"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><h3 id="osi七层网络模型">2.OSI七层网络模型</h3><p>TCP/IP协议是互联网的基础协议。不管是管是OSI七层模型还是TCP/IP的四层、五层模型，每一层都要有自己的专属协议，完成自己相应的工作以及与上下层级之间进行沟通。</p><figure><imgsrc="https://www.runoob.com/wp-content/uploads/2018/09/1538030296-8668-20150904095142060-1017190812.gif"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p><strong>1）物理层（Physical Layer）</strong></p><p>激活、维持、关闭通信端点之间的机械特性、电气特性、功能特性以及过程特性。<strong>该层为上层协议提供了一个传输数据的可靠的物理媒体。简单的说，物理层确保原始的数据可在各种物理媒体上传输。</strong>物理层记住两个重要的设备名称，==中继器（Repeater，也叫放大器）==和==集线器==。</p><p><strong>2）数据链路层（Data Link Layer）</strong></p><p>数据链路层在物理层提供的服务的基础上向网络层提供服务，其最基本的服务是将源自网络层来的数据可靠地传输到相邻节点的目标机网络层。为达到这一目的，数据链路必须具备一系列相应的功能，主要有：如何将数据组合成数据块，在数据链路层中称这种数据块为<strong>帧（frame）</strong>，帧是数据链路层的传送单位；如何控制帧在物理信道上的传输，包括如何处理传输差错，如何调节发送速率以使与接收方相匹配；以及在两个网络实体之间提供数据链路通路的建立、维持和释放的管理。数据链路层在不可靠的物理介质上提供可靠的传输。该层的作用包括：物理地址寻址、数据的成帧、流量控制、数据的检错、重发等。</p><p>有关数据链路层的重要知识点：</p><ul><li><strong>1&gt; 数据链路层为网络层提供可靠的数据传输；</strong></li><li>　　<strong>2&gt; 基本数据单位为帧；</strong></li><li>　　<strong>3&gt; 主要的协议：以太网协议；</strong></li><li>　　<strong>4&gt; 两个重要设备名称：网桥和交换机。</strong></li></ul><p><strong>3）网络层（Network Layer）</strong></p><p>网络层的目的是<strong>实现两个端系统之间的数据透明传送</strong>，具体功能包括寻址和路由选择、连接的建立、保持和终止等。它提供的服务使传输层不需要了解网络中的数据传输和交换技术。如果您想用尽量少的词来记住网络层，那就是<strong>"路径选择、路由及逻辑寻址"</strong>。</p><p>网络层中涉及众多的协议，其中包括最重要的协议，也是TCP/IP的核心协议——IP协议。IP协议非常简单，仅仅提供不可靠、无连接的传送服务。IP协议的主要功能有：无连接数据报传输、数据报路由选择和差错控制。与IP协议配套使用实现其功能的还有地址解析协议ARP、逆地址解析协议RARP、因特网报文协议ICMP、因特网组管理协议IGMP。具体的协议我们会在接下来的部分进行总结，有关网络层的重点为：</p><ul><li>　　<strong>1&gt;网络层负责对子网间的数据包进行路由选择。此外，网络层还可以实现拥塞控制、网际互连等功能；</strong></li><li>　　<strong>2&gt; 基本数据单位为IP数据报；</strong></li><li>　　<strong>3&gt; 包含的主要协议：</strong></li><li>　　<strong>IP协议（InternetProtocol，因特网互联协议）;</strong></li><li>　　<strong>ICMP协议（Internet Control MessageProtocol，因特网控制报文协议）;</strong></li><li>　　<strong>ARP协议（Address ResolutionProtocol，地址解析协议）;</strong></li><li>　　<strong>RARP协议（Reverse Address ResolutionProtocol，逆地址解析协议）。</strong></li><li>　　<strong>4&gt; 重要的设备：路由器。</strong></li></ul><p><strong>4）传输层（Transport Layer）</strong></p><p>第一个端到端，即主机到主机的层次。传输层负责将上层数据分段并提供端到端的、可靠的或不可靠的传输。此外，传输层还要处理端到端的差错控制和流量控制问题。传输层的任务是根据通信子网的特性，最佳的利用网络资源，为两个端系统的会话层之间，提供建立、维护和取消传输连接的功能，负责端到端的可靠数据传输。在这一层，信息传送的协议数据单元称为<strong>段或报文</strong>。网络层只是根据网络地址将源结点发出的数据包传送到目的结点，而传输层则负责将数据可靠地传送到相应的端口。有关网络层的重点：</p><ul><li><strong>1&gt;传输层负责将上层数据分段并提供端到端的、可靠的或不可靠的传输以及端到端的差错控制和流量控制问题；</strong></li><li><strong>2&gt; 包含的主要协议：TCP协议（Transmission ControlProtocol，传输控制协议）、UDP协议（User DatagramProtocol，用户数据报协议）；</strong></li><li><strong>3&gt; 重要设备：网关。</strong></li></ul><p><strong>5）会话层</strong></p><p>会话层管理主机之间的会话进程，即负责建立、管理、终止进程之间的会话。会话层还利用在数据中插入校验点来实现数据的同步。</p><p><strong>6）表示层</strong></p><p>表示层对上层数据或信息进行变换以保证一个主机应用层信息可以被另一个主机的应用程序理解。表示层的数据转换包括数据的加密、压缩、格式转换等。</p><p><strong>7）应用层</strong></p><p>为操作系统或网络应用程序提供访问网络服务的接口。</p><p>会话层、表示层和应用层重点：</p><ul><li><strong>1&gt; 数据传输基本单位为报文；</strong></li><li><strong>2&gt;包含的主要协议：FTP（文件传送协议）、Telnet（远程登录协议）、DNS（域名解析协议）、SMTP（邮件传送协议），POP3协议（邮局协议），HTTP协议（HyperText Transfer Protocol）。</strong></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>计算机基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>搭建ftp服务器小结</title>
    <link href="/2022/05/27/%E6%90%AD%E5%BB%BAftp%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%B0%8F%E7%BB%93/"/>
    <url>/2022/05/27/%E6%90%AD%E5%BB%BAftp%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%B0%8F%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h2 id="背景信息">背景信息</h2><p>FTP（File TransferProtocol）是一种文件传输协议，基于客户端/服务器架构，支持以下两种工作模式：</p><ul><li>主动模式：客户端向FTP服务器发送端口信息，由服务器主动连接该端口。</li><li>被动模式：FTP服务器开启并发送端口信息给客户端，由客户端连接该端口，服务器被动接受连接。</li></ul><p><strong>说明</strong>大多数FTP客户端都在局域网中，没有独立的公网IP地址，且有防火墙阻拦，主动模式下FTP服务器成功连接到客户端比较困难。因此，如无特殊需求，建议您将FTP服务器配置为被动模式。</p><p>FTP支持以下三种认证模式：</p><ul><li>匿名用户模式：任何人无需密码验证就可以直接登录到FTP服务器。这种模式最不安全，一般只用来保存不重要的公开文件，不推荐在生产环境中使用。</li><li>本地用户模式：通过Linux系统本地账号进行验证的模式，相较于匿名用户模式更安全。</li><li>虚拟用户模式：FTP服务器的专有用户。虚拟用户只能访问Linux系统为其提供的FTP服务，而不能访问Linux系统的其它资源，进一步增强了FTP服务器的安全性。</li></ul><p>本文主要介绍被动模式下，使用本地用户访问FTP服务器的配置方法。</p><p>1.修改vsftpd.conf配置文件</p><ol type="1"><li><p>运行以下命令，打开vsftpd的配置文件。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">vim /etc/vsftpd/vsftpd.conf<br></code></pre></td></tr></table></figure></li><li><p>按i进入编辑模式。</p></li><li><p>配置FTP服务器为被动模式。</p><p>具体的配置参数说明如下：</p><p><strong>注意</strong>修改和添加配置文件内的信息时，请注意格式问题。例如，==添加多余的空格会造成无法重启服务的结果==。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#除下面提及的参数，其他参数保持默认值即可。</span><br><br><span class="hljs-comment">#修改下列参数的值：</span><br><span class="hljs-comment">#禁止匿名登录FTP服务器。</span><br>anonymous_enable=NO<br><span class="hljs-comment">#允许本地用户登录FTP服务器。</span><br>local_enable=YES<br><span class="hljs-comment">#监听IPv4 sockets。</span><br>listen=YES<br><br><span class="hljs-comment">#在行首添加#注释掉以下参数：</span><br><span class="hljs-comment">#关闭监听IPv6 sockets。</span><br><span class="hljs-comment">#listen_ipv6=YES</span><br><br><span class="hljs-comment">#在配置文件的末尾添加下列参数：</span><br><span class="hljs-comment">#设置本地用户登录后所在目录。如需修改共享文件夹，修改目录即可</span><br>local_root=/var/ftp/test<br><span class="hljs-comment">#全部用户被限制在主目录。</span><br>chroot_local_user=YES<br><span class="hljs-comment">#启用例外用户名单。</span><br>chroot_list_enable=YES<br><span class="hljs-comment">#指定例外用户列表文件，列表中用户不被锁定在主目录。</span><br>chroot_list_file=/etc/vsftpd/chroot_list<br><span class="hljs-comment">#开启被动模式。</span><br>pasv_enable=YES<br>allow_writeable_chroot=YES<br><span class="hljs-comment">#本教程中为Linux实例的公网IP。</span><br>pasv_address=&lt;FTP服务器公网IP地址&gt;<br><span class="hljs-comment">#设置被动模式下，建立数据传输可使用的端口范围的最小值。</span><br><span class="hljs-comment">#建议您把端口范围设置在一段比较高的范围内，例如50000~50010，有助于提高访问FTP服务器的安全性。</span><br>pasv_min_port=&lt;port number&gt;<br><span class="hljs-comment">#设置被动模式下，建立数据传输可使用的端口范围的最大值。</span><br>pasv_max_port=&lt;port number&gt;<br></code></pre></td></tr></table></figure><p>更多参数的详细信息，请参见<ahref="https://help.aliyun.com/document_detail/92048.htm#section-t9a-ors-44c">vsftp配置文件及参数说明</a>。</p><p>4.修改完，保存退出vim。运行以下命令重启vsftpd服务即可。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs undefined">systemctl restart vsftpd.service<br></code></pre></td></tr></table></figure></li></ol><h2 id="vsftp配置文件及参数说明">vsftp配置文件及参数说明</h2><p>/etc/vsftpd目录下文件说明如下：</p><ul><li>/etc/vsftpd/vsftpd.conf是vsftpd的核心配置文件。</li><li>/etc/vsftpd/ftpusers是黑名单文件，此文件中的用户不允许访问FTP服务器。</li><li>/etc/vsftpd/user_list是白名单文件，此文件中的用户允许访问FTP服务器。</li></ul><p>配置文件vsftpd.conf参数说明如下：</p><ul><li><p>用户登录控制参数说明如下表所示。</p><table><thead><tr class="header"><th style="text-align: left;">参数</th><th style="text-align: left;">说明</th></tr></thead><tbody><tr class="odd"><td style="text-align: left;">anonymous_enable=YES</td><td style="text-align: left;">接受匿名用户</td></tr><tr class="even"><td style="text-align: left;">no_anon_password=YES</td><td style="text-align: left;">匿名用户login时不询问口令</td></tr><tr class="odd"><td style="text-align: left;">anon_root=（none）</td><td style="text-align: left;">匿名用户主目录</td></tr><tr class="even"><td style="text-align: left;">local_enable=YES</td><td style="text-align: left;">接受本地用户</td></tr><tr class="odd"><td style="text-align: left;">local_root=（none）</td><td style="text-align: left;">本地用户主目录</td></tr></tbody></table></li><li><p>用户权限控制参数说明如下表所示。</p><table><thead><tr class="header"><th style="text-align: left;">参数</th><th style="text-align: left;">说明</th></tr></thead><tbody><tr class="odd"><td style="text-align: left;">write_enable=YES</td><td style="text-align: left;">可以上传文件（全局控制）</td></tr><tr class="even"><td style="text-align: left;">local_umask=022</td><td style="text-align: left;">本地用户上传的文件权限</td></tr><tr class="odd"><td style="text-align: left;">file_open_mode=0666</td><td style="text-align: left;">上传文件的权限配合umask使用</td></tr><tr class="even"><td style="text-align: left;">anon_upload_enable=NO</td><td style="text-align: left;">匿名用户可以上传文件</td></tr><tr class="odd"><td style="text-align: left;">anon_mkdir_write_enable=NO</td><td style="text-align: left;">匿名用户可以建目录</td></tr><tr class="even"><td style="text-align: left;">anon_other_write_enable=NO</td><td style="text-align: left;">匿名用户修改删除</td></tr><tr class="odd"><td style="text-align: left;">chown_username=lightwiter</td><td style="text-align: left;">匿名上传文件所属用户名</td></tr></tbody></table></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>ftp 协议</title>
    <link href="/2022/05/26/ftp-%E5%8D%8F%E8%AE%AE/"/>
    <url>/2022/05/26/ftp-%E5%8D%8F%E8%AE%AE/</url>
    
    <content type="html"><![CDATA[<p>FTP（File TransferProtocol）是一种文件传输协议，基于客户端/服务器架构，支持以下两种工作模式：</p><ul><li>主动模式（PORT）：客户端向FTP服务器发送端口信息，由服务器主动连接该端口。</li><li>被动模式（PASV）：FTP服务器开启并发送端口信息给客户端，由客户端连接该端口，服务器被动接受连接。</li></ul><p>FTP支持以下三种认证模式：</p><ul><li>匿名用户模式：任何人无需密码验证就可以直接登录FTP服务器。该模式不安全，一般只用来传输不重要的公开文件，不推荐在生产环境中使用。</li><li>本地用户模式：通过Linux系统本地用户验证登录权限，相较于匿名用户模式更安全。</li><li>虚拟用户模式：通过虚拟用户验证登录权限，虚拟用户只能访问Linux系统为其提供的FTP服务，而不能访问Linux系统的其它资源。该模式相较于其他两种模式更加安全，如果您对服务器的数据有较高的安全性要求，建议在相关专业人员的指导下，自行配置该模式。</li></ul><p>本文主要介绍配置简单的匿名用户模式以及较为安全的本地用户模式。</p><h2 id="步骤一准备工作">步骤一：准备工作</h2><p>本文将使用FTP客户端工具FileZilla连接FTP服务器，因此您需要完成以下准备工作：</p><ol type="1"><li><p>在本地主机上，下载并安装FileZilla。</p><p>具体下载地址，请参见<ahref="https://www.filezilla.cn/download">FileZilla下载中心</a>。</p></li><li><p>重置Linux服务器的</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">root</span><br></code></pre></td></tr></table></figure><p>用户的密码。</p><p>具体操作，请参见<ahref="https://help.aliyun.com/document_detail/60055.htm#task305">管理服务器密码</a>。</p></li></ol><h2 id="步骤二安装与配置vsftpd">步骤二：安装与配置vsftpd</h2><ol type="1"><li><p>远程连接Linux服务器。</p><p>具体操作，请参见<ahref="https://help.aliyun.com/document_detail/59083.htm#multiTask1826">远程连接Linux服务器</a>。本示例中，将通过管理控制台远程连接Linux服务器，并切换至<code>root</code>用户进行后续操作。</p><p><strong>说明</strong>通过管理控制台远程连接Linux服务器时，您的身份为普通用户。如果不切换至<code>root</code>用户，运行部分命令时可能出现Error:This command has to be run under the root user.的报错。</p><ol type="1"><li><p>远程连接Linux服务器后，运行以下命令，切换至<code>root</code>用户。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs undefined">sudo su root<br></code></pre></td></tr></table></figure></li><li><p>运行以下命令，返回至<code>root</code>用户的根目录。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span><br></code></pre></td></tr></table></figure><p>完整的命令行操作示例如下图所示：<imgsrc="https://help-static-aliyun-doc.aliyuncs.com/assets/img/zh-CN/7683998161/p266415.png"alt="su root" /></p><p><strong>说明</strong>通过以上命令行操作切换至<code>root</code>用户后，如果您需要返回至普通用户，请运行<strong>exit</strong>命令。</p></li></ol></li><li><p>运行以下命令，安装vsftpd。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs undefined">yum install -y vsftpd<br></code></pre></td></tr></table></figure><p>出现如下图所示信息，表示vsftpd安装成功。<imgsrc="https://help-static-aliyun-doc.aliyuncs.com/assets/img/zh-CN/3389188161/p265287.png"alt="轻量-安装ftp" /></p></li><li><p>运行以下命令，设置FTP服务开机自启动。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">systemctl <span class="hljs-built_in">enable</span> vsftpd.service<br></code></pre></td></tr></table></figure></li><li><p>运行以下命令，启动FTP服务。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">systemctl <span class="hljs-keyword">start</span> vsftpd.service<br></code></pre></td></tr></table></figure></li><li><p>运行以下命令，查看FTP服务的端口号。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs undefined">netstat -antup | grep ftp<br></code></pre></td></tr></table></figure><p>如下图所示，可查看到FTP服务的端口号，表示服务已正常启动。<imgsrc="https://help-static-aliyun-doc.aliyuncs.com/assets/img/zh-CN/7683998161/p265294.png"alt="轻量-FTP状态" /></p></li></ol><h2id="步骤三设置ftp服务器的访问模式">步骤三：设置FTP服务器的访问模式</h2><p>您可以选择以下任一方式设置FTP服务器，建议您使用更加安全的本地用户模式。</p><ul><li><p>匿名访问模式：</p><ol type="1"><li><p>运行以下命令，修改配置文件</p><p>/etc/vsftpd/vsftpd.conf</p><p>。</p><p>如果您在安装vsftpd时，使用的是<strong>apt installvsftpd</strong>安装命令，则配置文件路径为/etc/vsftpd.conf。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">vim /etc/vsftpd/vsftpd.conf<br></code></pre></td></tr></table></figure></li><li><p>按i进入编辑模式。</p></li><li><p>分别找到匿名模式（</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">anonymous_enable</span><br></code></pre></td></tr></table></figure><p>）以及匿名上传权限（</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">anon_upload_enable</span><br></code></pre></td></tr></table></figure><p>），并确认已修改为开启状态。</p><p>不同操作系统版本中，默认的配置文件信息可能有所不同，您需要保证修改后的参数配置，如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs objectc">anonymous_enable=YES<br>anon_upload_enable=YES<br></code></pre></td></tr></table></figure></li><li><p>在文件的末尾，新增以下参数。</p><p><strong>注意</strong>复制以下参数，然后粘贴至Linux服务器的配置文件时，请注意参数不要被<code>#</code>号注释掉。同时，请注意格式问题。例如，添加多余的空格会造成无法重启服务的结果。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#开启被动模式。</span><br>pasv_enable=YES<br><span class="hljs-comment">#设置被动模式下，建立数据传输可使用的端口范围的最小值。</span><br><span class="hljs-comment">#建议您把端口范围设置在一段比较高的范围内，例如50000~50010，有助于提高访问FTP服务器的安全性。</span><br>pasv_min_port=&lt;port number&gt;<br><span class="hljs-comment">#设置被动模式下，建立数据传输可使用的端口范围的最大值。</span><br>pasv_max_port=&lt;port number&gt;<br></code></pre></td></tr></table></figure></li><li><p>按Esc退出编辑模式，然后输入<code>:wq</code>并回车，保存退出文件。</p></li><li><p>运行以下命令，更改</p><p>/var/ftp/pub</p><p>目录的权限，为FTP用户添加写权限。</p><p>/var/ftp/pub为FTP服务默认的文件目录。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">chmod</span> o+w /var/ftp/pub/<br></code></pre></td></tr></table></figure></li><li><p>运行以下命令，重启FTP服务。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs undefined">systemctl restart vsftpd.service<br></code></pre></td></tr></table></figure></li></ol></li><li><p>本地用户模式：</p><ol type="1"><li><p>运行以下命令为FTP服务创建一个Linux用户。</p><p>本示例中，该用户名为<code>ftptest</code>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs undefined">adduser ftptest<br></code></pre></td></tr></table></figure></li><li><p>运行以下命令修改</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">ftptest</span><br></code></pre></td></tr></table></figure><p>用户的密码。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs undefined">passwd ftptest<br></code></pre></td></tr></table></figure><p>运行命令后，根据命令行提示完成FTP用户的密码修改。</p></li><li><p>运行以下命令创建一个供FTP服务使用的文件目录。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">mkdir</span> /var/ftp/test<br></code></pre></td></tr></table></figure></li><li><p>运行以下命令更改/var/ftp/test目录的拥有者为</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">ftptest</span><br></code></pre></td></tr></table></figure><p>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">chown</span> -R ftptest:ftptest /var/ftp/test<br></code></pre></td></tr></table></figure></li><li><p>修改vsftpd.conf配置文件。</p><ol type="1"><li><p>运行以下命令，修改配置文件</p><p>/etc/vsftpd/vsftpd.conf</p><p>。</p><p>如果您在安装vsftpd时，使用的是<strong>apt installvsftpd</strong>安装命令，则配置文件路径为/etc/vsftpd.conf。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">vim /etc/vsftpd/vsftpd.conf<br></code></pre></td></tr></table></figure></li><li><p>按i进入编辑模式。</p></li><li><p>配置FTP服务器为被动模式。</p><p>具体的配置参数说明如下：</p><p><strong>注意</strong>复制以下参数，然后粘贴至Linux服务器的配置文件时，请注意参数不要被<code>#</code>号注释掉。同时，请注意格式问题。例如，添加多余的空格会造成无法重启服务的结果。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#除下面提及的参数，其他参数保持默认值即可。</span><br><br><span class="hljs-comment">#修改下列参数的值：</span><br><span class="hljs-comment">#禁止匿名登录FTP服务器。</span><br>anonymous_enable=NO<br><span class="hljs-comment">#允许本地用户登录FTP服务器。</span><br>local_enable=YES<br><span class="hljs-comment">#监听IPv4 sockets。</span><br>listen=YES<br><br><span class="hljs-comment">#在行首添加#注释掉以下参数：</span><br><span class="hljs-comment">#关闭监听IPv6 sockets。</span><br><span class="hljs-comment">#listen_ipv6=YES</span><br><br><span class="hljs-comment">#在配置文件的末尾添加下列参数：</span><br><span class="hljs-comment">#设置本地用户登录后所在目录。</span><br>local_root=/var/ftp/test<br><span class="hljs-comment">#全部用户被限制在主目录。</span><br>chroot_local_user=YES<br><span class="hljs-comment">#启用例外用户名单。</span><br>chroot_list_enable=YES<br><span class="hljs-comment">#指定例外用户列表文件，列表中用户不被锁定在主目录。</span><br>chroot_list_file=/etc/vsftpd/chroot_list<br><span class="hljs-comment">#开启被动模式。</span><br>pasv_enable=YES<br>allow_writeable_chroot=YES<br><span class="hljs-comment">#本示例中为Linux服务器的公网IP。</span><br>pasv_address=&lt;FTP服务器公网IP地址&gt;<br><span class="hljs-comment">#设置被动模式下，建立数据传输可使用的端口范围的最小值。</span><br><span class="hljs-comment">#建议您把端口范围设置在一段比较高的范围内，例如50000~50010，有助于提高访问FTP服务器的安全性。</span><br>pasv_min_port=&lt;port number&gt;<br><span class="hljs-comment">#设置被动模式下，建立数据传输可使用的端口范围的最大值。</span><br>pasv_max_port=&lt;port number&gt;<br></code></pre></td></tr></table></figure><p>更多参数的详细信息，请参见<ahref="https://help.aliyun.com/document_detail/60152.html#section-wx4-1bx-kln">vsftp配置文件及参数说明</a>。</p></li><li><p>按Esc退出编辑模式，然后输入<code>:wq</code>并回车，保存退出文件。</p></li></ol></li><li><p>创建</p><p>chroot_list</p><p>文件，并在文件中写入例外用户名单。</p><ol type="1"><li><p>运行以下命令，创建</p><p>chroot_list</p><p>文件。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">vim /etc/vsftpd/chroot_list<br></code></pre></td></tr></table></figure></li><li><p>按i进入编辑模式。</p></li><li><p>输入例外用户名单。此名单中的用户不会被锁定在主目录，可以访问其他目录。</p><p><strong>注意</strong>没有例外用户时，也必须创建chroot_list文件，内容可为空。</p></li><li><p>按Esc退出编辑模式，然后输入<code>:wq</code>并回车，保存退出文件。</p></li></ol></li><li><p>运行以下命令，重启FTP服务。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs undefined">systemctl restart vsftpd.service<br></code></pre></td></tr></table></figure></li></ol></li></ul><h2id="步骤四配置linux服务器的防火墙">步骤四：配置Linux服务器的防火墙</h2><p>搭建好FTP站点后，在Linux服务器的防火墙中，需要放行下列FTP端口。具体操作，请参见<ahref="https://help.aliyun.com/document_detail/59086.htm#section-zy8-x7r-9pl">添加防火墙规则</a>。</p><p>被动模式需开放21端口，以及配置文件/etc/vsftpd/vsftpd.conf中参数<code>pasv_min_port</code>和<code>pasv_max_port</code>之间的所有端口。配置详情如下表所示。</p><table><thead><tr class="header"><th style="text-align: left;">应用类型</th><th style="text-align: left;">协议</th><th style="text-align: left;">端口范围</th></tr></thead><tbody><tr class="odd"><td style="text-align: left;">FTP</td><td style="text-align: left;">TCP</td><td style="text-align: left;">21</td></tr><tr class="even"><td style="text-align: left;">自定义</td><td style="text-align: left;">TCP</td><tdstyle="text-align: left;"><code>pasv_min_port/pasv_max_port</code>。例如：50000/50010</td></tr></tbody></table><p>配置完成后，如下图所示：<imgsrc="https://help-static-aliyun-doc.aliyuncs.com/assets/img/zh-CN/7683998161/p266458.png"alt="FTP防火墙" /></p><h2id="步骤五通过ftp客户端测试连接ftp服务器">步骤五：通过FTP客户端测试连接FTP服务器</h2><ol type="1"><li><p>打开FileZilla客户端。</p></li><li><p>在顶部菜单栏，选择<strong><em>*文件*</em> &gt;*<em>站点管理器*</em></strong>。</p></li><li><p>在<strong>站点管理器</strong>对话框的左下角，单击<strong>新站点</strong>。</p></li><li><p>输入新站点的名称，并完成站点配置。</p><p><imgsrc="https://help-static-aliyun-doc.aliyuncs.com/assets/img/zh-CN/7690838161/p261708.png"alt="filezilla" />具体的配置项说明如下：</p><ul><li><p>新站点名称：您自定义的站点名称。例如<code>test-01</code>。</p></li><li><p>协议：FTP-文件传输协议。</p></li><li><p>主机：FTP服务器公网IP地址。本文中为Linux实例的公网IP地址，例如<code>121.43.XX.XX</code>。</p></li><li><p>端口：21。</p></li><li><p>登录类型：匿名。</p><p>本示例中使用FTP客户端连接匿名模式的FTP服务器。如果您需要使用FTP用户密码连接FTP服务器，则登录类型需要设置为正常，并需要配置用户和密码信息。</p></li></ul></li><li><p>单击</p><p>连接</p><p>。</p><p>连接成功后，您可以对文件进行上传、下载和删除等操作。FileZilla工具界面如下图所示。<imgsrc="https://help-static-aliyun-doc.aliyuncs.com/assets/img/zh-CN/5531787161/p261717.png"alt="filezilla" />图中各区域的信息说明如下表所示。</p><table><thead><tr class="header"><th style="text-align: left;">序号</th><th style="text-align: left;">说明</th></tr></thead><tbody><tr class="odd"><td style="text-align: left;">①</td><td style="text-align: left;">显示命令、FTP连接状态和任务执行结果。</td></tr><tr class="even"><td style="text-align: left;">②</td><td style="text-align: left;">本地区域，显示本地主机的目录信息。</td></tr><tr class="odd"><td style="text-align: left;">③</td><tdstyle="text-align: left;">远程区域，显示FTP服务器的目录信息。匿名模式下，默认目录为/pub。</td></tr><tr class="even"><td style="text-align: left;">④</td><tdstyle="text-align: left;">记录区域，可查看FTP任务的队列信息和日志信息。</td></tr></tbody></table></li></ol><h2 id="vsftp配置文件及参数说明">vsftp配置文件及参数说明</h2><p>/etc/vsftpd目录下文件说明如下：</p><ul><li>/etc/vsftpd/vsftpd.conf是vsftpd的核心配置文件。</li><li>/etc/vsftpd/ftpusers是黑名单文件，此文件中的用户不允许访问FTP服务器。</li><li>/etc/vsftpd/user_list是白名单文件，此文件中的用户允许访问FTP服务器。</li></ul><p>配置文件vsftpd.conf参数说明如下：</p><ul><li><p>用户登录控制参数说明如下表所示。</p><table><thead><tr class="header"><th style="text-align: left;">参数</th><th style="text-align: left;">说明</th></tr></thead><tbody><tr class="odd"><td style="text-align: left;">anonymous_enable=YES</td><td style="text-align: left;">接受匿名用户</td></tr><tr class="even"><td style="text-align: left;">no_anon_password=YES</td><td style="text-align: left;">匿名用户login时不询问口令</td></tr><tr class="odd"><td style="text-align: left;">anon_root=（none）</td><td style="text-align: left;">匿名用户主目录</td></tr><tr class="even"><td style="text-align: left;">local_enable=YES</td><td style="text-align: left;">接受本地用户</td></tr><tr class="odd"><td style="text-align: left;">local_root=（none）</td><td style="text-align: left;">本地用户主目录</td></tr></tbody></table></li><li><p>用户权限控制参数说明如下表所示。</p><table><thead><tr class="header"><th style="text-align: left;">参数</th><th style="text-align: left;">说明</th></tr></thead><tbody><tr class="odd"><td style="text-align: left;">write_enable=YES</td><td style="text-align: left;">可以上传文件（全局控制）</td></tr><tr class="even"><td style="text-align: left;">local_umask=022</td><td style="text-align: left;">本地用户上传的文件权限</td></tr><tr class="odd"><td style="text-align: left;">file_open_mode=0666</td><td style="text-align: left;">上传文件的权限配合umask使用</td></tr><tr class="even"><td style="text-align: left;">anon_upload_enable=NO</td><td style="text-align: left;">匿名用户可以上传文件</td></tr><tr class="odd"><td style="text-align: left;">anon_mkdir_write_enable=NO</td><td style="text-align: left;">匿名用户可以建目录</td></tr><tr class="even"><td style="text-align: left;">anon_other_write_enable=NO</td><td style="text-align: left;">匿名用户修改删除</td></tr><tr class="odd"><td style="text-align: left;">chown_username=lightwiter</td><td style="text-align: left;">匿名上传文件所属用户名</td></tr></tbody></table></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>大气光学湍流模型研究与实践-笔记</title>
    <link href="/2022/05/24/%E5%A4%A7%E6%B0%94%E5%85%89%E5%AD%A6%E6%B9%8D%E6%B5%81%E6%A8%A1%E5%9E%8B%E7%A0%94%E7%A9%B6%E4%B8%8E%E5%AE%9E%E8%B7%B5-%E7%AC%94%E8%AE%B0/"/>
    <url>/2022/05/24/%E5%A4%A7%E6%B0%94%E5%85%89%E5%AD%A6%E6%B9%8D%E6%B5%81%E6%A8%A1%E5%9E%8B%E7%A0%94%E7%A9%B6%E4%B8%8E%E5%AE%9E%E8%B7%B5-%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<p>大气光学湍流强度在垂直方向的分布，称为<strong>大气光学湍流廓线</strong>，通常记为<span class="math inline">\(C_{n}^{2}\)</span>廓线</p><p>大气相干长度 <spanclass="math inline">\(r_0\)</span>,也被称为Fried常数，表征<strong>分辨率不再受大气湍流影响的望远镜的等效口径</strong>。<spanclass="math inline">\(C_n^2\)</span>廓线直接对高度积分，就可以得到大气相干长度。<spanclass="math inline">\(r_0\)</span>进行简单的变化，就是我们经常使用的大气视宁度。<spanclass="math inline">\(ε=0.98\frac{λ}{r_0}\)</span>,<strong>大气视宁度</strong>表示大口径望远镜焦面上星象的半峰全宽。</p><p>自适应光学技术通过实时补偿大气扰动造成的波前畸变，来改善成像质量。对天文选址提出新的要求，高空湍流及其相关的参数：等晕角、大气相干时间则变得更加重要。</p><p><strong>等晕角 <spanclass="math inline">\(θ_{AO}\)</span></strong>表示在望远镜的入瞳处具有近似波前的两个星象的最大角距。高空<spanclass="math inline">\(C_n^2\)</span>值越大，等晕角的值越小。等晕角<spanclass="math inline">\(θ_{AO}\)</span>对于N个变形镜的自适应光学系统，能够归一化到<spanclass="math inline">\(θ_{N}\)</span>,它对应的改正后的等晕区的视场，能够影响覆盖天区的大小。</p><p><strong>大气相干时间 <spanclass="math inline">\(τ_{AO}\)</span></strong>表示波前保持相干时间。V(h)表示大气风速廓线。湍流强度所在位置的风速越大，大气相干时间的值越小。</p><p><strong>湍流外尺度 <span class="math inline">\(L_0\)</span>,内尺度<span class="math inline">\(l_0\)</span>。温度结构函数 <spanclass="math inline">\(C_t^2\)</span></strong>。</p><p>位温θ，位温的结构函数<spanclass="math inline">\(D_θ（l）\)</span>，其中 <spanclass="math inline">\(\overline{N}\)</span>表示位温扰动方差的耗散率，<spanclass="math inline">\(\epsilon\)</span>为湍动能耗散率。<spanclass="math inline">\(C_θ^2\)</span>表示位温结构常数。</p><p><strong>理查德森数 <spanclass="math inline">\(R_i\)</span></strong>来表示大气光学湍流的稳定程度。</p><p>目前已有许多成熟的技术设备来测量 <spanclass="math inline">\(C_{n}^{2}\)</span>廓线及其积分参数值：</p><p><strong>DIMM(Differential Image MotionMonitor)</strong>,SLODAR等通过测量波前倾斜来获取光学湍流参数；可以测量大气相干长度，或者视宁度。</p><p><strong>MASS（Multi-Aperture ScintillationSenor）</strong>,SCIDAR(Scintillation Detection andRanging)等通过测量闪烁；可以测量 <spanclass="math inline">\(C_{n}^{2}\)</span>廓线、大气相干长度、大气相干时间、等晕角。</p><p>SODAR，<strong>SNODAR（Surface layer Non-Doppler AcousticRadar）</strong>等通过向空间发射声波，通过接受回波来计算官学湍流信息。可以测量<spanclass="math inline">\(C_{n}^{2}\)</span>廓线、大气相干长度、大气相干时间、等晕角。</p><p>探空气不适合研究天文台址的光学湍流参数。目前用于计算光学湍流参数的气象模式主要有Meso-NH（Non-HydrostaticMesoscale Atmospheric Model）、==WRF（Weather Research and ForecastingMoel）==和MM5（Mesoscale Model 5）；</p><p>WRF是由美国开发的新一代中尺度非静力学天气预报模式。WRF模式分为两种，<strong>ARF（theAdvanced Research）和NMM（the Nonhydrostatic MesoscaleModel）</strong>，即==高级研究和业务预报==两种模式，水平方向采用ArakawaC网格点，垂直方向则采用地形跟随质量坐标。在时间积分方面采用三阶或者四阶的Runge-Kutta算法。WRF模式的源代码以及所需地形、气象数据都可以由NCAR和NCEP的网站下载。</p><p>英文对照</p><p>相干时间 coherent time COH_TIME</p><p>等晕角 isohalo angle ISO_ANGLE</p><p>边界层视宁度 boundary layer seeing</p><p>经纬度 Longitude and latitude</p><p>地表高度 surface height</p><p>相干长度 coherence length</p><p>自由大气视宁角 Free Atmospheric Seeing Angle</p><p>高度 high</p><p>厚度 thickness</p><p>风速 wind speed</p><p>风向 wind direction</p><p>风速梯度 wind speed gradient</p><p>温度 temperature</p><p>气温 air temperature</p><p>位温 Potential temperature</p><p>位温梯度 Potential temperature gradient</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Fortran-动态数组&amp;导出数据类型&amp;指针</title>
    <link href="/2022/05/23/Fortran-%E5%8A%A8%E6%80%81%E6%95%B0%E7%BB%84-%E5%AF%BC%E5%87%BA%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B-%E6%8C%87%E9%92%88/"/>
    <url>/2022/05/23/Fortran-%E5%8A%A8%E6%80%81%E6%95%B0%E7%BB%84-%E5%AF%BC%E5%87%BA%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B-%E6%8C%87%E9%92%88/</url>
    
    <content type="html"><![CDATA[<h2 id="动态数组">动态数组</h2><p>动态数组是一种数组，其尺寸在编译时不知道，而是在执行时才已知/确定的。</p><p>​ 动态数组的属性使用 allocatable 声明。 .</p><p>​ 例如，</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs fortran"><span class="hljs-keyword">real</span>, <span class="hljs-keyword">dimension</span> (:,:), <span class="hljs-keyword">allocatable</span> :: darray    <br></code></pre></td></tr></table></figure><p>​数组的秩，即尺寸，必须提到但是，分配内存以这样的阵列，可以使用allocate函数。</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs fortran"><span class="hljs-built_in">allocate</span> ( darray(s1,s2) )      <br></code></pre></td></tr></table></figure><p>​ 该阵列使用后，在该程序中，所创建的存储器应该使用 deallocate函数解除</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs fortran"><span class="hljs-built_in">deallocate</span> (darray)  <br></code></pre></td></tr></table></figure><p>​ <strong>示例</strong></p><p>​ 下面的例子演示了上面讨论的概念。</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs fortran"><span class="hljs-function"><span class="hljs-keyword">program</span></span> dynamic_array <br><span class="hljs-keyword">implicit</span> <span class="hljs-keyword">none</span> <br><br>   <span class="hljs-comment">!rank is 2, but size not known   </span><br>   <span class="hljs-keyword">real</span>, <span class="hljs-keyword">dimension</span> (:,:), <span class="hljs-keyword">allocatable</span> :: darray    <br>   <span class="hljs-keyword">integer</span> :: s1, s2     <br>   <span class="hljs-keyword">integer</span> :: i, j     <br>   <br>   <span class="hljs-built_in">print</span>*, <span class="hljs-string">&quot;Enter the size of the array:&quot;</span>     <br>   read*, s1, s2      <br>   <br>   <span class="hljs-comment">! allocate memory      </span><br>   <span class="hljs-built_in">allocate</span> ( darray(s1,s2) )      <br>   <br>   <span class="hljs-keyword">do</span> i = <span class="hljs-number">1</span>, s1           <br>      <span class="hljs-keyword">do</span> j = <span class="hljs-number">1</span>, s2                <br>         darray(i,j) = i*j               <br>         <span class="hljs-built_in">print</span>*, <span class="hljs-string">&quot;darray(&quot;</span>,i,<span class="hljs-string">&quot;,&quot;</span>,j,<span class="hljs-string">&quot;) = &quot;</span>, darray(i,j)           <br>      <span class="hljs-keyword">end</span> <span class="hljs-keyword">do</span>      <br>   <span class="hljs-keyword">end</span> <span class="hljs-keyword">do</span>      <br>   <br>   <span class="hljs-built_in">deallocate</span> (darray)  <br><span class="hljs-keyword">end</span> <span class="hljs-function"><span class="hljs-keyword">program</span></span> dynamic_array<br></code></pre></td></tr></table></figure><p>​ 当上述代码被编译和执行时，它产生了以下结果：</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs fortran">Enter the <span class="hljs-built_in">size</span> of the array: <span class="hljs-number">3</span>,<span class="hljs-number">4</span><br>darray( <span class="hljs-number">1</span> , <span class="hljs-number">1</span> ) = <span class="hljs-number">1.00000000</span>    <br>darray( <span class="hljs-number">1</span> , <span class="hljs-number">2</span> ) = <span class="hljs-number">2.00000000</span>    <br>darray( <span class="hljs-number">1</span> , <span class="hljs-number">3</span> ) = <span class="hljs-number">3.00000000</span>    <br>darray( <span class="hljs-number">1</span> , <span class="hljs-number">4</span> ) = <span class="hljs-number">4.00000000</span>    <br>darray( <span class="hljs-number">2</span> , <span class="hljs-number">1</span> ) = <span class="hljs-number">2.00000000</span>    <br>darray( <span class="hljs-number">2</span> , <span class="hljs-number">2</span> ) = <span class="hljs-number">4.00000000</span>    <br>darray( <span class="hljs-number">2</span> , <span class="hljs-number">3</span> ) = <span class="hljs-number">6.00000000</span>    <br>darray( <span class="hljs-number">2</span> , <span class="hljs-number">4</span> ) = <span class="hljs-number">8.00000000</span>    <br>darray( <span class="hljs-number">3</span> , <span class="hljs-number">1</span> ) = <span class="hljs-number">3.00000000</span>    <br>darray( <span class="hljs-number">3</span> , <span class="hljs-number">2</span> ) = <span class="hljs-number">6.00000000</span>    <br>darray( <span class="hljs-number">3</span> , <span class="hljs-number">3</span> ) = <span class="hljs-number">9.00000000</span>    <br>darray( <span class="hljs-number">3</span> , <span class="hljs-number">4</span> ) = <span class="hljs-number">12.0000000</span>   <br></code></pre></td></tr></table></figure><h3 id="使用data语句">使用data语句</h3><p>​ data 语句可用于初始化多个阵列，或用于阵列部分的初始化。</p><p>​ data 语句的语法是：</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs fortran"><span class="hljs-keyword">data</span> variable / list / ...<br></code></pre></td></tr></table></figure><p>​ <strong>示例</strong></p><p>​ 下面的例子演示了这一概念：</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs fortran"><span class="hljs-function"><span class="hljs-keyword">program</span></span> dataStatement<br><span class="hljs-keyword">implicit</span> <span class="hljs-keyword">none</span><br><br>   <span class="hljs-keyword">integer</span> :: a(<span class="hljs-number">5</span>), b(<span class="hljs-number">3</span>,<span class="hljs-number">3</span>), c(<span class="hljs-number">10</span>),i, j<br>   <span class="hljs-keyword">data</span> a /<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>,<span class="hljs-number">10</span>,<span class="hljs-number">11</span>/ <br>   <br>   <span class="hljs-keyword">data</span> b(<span class="hljs-number">1</span>,:) /<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>/ <br>   <span class="hljs-keyword">data</span> b(<span class="hljs-number">2</span>,:)/<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>/ <br>   <span class="hljs-keyword">data</span> b(<span class="hljs-number">3</span>,:)/<span class="hljs-number">3</span>,<span class="hljs-number">3</span>,<span class="hljs-number">3</span>/ <br>   <span class="hljs-keyword">data</span> (c(i),i=<span class="hljs-number">1</span>,<span class="hljs-number">10</span>,<span class="hljs-number">2</span>) /<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>/ <br>   <span class="hljs-keyword">data</span> (c(i),i=<span class="hljs-number">2</span>,<span class="hljs-number">10</span>,<span class="hljs-number">2</span>)/<span class="hljs-number">5</span>*<span class="hljs-number">2</span>/<br>   <br>   <span class="hljs-built_in">Print</span> *, <span class="hljs-string">&#x27;The A array:&#x27;</span><br>   <span class="hljs-keyword">do</span> j = <span class="hljs-number">1</span>, <span class="hljs-number">5</span>                <br>      <span class="hljs-built_in">print</span>*, a(j)           <br>   <span class="hljs-keyword">end</span> <span class="hljs-keyword">do</span> <br>   <br>   <span class="hljs-built_in">Print</span> *, <span class="hljs-string">&#x27;The B array:&#x27;</span><br>   <span class="hljs-keyword">do</span> i = <span class="hljs-built_in">lbound</span>(b,<span class="hljs-number">1</span>), <span class="hljs-built_in">ubound</span>(b,<span class="hljs-number">1</span>)<br>      <span class="hljs-built_in">write</span>(*,*) (b(i,j), j = <span class="hljs-built_in">lbound</span>(b,<span class="hljs-number">2</span>), <span class="hljs-built_in">ubound</span>(b,<span class="hljs-number">2</span>))<br>   <span class="hljs-keyword">end</span> <span class="hljs-keyword">do</span><br><br>   <span class="hljs-built_in">Print</span> *, <span class="hljs-string">&#x27;The C array:&#x27;</span> <br>   <span class="hljs-keyword">do</span> j = <span class="hljs-number">1</span>, <span class="hljs-number">10</span>                <br>      <span class="hljs-built_in">print</span>*, c(j)           <br>   <span class="hljs-keyword">end</span> <span class="hljs-keyword">do</span>      <br>   <br><span class="hljs-keyword">end</span> <span class="hljs-function"><span class="hljs-keyword">program</span></span> dataStatement<br></code></pre></td></tr></table></figure><p>​ 当上述代码被编译和执行时，它产生了以下结果：</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs fortran">The A array:<br><span class="hljs-number">7</span><br><span class="hljs-number">8</span><br><span class="hljs-number">9</span><br><span class="hljs-number">10</span><br><span class="hljs-number">11</span><br>The B array:<br><span class="hljs-number">1</span>  <span class="hljs-number">1</span>  <span class="hljs-number">1</span><br><span class="hljs-number">2</span>  <span class="hljs-number">2</span>  <span class="hljs-number">2</span><br><span class="hljs-number">3</span>  <span class="hljs-number">3</span>  <span class="hljs-number">3</span><br>The C array:<br><span class="hljs-number">4</span><br><span class="hljs-number">2</span><br><span class="hljs-number">5</span><br><span class="hljs-number">2</span><br><span class="hljs-number">6</span><br><span class="hljs-number">2</span><br><span class="hljs-number">7</span><br><span class="hljs-number">2</span><br><span class="hljs-number">8</span><br><span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><h3 id="使用where语句">使用where语句</h3><p>​where语句可以使用数组中的某些元素在一个表达式，根据一些逻辑条件的结果。它允许表达的执行在一个元素上，如果给定的条件为真。</p><p>​ <strong>例子</strong></p><p>​ 下面的例子演示了这一概念：</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs fortran"><span class="hljs-function"><span class="hljs-keyword">program</span></span> whereStatement<br><span class="hljs-keyword">implicit</span> <span class="hljs-keyword">none</span><br><br>   <span class="hljs-keyword">integer</span> :: a(<span class="hljs-number">3</span>,<span class="hljs-number">5</span>), i , j<br>   <br>   <span class="hljs-keyword">do</span> i = <span class="hljs-number">1</span>,<span class="hljs-number">3</span><br>      <span class="hljs-keyword">do</span> j = <span class="hljs-number">1</span>, <span class="hljs-number">5</span>                <br>         a(i,j) = j-i          <br>      <span class="hljs-keyword">end</span> <span class="hljs-keyword">do</span> <br>   <span class="hljs-keyword">end</span> <span class="hljs-keyword">do</span><br>   <br>   <span class="hljs-built_in">Print</span> *, <span class="hljs-string">&#x27;The A array:&#x27;</span><br>   <br>   <span class="hljs-keyword">do</span> i = <span class="hljs-built_in">lbound</span>(a,<span class="hljs-number">1</span>), <span class="hljs-built_in">ubound</span>(a,<span class="hljs-number">1</span>)<br>      <span class="hljs-built_in">write</span>(*,*) (a(i,j), j = <span class="hljs-built_in">lbound</span>(a,<span class="hljs-number">2</span>), <span class="hljs-built_in">ubound</span>(a,<span class="hljs-number">2</span>))<br>   <span class="hljs-keyword">end</span> <span class="hljs-keyword">do</span><br>   <br>   <span class="hljs-keyword">where</span>( a&lt;<span class="hljs-number">0</span> ) <br>      a = <span class="hljs-number">1</span> <br>   <span class="hljs-keyword">elsewhere</span><br>      a = <span class="hljs-number">5</span><br>   <span class="hljs-keyword">end</span> <span class="hljs-keyword">where</span><br>  <br>   <span class="hljs-built_in">Print</span> *, <span class="hljs-string">&#x27;The A array:&#x27;</span><br>   <span class="hljs-keyword">do</span> i = <span class="hljs-built_in">lbound</span>(a,<span class="hljs-number">1</span>), <span class="hljs-built_in">ubound</span>(a,<span class="hljs-number">1</span>)<br>      <span class="hljs-built_in">write</span>(*,*) (a(i,j), j = <span class="hljs-built_in">lbound</span>(a,<span class="hljs-number">2</span>), <span class="hljs-built_in">ubound</span>(a,<span class="hljs-number">2</span>))<br>   <span class="hljs-keyword">end</span> <span class="hljs-keyword">do</span>   <br>   <br><span class="hljs-keyword">end</span> <span class="hljs-function"><span class="hljs-keyword">program</span></span> whereStatement<br></code></pre></td></tr></table></figure><p>​ 当上述代码被编译和执行时，它产生了以下结果：</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs fortran">The A array:<br><span class="hljs-number">0</span>   <span class="hljs-number">1</span>   <span class="hljs-number">2</span>  <span class="hljs-number">3</span>  <span class="hljs-number">4</span><br>-<span class="hljs-number">1</span>  <span class="hljs-number">0</span>   <span class="hljs-number">1</span>  <span class="hljs-number">2</span>  <span class="hljs-number">3</span><br>-<span class="hljs-number">2</span>  -<span class="hljs-number">1</span>  <span class="hljs-number">0</span>  <span class="hljs-number">1</span>  <span class="hljs-number">2</span><br>The A array:<br><span class="hljs-number">5</span>   <span class="hljs-number">5</span>   <span class="hljs-number">5</span>  <span class="hljs-number">5</span>  <span class="hljs-number">5</span><br><span class="hljs-number">1</span>   <span class="hljs-number">5</span>   <span class="hljs-number">5</span>  <span class="hljs-number">5</span>  <span class="hljs-number">5</span><br><span class="hljs-number">1</span>   <span class="hljs-number">1</span>   <span class="hljs-number">5</span>  <span class="hljs-number">5</span>  <span class="hljs-number">5</span><br></code></pre></td></tr></table></figure><h2 id="导出数据类型">导出数据类型</h2><p>Fortran语言可以定义导出的数据类型。导出的数据类型也被称为一个结构，它可以包含不同类型的数据对象。</p><p>​导出的数据类型被用来代表一个记录。例如要跟踪在图书馆的书，可能希望跟踪的每本书有如下属性：</p><ul><li>​ 标题- Title</li><li>​ 作者 - Author</li><li>​ 科目 - Subject</li><li>​ 编号 - Book ID</li></ul><h2 id="定义一个导出的数据类型">定义一个导出的数据类型</h2><p>​定义一个派生数据类型，类型和端类型的语句被使用。类型语句定义了一个新的数据类型，项目不止一个成员。类型声明的格式是这样的：</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs fortran"><span class="hljs-keyword">type</span> type_name      <br>   declarations<br><span class="hljs-keyword">end</span> <span class="hljs-keyword">type</span> <br></code></pre></td></tr></table></figure><p>​ 这里是会声明书的结构方式：</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs fortran"><span class="hljs-keyword">type</span> Books<br>   <span class="hljs-keyword">character</span>(len=<span class="hljs-number">50</span>) :: title<br>   <span class="hljs-keyword">character</span>(len=<span class="hljs-number">50</span>) :: author<br>   <span class="hljs-keyword">character</span>(len=<span class="hljs-number">150</span>) :: subject<br>   <span class="hljs-keyword">integer</span> :: book_id<br><span class="hljs-keyword">end</span> <span class="hljs-keyword">type</span> Books<br></code></pre></td></tr></table></figure><h2 id="访问结构成员">访问结构成员</h2><p>​ 一个派生数据类型的对象被称为结构</p><p>​ 类型书籍(Books) 的结构像一个类型声明语句创建如下：</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs fortran"><span class="hljs-keyword">type</span>(Books) :: book1 <br></code></pre></td></tr></table></figure><p>​ 结构的组成部分可以使用该组件选择字符(%)进行访问 :</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs fortran">book1%title = <span class="hljs-string">&quot;C Programming&quot;</span><br>book1%author = <span class="hljs-string">&quot;Nuha Ali&quot;</span><br>book1%subject = <span class="hljs-string">&quot;C Programming Tutorial&quot;</span><br>book1%book_id = <span class="hljs-number">6495407</span><br></code></pre></td></tr></table></figure><p>​ <strong>请注意，</strong>％符号前后没有空格。</p><p>​ <strong>示例</strong></p><p>​ 下面的程序说明了上述概念：</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs fortran"><span class="hljs-function"><span class="hljs-keyword">program</span></span> deriveDataType<br><br>   <span class="hljs-comment">!type declaration</span><br>   <span class="hljs-keyword">type</span> Books<br>      <span class="hljs-keyword">character</span>(len=<span class="hljs-number">50</span>) :: title<br>      <span class="hljs-keyword">character</span>(len=<span class="hljs-number">50</span>) :: author<br>      <span class="hljs-keyword">character</span>(len=<span class="hljs-number">150</span>) :: subject<br>      <span class="hljs-keyword">integer</span> :: book_id<br>   <span class="hljs-keyword">end</span> <span class="hljs-keyword">type</span> Books<br>   <br>   <span class="hljs-comment">!declaring type variables</span><br>   <span class="hljs-keyword">type</span>(Books) :: book1 <br>   <span class="hljs-keyword">type</span>(Books) :: book2 <br>   <br>   <span class="hljs-comment">!accessing the components of the structure</span><br>   <br>   book1%title = <span class="hljs-string">&quot;C Programming&quot;</span><br>   book1%author = <span class="hljs-string">&quot;Nuha Ali&quot;</span><br>   book1%subject = <span class="hljs-string">&quot;C Programming Tutorial&quot;</span><br>   book1%book_id = <span class="hljs-number">6495407</span> <br>   <br>   book2%title = <span class="hljs-string">&quot;Telecom Billing&quot;</span><br>   book2%author = <span class="hljs-string">&quot;Zara Ali&quot;</span><br>   book2%subject = <span class="hljs-string">&quot;Telecom Billing Tutorial&quot;</span><br>   book2%book_id = <span class="hljs-number">6495700</span><br>  <br>   <span class="hljs-comment">!display book info</span><br>   <br>   <span class="hljs-built_in">Print</span> *, book1%title <br>   <span class="hljs-built_in">Print</span> *, book1%author <br>   <span class="hljs-built_in">Print</span> *, book1%subject <br>   <span class="hljs-built_in">Print</span> *, book1%book_id  <br>   <br>   <span class="hljs-built_in">Print</span> *, book2%title <br>   <span class="hljs-built_in">Print</span> *, book2%author <br>   <span class="hljs-built_in">Print</span> *, book2%subject <br>   <span class="hljs-built_in">Print</span> *, book2%book_id  <br><br><span class="hljs-keyword">end</span> <span class="hljs-function"><span class="hljs-keyword">program</span></span> deriveDataType<br></code></pre></td></tr></table></figure><p>​ 当上述代码被编译和执行时，它产生了以下结果：</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs fortran"><span class="hljs-comment">C Programming                                     </span><br>Nuha Ali                                          <br><span class="hljs-comment">C Programming Tutorial            </span><br>    <span class="hljs-number">6495407</span><br>Telecom Billing                                   <br>Zara Ali                                          <br>Telecom Billing Tutorial            <br>    <span class="hljs-number">6495700</span><br></code></pre></td></tr></table></figure><h2 id="结构数组">结构数组</h2><p>​ 还可以创建一个派生类型的数组：</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs fortran"><span class="hljs-keyword">type</span>(Books), <span class="hljs-keyword">dimension</span>(<span class="hljs-number">2</span>) :: list<br></code></pre></td></tr></table></figure><p>​ 数组的单个元素，可以访问如下：</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs fortran">list(<span class="hljs-number">1</span>)%title = <span class="hljs-string">&quot;C Programming&quot;</span><br>list(<span class="hljs-number">1</span>)%author = <span class="hljs-string">&quot;Nuha Ali&quot;</span><br>list(<span class="hljs-number">1</span>)%subject = <span class="hljs-string">&quot;C Programming Tutorial&quot;</span><br>list(<span class="hljs-number">1</span>)%book_id = <span class="hljs-number">6495407</span><br></code></pre></td></tr></table></figure><p>​ 下面的程序说明了这个概念：</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs fortran"><span class="hljs-function"><span class="hljs-keyword">program</span></span> deriveDataType<br><br>   <span class="hljs-comment">!type declaration</span><br>   <span class="hljs-keyword">type</span> Books<br>      <span class="hljs-keyword">character</span>(len=<span class="hljs-number">50</span>) :: title<br>      <span class="hljs-keyword">character</span>(len=<span class="hljs-number">50</span>) :: author<br>      <span class="hljs-keyword">character</span>(len=<span class="hljs-number">150</span>) :: subject<br>      <span class="hljs-keyword">integer</span> :: book_id<br>   <span class="hljs-keyword">end</span> <span class="hljs-keyword">type</span> Books<br>   <br>   <span class="hljs-comment">!declaring array of books</span><br>   <span class="hljs-keyword">type</span>(Books), <span class="hljs-keyword">dimension</span>(<span class="hljs-number">2</span>) :: list <br>    <br>   <span class="hljs-comment">!accessing the components of the structure</span><br>   <br>   list(<span class="hljs-number">1</span>)%title = <span class="hljs-string">&quot;C Programming&quot;</span><br>   list(<span class="hljs-number">1</span>)%author = <span class="hljs-string">&quot;Nuha Ali&quot;</span><br>   list(<span class="hljs-number">1</span>)%subject = <span class="hljs-string">&quot;C Programming Tutorial&quot;</span><br>   list(<span class="hljs-number">1</span>)%book_id = <span class="hljs-number">6495407</span> <br>   <br>   list(<span class="hljs-number">2</span>)%title = <span class="hljs-string">&quot;Telecom Billing&quot;</span><br>   list(<span class="hljs-number">2</span>)%author = <span class="hljs-string">&quot;Zara Ali&quot;</span><br>   list(<span class="hljs-number">2</span>)%subject = <span class="hljs-string">&quot;Telecom Billing Tutorial&quot;</span><br>   list(<span class="hljs-number">2</span>)%book_id = <span class="hljs-number">6495700</span><br>  <br>   <span class="hljs-comment">!display book info</span><br>   <br>   <span class="hljs-built_in">Print</span> *, list(<span class="hljs-number">1</span>)%title <br>   <span class="hljs-built_in">Print</span> *, list(<span class="hljs-number">1</span>)%author <br>   <span class="hljs-built_in">Print</span> *, list(<span class="hljs-number">1</span>)%subject <br>   <span class="hljs-built_in">Print</span> *, list(<span class="hljs-number">1</span>)%book_id  <br>   <br>   <span class="hljs-built_in">Print</span> *, list(<span class="hljs-number">1</span>)%title <br>   <span class="hljs-built_in">Print</span> *, list(<span class="hljs-number">2</span>)%author <br>   <span class="hljs-built_in">Print</span> *, list(<span class="hljs-number">2</span>)%subject <br>   <span class="hljs-built_in">Print</span> *, list(<span class="hljs-number">2</span>)%book_id  <br><br><span class="hljs-keyword">end</span> <span class="hljs-function"><span class="hljs-keyword">program</span></span> deriveDataType<br></code></pre></td></tr></table></figure><p>​ 当上述代码被编译和执行时，它产生了以下结果：</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs fortran"><span class="hljs-comment">C Programming                                     </span><br>Nuha Ali                                          <br><span class="hljs-comment">C Programming Tutorial               </span><br>   <span class="hljs-number">6495407</span><br><span class="hljs-comment">C Programming                                     </span><br>Zara Ali                                          <br>Telecom Billing Tutorial                                      <br>   <span class="hljs-number">6495700</span><br></code></pre></td></tr></table></figure><h2 id="指针">指针</h2><p>在大多数编程语言中，一个指针变量存储对象的内存地址。然而，在Fortran中，指针是具有不是仅仅存储存储器地址多功能性的数据对象。它包含有关特定对象的详细信息，如类型，等级，扩展和存储器地址。</p><p>​ 指针是通过分配或指针赋值的目标相关联。</p><h3 id="声明一个指针变量">声明一个指针变量</h3><p>​ 一个指针变量与指针属性声明。</p><p>​ 下面的实施例示出了声明指针变量：</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs fortran"><span class="hljs-keyword">integer</span>, <span class="hljs-keyword">pointer</span> :: p1 <span class="hljs-comment">! pointer to integer  </span><br><span class="hljs-keyword">real</span>, <span class="hljs-keyword">pointer</span>, <span class="hljs-keyword">dimension</span> (:) :: pra <span class="hljs-comment">! pointer to 1-dim real array  </span><br><span class="hljs-keyword">real</span>, <span class="hljs-keyword">pointer</span>, <span class="hljs-keyword">dimension</span> (:,:) :: pra2 <span class="hljs-comment">! pointer to 2-dim real array</span><br></code></pre></td></tr></table></figure><p>​ 指针可以指向：</p><ul><li><p>​ 动态分配的内存区域</p></li><li><p>​ 数据对象与目标属性相同类型的指针</p><h3 id="分配指针的空间">分配指针的空间</h3></li></ul><p>​ allocate语句可以分配指针对象空间。例如：</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs fortran"><span class="hljs-function"><span class="hljs-keyword">program</span></span> pointerExample<br><span class="hljs-keyword">implicit</span> <span class="hljs-keyword">none</span><br><br>   <span class="hljs-keyword">integer</span>, <span class="hljs-keyword">pointer</span> :: p1<br>   <span class="hljs-built_in">allocate</span>(p1)<br>   <br>   p1 = <span class="hljs-number">1</span><br>   <span class="hljs-built_in">Print</span> *, p1<br>   <br>   p1 = p1 + <span class="hljs-number">4</span><br>   <span class="hljs-built_in">Print</span> *, p1<br>   <br><span class="hljs-keyword">end</span> <span class="hljs-function"><span class="hljs-keyword">program</span></span> pointerExample<br></code></pre></td></tr></table></figure><p>​ 当上述代码被编译和执行时，它产生了以下结果：</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs fortran"><span class="hljs-number">1</span><br><span class="hljs-number">5</span><br></code></pre></td></tr></table></figure><p>​应该解除分配语句清空该分配的存储空间当它不再需要，并避免未使用的和不可用的存储器空间的积累。</p><h3 id="目标和关联">目标和关联</h3><p>​目标是另一个正态变量，空间预留给它。目标变量必须与目标属性进行声明。</p><p>​ 一个指针变量使用的关联操作符使目标变量相关联(=&gt;)。</p><p>​ 让我们重写前面的例子中，以说明这个概念：</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs fortran"><span class="hljs-function"><span class="hljs-keyword">program</span></span> pointerExample<br><span class="hljs-keyword">implicit</span> <span class="hljs-keyword">none</span><br><br>   <span class="hljs-keyword">integer</span>, <span class="hljs-keyword">pointer</span> :: p1<br>   <span class="hljs-keyword">integer</span>, <span class="hljs-keyword">target</span> :: t1 <br>   <br>   p1=&gt;t1<br>   p1 = <span class="hljs-number">1</span><br>   <br>   <span class="hljs-built_in">Print</span> *, p1<br>   <span class="hljs-built_in">Print</span> *, t1<br>   <br>   p1 = p1 + <span class="hljs-number">4</span><br>   <br>   <span class="hljs-built_in">Print</span> *, p1<br>   <span class="hljs-built_in">Print</span> *, t1<br>   <br>   t1 = <span class="hljs-number">8</span><br>   <br>   <span class="hljs-built_in">Print</span> *, p1<br>   <span class="hljs-built_in">Print</span> *, t1<br>   <br><span class="hljs-keyword">end</span> <span class="hljs-function"><span class="hljs-keyword">program</span></span> pointerExample<br></code></pre></td></tr></table></figure><p>​ 当上述代码被编译和执行时，它产生了以下结果：</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs fortran"><span class="hljs-number">1</span><br><span class="hljs-number">1</span><br><span class="hljs-number">5</span><br><span class="hljs-number">5</span><br><span class="hljs-number">8</span><br><span class="hljs-number">8</span><br></code></pre></td></tr></table></figure><p>​ 指针可以是：</p><ul><li>​ 未定义的</li><li>​ 关联的</li><li>​ 未关联的</li></ul><p>​在上面的程序中，我们使用associated的指针p1与目标t1时，使用=&gt;运算符。相关的函数，测试指针的关联状态。</p><p>​ 这个声明无效的关联从一个目标一个指针。</p><p>​无效非空目标，因为可能有多个指针指向同一个目标。然而空指针指也是无效的。</p><p>​ 示例 1</p><p>​ 下面的例子演示了概念：</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs fortran"><span class="hljs-function"><span class="hljs-keyword">program</span></span> pointerExample<br><span class="hljs-keyword">implicit</span> <span class="hljs-keyword">none</span><br><br>   <span class="hljs-keyword">integer</span>, <span class="hljs-keyword">pointer</span> :: p1<br>   <span class="hljs-keyword">integer</span>, <span class="hljs-keyword">target</span> :: t1 <br>   <span class="hljs-keyword">integer</span>, <span class="hljs-keyword">target</span> :: t2<br>   <br>   p1=&gt;t1<br>   p1 = <span class="hljs-number">1</span><br>   <br>   <span class="hljs-built_in">Print</span> *, p1<br>   <span class="hljs-built_in">Print</span> *, t1<br>   <br>   p1 = p1 + <span class="hljs-number">4</span><br>   <span class="hljs-built_in">Print</span> *, p1<br>   <span class="hljs-built_in">Print</span> *, t1<br>   <br>   t1 = <span class="hljs-number">8</span><br>   <span class="hljs-built_in">Print</span> *, p1<br>   <span class="hljs-built_in">Print</span> *, t1<br>   <br>   <span class="hljs-built_in">nullify</span>(p1)<br>   <span class="hljs-built_in">Print</span> *, t1<br>   <br>   p1=&gt;t2<br>   <span class="hljs-built_in">Print</span> *, <span class="hljs-built_in">associated</span>(p1)<br>   <span class="hljs-built_in">Print</span>*, <span class="hljs-built_in">associated</span>(p1, t1)<br>   <span class="hljs-built_in">Print</span>*, <span class="hljs-built_in">associated</span>(p1, t2)<br>   <br>   <span class="hljs-comment">!what is the value of p1 at present</span><br>   <span class="hljs-built_in">Print</span> *, p1<br>   <span class="hljs-built_in">Print</span> *, t2<br>   <br>   p1 = <span class="hljs-number">10</span><br>   <span class="hljs-built_in">Print</span> *, p1<br>   <span class="hljs-built_in">Print</span> *, t2<br>   <br><span class="hljs-keyword">end</span> <span class="hljs-function"><span class="hljs-keyword">program</span></span> pointerExample<br></code></pre></td></tr></table></figure><p>​ 当上述代码被编译和执行时，它产生了以下结果：</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs fortran"><span class="hljs-number">1</span><br><span class="hljs-number">1</span><br><span class="hljs-number">5</span><br><span class="hljs-number">5</span><br><span class="hljs-number">8</span><br><span class="hljs-number">8</span><br><span class="hljs-number">8</span><br>T<br>F<br>T<br><span class="hljs-number">952754640</span><br><span class="hljs-number">952754640</span><br><span class="hljs-number">10</span><br><span class="hljs-number">10</span><br></code></pre></td></tr></table></figure><p>​ 请注意，每次运行该代码时，内存地址会有所不同。</p><p>​ <strong>示例 2</strong></p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs fortran"><span class="hljs-function"><span class="hljs-keyword">program</span></span> pointerExample<br><span class="hljs-keyword">implicit</span> <span class="hljs-keyword">none</span><br><br>   <span class="hljs-keyword">integer</span>, <span class="hljs-keyword">pointer</span> :: a, b<br>   <span class="hljs-keyword">integer</span>, <span class="hljs-keyword">target</span> :: t<br>   <span class="hljs-keyword">integer</span> :: n<br>   <br>   t= <span class="hljs-number">1</span><br>   a=&gt;t<br>   t = <span class="hljs-number">2</span><br>   b =&gt; t<br>   n = a + b<br>   <br>   <span class="hljs-built_in">Print</span> *, a, b, t, n <br>   <br><span class="hljs-keyword">end</span> <span class="hljs-function"><span class="hljs-keyword">program</span></span> pointerExample<br></code></pre></td></tr></table></figure><p>​ 当上述代码被编译和执行时，它产生了以下结果：</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs fortran"><span class="hljs-number">2</span>  <span class="hljs-number">2</span>  <span class="hljs-number">2</span>  <span class="hljs-number">4</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Fortran</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Fortran-函数</title>
    <link href="/2022/05/23/Fortran-%E5%87%BD%E6%95%B0/"/>
    <url>/2022/05/23/Fortran-%E5%87%BD%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="向量和矩阵乘法函数">向量和矩阵乘法函数</h2><p><strong>下表描述了向量和矩阵乘法函数：</strong></p><table><thead><tr class="header"><th>函数</th><th>描述</th></tr></thead><tbody><tr class="odd"><td><strong>dot_product</strong>(vector_a, vector_b)</td><td>函数返回两个输入向量，它必须具有相同长度的标量积。</td></tr><tr class="even"><td><strong>matmul </strong>(matrix_a, matrix_b)</td><td>它返回两个矩阵的矩阵乘积，它必须是一致的，即具有相似大小 (m, k) 和(k, n)</td></tr></tbody></table><p>​ <strong>实例</strong></p><p>​ 下面的例子演示了内积：</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs fortran"><span class="hljs-function"><span class="hljs-keyword">program</span></span> arrayDotProduct<br><br>   <span class="hljs-keyword">real</span>, <span class="hljs-keyword">dimension</span>(<span class="hljs-number">5</span>) :: a, b<br>   <span class="hljs-keyword">integer</span>:: i, asize, bsize<br>   <br>   asize = <span class="hljs-built_in">size</span>(a)<br>   bsize = <span class="hljs-built_in">size</span>(b)<br>   <br>   <span class="hljs-keyword">do</span> i = <span class="hljs-number">1</span>, asize<br>      a(i) = i<br>   <span class="hljs-keyword">end</span> <span class="hljs-keyword">do</span><br>   <br>   <span class="hljs-keyword">do</span> i = <span class="hljs-number">1</span>, bsize<br>      b(i) = i*<span class="hljs-number">2</span><br>   <span class="hljs-keyword">end</span> <span class="hljs-keyword">do</span><br>   <br>   <span class="hljs-keyword">do</span> i = <span class="hljs-number">1</span>, asize<br>      <span class="hljs-built_in">Print</span> *, a(i)<br>   <span class="hljs-keyword">end</span> <span class="hljs-keyword">do</span><br>   <br>   <span class="hljs-keyword">do</span> i = <span class="hljs-number">1</span>, bsize<br>      <span class="hljs-built_in">Print</span> *, b(i)<br>   <span class="hljs-keyword">end</span> <span class="hljs-keyword">do</span><br>   <br>   <span class="hljs-built_in">Print</span>*, <span class="hljs-string">&#x27;Vector Multiplication: Dot Product:&#x27;</span><br>   <span class="hljs-built_in">Print</span>*, <span class="hljs-built_in">dot_product</span>(a, b)<br>   <br><span class="hljs-keyword">end</span> <span class="hljs-function"><span class="hljs-keyword">program</span></span> arrayDotProduct<br></code></pre></td></tr></table></figure><p>​ 当上述代码被编译和执行时，它产生了以下结果：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">1</span>.<span class="hljs-number">00000000</span>    <br><span class="hljs-attribute">2</span>.<span class="hljs-number">00000000</span>    <br><span class="hljs-attribute">3</span>.<span class="hljs-number">00000000</span>    <br><span class="hljs-attribute">4</span>.<span class="hljs-number">00000000</span>    <br><span class="hljs-attribute">5</span>.<span class="hljs-number">00000000</span>    <br><span class="hljs-attribute">2</span>.<span class="hljs-number">00000000</span>    <br><span class="hljs-attribute">4</span>.<span class="hljs-number">00000000</span>    <br><span class="hljs-attribute">6</span>.<span class="hljs-number">00000000</span>    <br><span class="hljs-attribute">8</span>.<span class="hljs-number">00000000</span>    <br><span class="hljs-attribute">10</span>.<span class="hljs-number">0000000</span>    <br><span class="hljs-attribute">Vector</span> Multiplication: Dot Product:<br><span class="hljs-attribute">110</span>.<span class="hljs-number">000000</span>   <br></code></pre></td></tr></table></figure><p>​ <strong>实例</strong></p><p>​ 下面的例子演示了矩阵乘法：</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs fortran"><span class="hljs-function"><span class="hljs-keyword">program</span></span> matMulProduct<br><br>   <span class="hljs-keyword">integer</span>, <span class="hljs-keyword">dimension</span>(<span class="hljs-number">3</span>,<span class="hljs-number">3</span>) :: a, b, c<br>   <span class="hljs-keyword">integer</span> :: i, j<br>    <br>   <span class="hljs-keyword">do</span> i = <span class="hljs-number">1</span>, <span class="hljs-number">3</span><br>      <span class="hljs-keyword">do</span> j = <span class="hljs-number">1</span>, <span class="hljs-number">3</span><br>         a(i, j) = i+j<br>      <span class="hljs-keyword">end</span> <span class="hljs-keyword">do</span><br>   <span class="hljs-keyword">end</span> <span class="hljs-keyword">do</span><br>   <br>   <span class="hljs-built_in">print</span> *, <span class="hljs-string">&#x27;Matrix Multiplication: A Matrix&#x27;</span><br>   <br>   <span class="hljs-keyword">do</span> i = <span class="hljs-number">1</span>, <span class="hljs-number">3</span><br>      <span class="hljs-keyword">do</span> j = <span class="hljs-number">1</span>, <span class="hljs-number">3</span><br>         <span class="hljs-built_in">print</span>*, a(i, j)<br>      <span class="hljs-keyword">end</span> <span class="hljs-keyword">do</span><br>   <span class="hljs-keyword">end</span> <span class="hljs-keyword">do</span><br>   <br>   <span class="hljs-keyword">do</span> i = <span class="hljs-number">1</span>, <span class="hljs-number">3</span><br>      <span class="hljs-keyword">do</span> j = <span class="hljs-number">1</span>, <span class="hljs-number">3</span><br>         b(i, j) = i*j<br>      <span class="hljs-keyword">end</span> <span class="hljs-keyword">do</span><br>   <span class="hljs-keyword">end</span> <span class="hljs-keyword">do</span><br>   <br>   <span class="hljs-built_in">Print</span>*, <span class="hljs-string">&#x27;Matrix Multiplication: B Matrix&#x27;</span><br>   <br>   <span class="hljs-keyword">do</span> i = <span class="hljs-number">1</span>, <span class="hljs-number">3</span><br>      <span class="hljs-keyword">do</span> j = <span class="hljs-number">1</span>, <span class="hljs-number">3</span><br>         <span class="hljs-built_in">print</span>*, b(i, j)<br>      <span class="hljs-keyword">end</span> <span class="hljs-keyword">do</span><br>   <span class="hljs-keyword">end</span> <span class="hljs-keyword">do</span><br>   <br>   c = <span class="hljs-built_in">matmul</span>(a, b)<br>   <span class="hljs-built_in">Print</span>*, <span class="hljs-string">&#x27;Matrix Multiplication: Result Matrix&#x27;</span><br>   <br>   <span class="hljs-keyword">do</span> i = <span class="hljs-number">1</span>, <span class="hljs-number">3</span><br>      <span class="hljs-keyword">do</span> j = <span class="hljs-number">1</span>, <span class="hljs-number">3</span><br>         <span class="hljs-built_in">print</span>*, c(i, j)<br>      <span class="hljs-keyword">end</span> <span class="hljs-keyword">do</span><br>   <span class="hljs-keyword">end</span> <span class="hljs-keyword">do</span><br>   <br><span class="hljs-keyword">end</span> <span class="hljs-function"><span class="hljs-keyword">program</span></span> matMulProduct<br></code></pre></td></tr></table></figure><p>​ 当上述代码被编译和执行时，它产生了以下结果：</p><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs gauss"><span class="hljs-keyword">Matrix</span> Multiplication: A <span class="hljs-keyword">Matrix</span><br><span class="hljs-number">2</span><br><span class="hljs-number">3</span><br><span class="hljs-number">4</span><br><span class="hljs-number">3</span><br><span class="hljs-number">4</span><br><span class="hljs-number">5</span><br><span class="hljs-number">4</span><br><span class="hljs-number">5</span><br><span class="hljs-number">6</span><br> <span class="hljs-keyword">Matrix</span> Multiplication: B <span class="hljs-keyword">Matrix</span><br><span class="hljs-number">1</span><br><span class="hljs-number">2</span><br><span class="hljs-number">3</span><br><span class="hljs-number">2</span><br><span class="hljs-number">4</span><br><span class="hljs-number">6</span><br><span class="hljs-number">3</span><br><span class="hljs-number">6</span><br><span class="hljs-number">9</span><br><span class="hljs-keyword">Matrix</span> Multiplication: Result <span class="hljs-keyword">Matrix</span><br><span class="hljs-number">20</span><br><span class="hljs-number">40</span><br><span class="hljs-number">60</span><br><span class="hljs-number">26</span><br><span class="hljs-number">52</span><br><span class="hljs-number">78</span><br><span class="hljs-number">32</span><br><span class="hljs-number">64</span><br><span class="hljs-number">96</span><br></code></pre></td></tr></table></figure><h2 id="还原函数">还原函数</h2><p><strong>下表描述了还原功能</strong>：</p><table><thead><tr class="header"><th>函数</th><th>描述</th></tr></thead><tbody><tr class="odd"><td><strong>all</strong>(mask, dim)</td><td>它返回一个逻辑值，指明掩码的所有关系是.true。以及只有所需的维度，如果第二个参数是给定的。</td></tr><tr class="even"><td><strong>any</strong>(mask, dim)</td><td>它返回一个逻辑值，指明掩码的任何关系是.true。以及只有所需的维度，如果第二个参数是给定的。</td></tr><tr class="odd"><td><strong>count</strong>(mask, dim)</td><td>它返回一个数字值，该值为掩码为 .true关系的数目。以及所需的维数，如果第二个参数给出。</td></tr><tr class="even"><td><strong>maxval</strong>(array, dim, mask)</td><td>它返回的数组的数组中最大的值，那些遵守于第三个参数掩码的关系，如果一个给定的，以及具有只有所需的维数，如果第二个参数dim给出的。</td></tr><tr class="odd"><td><strong>minval</strong>(array, dim, mask)</td><td>它返回数组的数组中那些遵守于第三个参数掩码的关系的最小值，如果一个给定的，以及具有仅在第二个参数dim 给出所期望的维度。</td></tr><tr class="even"><td><strong>product</strong>(array, dim, mask)</td><td>它返回该产品遵守于第三个参数掩码的关系，如果一个给定的，以及具有只有所需的维数，如果第二个参数dim 给出的所有数组的数组中的元素，。</td></tr><tr class="odd"><td><strong>sum </strong>(array, dim, mask)</td><td>它返回遵守于第三个参数掩码关系的总和，如果给定以及具有只有所需的维数，如果第二个参数dim给出的所有数组的数组中的元素。</td></tr></tbody></table><p>​ 例子</p><p>​ 下面的例子演示了这一概念：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">program</span> arrayReduction<br><br>   <span class="hljs-attribute">real</span>, dimension(<span class="hljs-number">3</span>,<span class="hljs-number">2</span>) :: a <br>   <span class="hljs-attribute">a</span> = reshape( (/<span class="hljs-number">5</span>,<span class="hljs-number">9</span>,<span class="hljs-number">6</span>,<span class="hljs-number">10</span>,<span class="hljs-number">8</span>,<span class="hljs-number">12</span>/), (/<span class="hljs-number">3</span>,<span class="hljs-number">2</span>/) ) <br>   <br>   <span class="hljs-attribute">Print</span> *, <span class="hljs-literal">all</span>(a&gt;<span class="hljs-number">5</span>)<br>   <span class="hljs-attribute">Print</span> *, any(a&gt;<span class="hljs-number">5</span>)<br>   <span class="hljs-attribute">Print</span> *, count(a&gt;<span class="hljs-number">5</span>)<br>   <span class="hljs-attribute">Print</span> *, <span class="hljs-literal">all</span>(a&gt;=<span class="hljs-number">5</span> .and. a&lt;<span class="hljs-number">10</span>)<br>  <br><span class="hljs-attribute">end</span> program arrayReduction<br></code></pre></td></tr></table></figure><p>​ 当上述代码被编译和执行时，它产生了以下结果：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs r"><span class="hljs-built_in">F</span><br><span class="hljs-built_in">T</span><br><span class="hljs-number">5</span><br><span class="hljs-built_in">F</span><br></code></pre></td></tr></table></figure><p>​ <strong>实例</strong></p><p>​ 下面的例子演示了这一概念：</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs fortran"><span class="hljs-function"><span class="hljs-keyword">program</span></span> arrayReduction<br><span class="hljs-keyword">implicit</span> <span class="hljs-keyword">none</span><br><br>   <span class="hljs-keyword">real</span>, <span class="hljs-keyword">dimension</span>(<span class="hljs-number">1</span>:<span class="hljs-number">6</span>) :: a = (/ <span class="hljs-number">21.0</span>, <span class="hljs-number">12.0</span>,<span class="hljs-number">33.0</span>, <span class="hljs-number">24.0</span>, <span class="hljs-number">15.0</span>, <span class="hljs-number">16.0</span> /)<br>   <span class="hljs-built_in">Print</span> *, <span class="hljs-built_in">maxval</span>(a)<br>   <span class="hljs-built_in">Print</span> *, <span class="hljs-built_in">minval</span>(a)<br>   <span class="hljs-built_in">Print</span> *, <span class="hljs-built_in">sum</span>(a)<br>   <span class="hljs-built_in">Print</span> *, <span class="hljs-built_in">product</span>(a)<br>   <br><span class="hljs-keyword">end</span> <span class="hljs-function"><span class="hljs-keyword">program</span></span> arrayReduction <br></code></pre></td></tr></table></figure><p>​ 当上述代码被编译和执行时，它产生了以下结果：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">33</span>.<span class="hljs-number">0000000</span>    <br><span class="hljs-attribute">12</span>.<span class="hljs-number">0000000</span>    <br><span class="hljs-attribute">121</span>.<span class="hljs-number">000000</span>    <br><span class="hljs-attribute">47900160</span>.<span class="hljs-number">0</span> <br></code></pre></td></tr></table></figure><h2 id="查询函数">查询函数</h2><p>下表描述了查询功能：</p><table><thead><tr class="header"><th>函数</th><th>描述</th></tr></thead><tbody><tr class="odd"><td><strong>allocated</strong>(array)</td><td>它是一个逻辑功能，它指示该阵列被分配。</td></tr><tr class="even"><td><strong>lbound</strong>(array, dim)</td><td>它返回的数组的维数较低的限制。如果dim(尺寸)不给出一个参数，会得到一个整数向量，如果dim计算在内，得到的整数值正好具有较低维数的限制。</td></tr><tr class="odd"><td><strong>shape</strong>(source)</td><td>它返回一个阵列源为一个整数向量的形状。</td></tr><tr class="even"><td><strong>size</strong>(array, dim)</td><td>它返回在数组元素的数目。如果dim没有给出，并在相关维数的元素个数，如果dim也包括在内。</td></tr><tr class="odd"><td><strong>ubound</strong>(array, dim)</td><td>它返回尺寸的限制。</td></tr></tbody></table><p>​ 例子</p><p>​ 下面的例子演示了这一概念：</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs fortran"><span class="hljs-function"><span class="hljs-keyword">program</span></span> arrayInquiry<br><br>   <span class="hljs-keyword">real</span>, <span class="hljs-keyword">dimension</span>(<span class="hljs-number">3</span>,<span class="hljs-number">2</span>) :: a <br>   a = <span class="hljs-built_in">reshape</span>( (/<span class="hljs-number">5</span>,<span class="hljs-number">9</span>,<span class="hljs-number">6</span>,<span class="hljs-number">10</span>,<span class="hljs-number">8</span>,<span class="hljs-number">12</span>/), (/<span class="hljs-number">3</span>,<span class="hljs-number">2</span>/) ) <br>   <br>   <span class="hljs-built_in">Print</span> *, <span class="hljs-built_in">lbound</span>(a, <span class="hljs-built_in">dim</span>=<span class="hljs-number">1</span>)<br>   <span class="hljs-built_in">Print</span> *, <span class="hljs-built_in">ubound</span>(a, <span class="hljs-built_in">dim</span>=<span class="hljs-number">1</span>)<br>   <span class="hljs-built_in">Print</span> *, <span class="hljs-built_in">shape</span>(a)<br>   <span class="hljs-built_in">Print</span> *, <span class="hljs-built_in">size</span>(a,<span class="hljs-built_in">dim</span>=<span class="hljs-number">1</span>)<br>   <br><span class="hljs-keyword">end</span> <span class="hljs-function"><span class="hljs-keyword">program</span></span> arrayInquiry<br></code></pre></td></tr></table></figure><p>​ 当上述代码被编译和执行时，它产生了以下结果：</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-number">1</span><br><span class="hljs-number">3</span><br><span class="hljs-symbol">3 </span><span class="hljs-number">2</span><br><span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><h2 id="构造函数">构造函数</h2><p>下表介绍了结构功能：</p><table><thead><tr class="header"><th>函数</th><th>描述</th></tr></thead><tbody><tr class="odd"><td><strong>merge</strong>(tsource, fsource, mask)</td><td>该功能连接两个阵列。它给出了tsource及元素，如果mask条件是.true。如果掩码的条件是.false。这两个字段tsource和fsource必须是相同的类型并具有相同的形状。其结果也就是这种类型和形状。还掩码必须具有相同的形状。</td></tr><tr class="even"><td><strong>pack</strong>(array, mask, vector)</td><td>它包一个阵列，以使用掩码的控制向量。逻辑阵列掩模的形状，具有以符合一个用于阵列，要不然掩码必须是一个标量。如果载体被包括在内，它必须是秩1与至少一样多的元素是在掩码为真，并且具有相同的类型的数组的数组(即一个向量)。如果掩码的值为.true。然后矢量代替必须的元件阵列的数量相同。</td></tr><tr class="odd"><td><strong>spread</strong>(source, dim, ncopies)</td><td>它返回相同类型作为参数源与秩增加一个阵列。参数dim和ncopies都是整数。如果ncopies是负则用零值来代替。如果source是一个标量，然后扩散变得所有具有相同值ncopies 元素的向量。参数dim指示哪个索引将被延长。它必须是范围为1和1+(源级)中，如果 source是一个标量，dim 必须是1。参数 ncopies 是在新的尺寸元素的数量。</td></tr><tr class="even"><td><strong>unpack</strong>(vector, mask, array)</td><td>它散射一个载体，掩码下的控制阵列。逻辑阵列掩模的形状具有以符合一个用于数组。阵列载体必须具有等级1(即它是一个向量)与至少一样多的元素是那些掩码内值都为true，并且还必须具有相同类型阵列。如果阵列被给定为一个标量，然后它被认为是使用相同形状的掩码，并在同一标量元素无处不在的阵列。其结果将是具有相同形状的掩码和类型相同的矢量阵列。该值将是那些从所接受的载体，而在阵列的剩余位置的旧值被保留。</td></tr></tbody></table><p>​ <strong>示例</strong></p><p>​ 下面的例子演示了这一概念：</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs fortran"><span class="hljs-function"><span class="hljs-keyword">program</span></span> arrayConstruction<br><span class="hljs-keyword">implicit</span> <span class="hljs-keyword">none</span><br>   <span class="hljs-keyword">interface</span><br>      <span class="hljs-function"><span class="hljs-keyword">subroutine</span></span> write_array (a)<br>         <span class="hljs-keyword">real</span> :: a(:,:)<br>      <span class="hljs-keyword">end</span> <span class="hljs-function"><span class="hljs-keyword">subroutine</span></span> write_array<br>      <br>      <span class="hljs-function"><span class="hljs-keyword">subroutine</span></span> write_l_array (a)<br>         <span class="hljs-keyword">logical</span> :: a(:,:)<br>      <span class="hljs-keyword">end</span> <span class="hljs-function"><span class="hljs-keyword">subroutine</span></span> write_l_array<br>   <span class="hljs-keyword">end</span> <span class="hljs-keyword">interface</span><br><br>   <span class="hljs-keyword">real</span>, <span class="hljs-keyword">dimension</span>(<span class="hljs-number">2</span>,<span class="hljs-number">3</span>) :: tsource, fsource, result<br>   <span class="hljs-keyword">logical</span>, <span class="hljs-keyword">dimension</span>(<span class="hljs-number">2</span>,<span class="hljs-number">3</span>) :: mask<br>   <br>   tsource = <span class="hljs-built_in">reshape</span>( (/ <span class="hljs-number">35</span>, <span class="hljs-number">23</span>, <span class="hljs-number">18</span>, <span class="hljs-number">28</span>, <span class="hljs-number">26</span>, <span class="hljs-number">39</span> /), &amp;<br>                    (/ <span class="hljs-number">2</span>, <span class="hljs-number">3</span> /) )<br>   fsource = <span class="hljs-built_in">reshape</span>( (/ -<span class="hljs-number">35</span>, -<span class="hljs-number">23</span>, -<span class="hljs-number">18</span>, -<span class="hljs-number">28</span>, -<span class="hljs-number">26</span>, -<span class="hljs-number">39</span> /), &amp;<br>                    (/ <span class="hljs-number">2</span>,<span class="hljs-number">3</span> /) )<br>   mask = <span class="hljs-built_in">reshape</span>( (/ .true., .false., .false., .true., &amp;<br>                 .false., .false. /), (/ <span class="hljs-number">2</span>,<span class="hljs-number">3</span> /) )<br><br>   result = <span class="hljs-built_in">merge</span>(tsource, fsource, mask)<br>   <span class="hljs-keyword">call</span> write_array(tsource)<br>   <span class="hljs-keyword">call</span> write_array(fsource)<br>   <span class="hljs-keyword">call</span> write_l_array(mask)<br>   <span class="hljs-keyword">call</span> write_array(result)<br>   <br><span class="hljs-keyword">end</span> <span class="hljs-function"><span class="hljs-keyword">program</span></span> arrayConstruction<br><br><br><br><span class="hljs-function"><span class="hljs-keyword">subroutine</span></span> write_array (a)<br><br>   <span class="hljs-keyword">real</span> :: a(:,:)<br>   <span class="hljs-keyword">do</span> i = <span class="hljs-built_in">lbound</span>(a,<span class="hljs-number">1</span>), <span class="hljs-built_in">ubound</span>(a,<span class="hljs-number">1</span>)<br>      <span class="hljs-built_in">write</span>(*,*) (a(i, j), j = <span class="hljs-built_in">lbound</span>(a,<span class="hljs-number">2</span>), <span class="hljs-built_in">ubound</span>(a,<span class="hljs-number">2</span>) )<br>   <span class="hljs-keyword">end</span> <span class="hljs-keyword">do</span><br>   <span class="hljs-keyword">return</span><br>   <br><span class="hljs-keyword">end</span> <span class="hljs-function"><span class="hljs-keyword">subroutine</span></span> write_array<br><br><br><span class="hljs-function"><span class="hljs-keyword">subroutine</span></span> write_l_array (a)<br><br>   <span class="hljs-keyword">logical</span> :: a(:,:)<br>   <span class="hljs-keyword">do</span> i = <span class="hljs-built_in">lbound</span>(a,<span class="hljs-number">1</span>), <span class="hljs-built_in">ubound</span>(a,<span class="hljs-number">1</span>)<br>      <span class="hljs-built_in">write</span>(*,*) (a(i, j), j= <span class="hljs-built_in">lbound</span>(a,<span class="hljs-number">2</span>), <span class="hljs-built_in">ubound</span>(a,<span class="hljs-number">2</span>))<br>   <span class="hljs-keyword">end</span> <span class="hljs-keyword">do</span><br>   <span class="hljs-keyword">return</span><br>   <br><span class="hljs-keyword">end</span> <span class="hljs-function"><span class="hljs-keyword">subroutine</span></span> write_l_array<br></code></pre></td></tr></table></figure><p>​ 当上述代码被编译和执行时，它产生了以下结果：</p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs dns"><span class="hljs-number">35.0000000</span>   <span class="hljs-number">18.0000000</span>   <span class="hljs-number">26.0000000</span>    <br><span class="hljs-number">23.0000000</span>   <span class="hljs-number">28.0000000</span>   <span class="hljs-number">39.0000000</span>    <br>-<span class="hljs-number">35.0000000</span>  -<span class="hljs-number">18.0000000</span>  -<span class="hljs-number">26.0000000</span>    <br>-<span class="hljs-number">23.0000000</span>  -<span class="hljs-number">28.0000000</span>  -<span class="hljs-number">39.0000000</span>    <br>T F F<br>F T F<br><span class="hljs-number">35.0000000</span>   -<span class="hljs-number">18.0000000</span>  -<span class="hljs-number">26.0000000</span>    <br></code></pre></td></tr></table></figure><h2 id="重塑函数">重塑函数</h2><p>下表描述了重塑函数：</p><table><thead><tr class="header"><th>函数</th><th>描述</th></tr></thead><tbody><tr class="odd"><td><strong>reshape</strong>(source, shape, pad, order)</td><td>它构造一个特定形状的形状，从一个给定source阵列中的元素开始的数组。如果垫不包含则soure的尺寸必须至少为产物(形状)。如果pad包括在内，它必须具有相同的类型的soure。如果order被包括，它必须使用相同的形状的形状的整数数组，值必须是一个排列(1,2,3，...，n)，其中n是在形状要素的数量，它必须小于或等于7。</td></tr></tbody></table><p>​ <strong>示例</strong></p><p>​ 下面的例子演示了这一概念：</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs fortran"><span class="hljs-function"><span class="hljs-keyword">program</span></span> arrayReshape<br><span class="hljs-keyword">implicit</span> <span class="hljs-keyword">none</span><br><br><span class="hljs-keyword">interface</span><br>   <span class="hljs-function"><span class="hljs-keyword">subroutine</span></span> write_matrix(a)<br>   <span class="hljs-keyword">real</span>, <span class="hljs-keyword">dimension</span>(:,:) :: a<br>   <span class="hljs-keyword">end</span> <span class="hljs-function"><span class="hljs-keyword">subroutine</span></span> write_matrix<br>   <span class="hljs-keyword">end</span> <span class="hljs-keyword">interface</span><br><br>   <span class="hljs-keyword">real</span>, <span class="hljs-keyword">dimension</span> (<span class="hljs-number">1</span>:<span class="hljs-number">9</span>) :: b = (/ <span class="hljs-number">21</span>, <span class="hljs-number">22</span>, <span class="hljs-number">23</span>, <span class="hljs-number">24</span>, <span class="hljs-number">25</span>, <span class="hljs-number">26</span>, <span class="hljs-number">27</span>, <span class="hljs-number">28</span>, <span class="hljs-number">29</span> /)<br>   <span class="hljs-keyword">real</span>, <span class="hljs-keyword">dimension</span> (<span class="hljs-number">1</span>:<span class="hljs-number">3</span>, <span class="hljs-number">1</span>:<span class="hljs-number">3</span>) :: c, d, e<br>   <span class="hljs-keyword">real</span>, <span class="hljs-keyword">dimension</span> (<span class="hljs-number">1</span>:<span class="hljs-number">4</span>, <span class="hljs-number">1</span>:<span class="hljs-number">4</span>) :: f, g, h<br><br>   <span class="hljs-keyword">integer</span>, <span class="hljs-keyword">dimension</span> (<span class="hljs-number">1</span>:<span class="hljs-number">2</span>) :: order1 = (/ <span class="hljs-number">1</span>, <span class="hljs-number">2</span> /)<br>   <span class="hljs-keyword">integer</span>, <span class="hljs-keyword">dimension</span> (<span class="hljs-number">1</span>:<span class="hljs-number">2</span>) :: order2 = (/ <span class="hljs-number">2</span>, <span class="hljs-number">1</span> /)<br>   <span class="hljs-keyword">real</span>, <span class="hljs-keyword">dimension</span> (<span class="hljs-number">1</span>:<span class="hljs-number">16</span>) :: pad1 = (/ -<span class="hljs-number">1</span>, -<span class="hljs-number">2</span>, -<span class="hljs-number">3</span>, -<span class="hljs-number">4</span>, -<span class="hljs-number">5</span>, -<span class="hljs-number">6</span>, -<span class="hljs-number">7</span>, -<span class="hljs-number">8</span>, &amp;<br>                                 &amp; -<span class="hljs-number">9</span>, -<span class="hljs-number">10</span>, -<span class="hljs-number">11</span>, -<span class="hljs-number">12</span>, -<span class="hljs-number">13</span>, -<span class="hljs-number">14</span>, -<span class="hljs-number">15</span>, -<span class="hljs-number">16</span> /)<br><br>   c = <span class="hljs-built_in">reshape</span>( b, (/ <span class="hljs-number">3</span>, <span class="hljs-number">3</span> /) )<br>   <span class="hljs-keyword">call</span> write_matrix(c)<br><br>   d = <span class="hljs-built_in">reshape</span>( b, (/ <span class="hljs-number">3</span>, <span class="hljs-number">3</span> /), order = order1)<br>   <span class="hljs-keyword">call</span> write_matrix(d)<br><br>   e = <span class="hljs-built_in">reshape</span>( b, (/ <span class="hljs-number">3</span>, <span class="hljs-number">3</span> /), order = order2)<br>   <span class="hljs-keyword">call</span> write_matrix(e)<br><br>   f = <span class="hljs-built_in">reshape</span>( b, (/ <span class="hljs-number">4</span>, <span class="hljs-number">4</span> /), <span class="hljs-keyword">pad</span> = pad1)<br>   <span class="hljs-keyword">call</span> write_matrix(f)<br><br>   g = <span class="hljs-built_in">reshape</span>( b, (/ <span class="hljs-number">4</span>, <span class="hljs-number">4</span> /), <span class="hljs-keyword">pad</span> = pad1, order = order1)<br>   <span class="hljs-keyword">call</span> write_matrix(g)<br><br>   h = <span class="hljs-built_in">reshape</span>( b, (/ <span class="hljs-number">4</span>, <span class="hljs-number">4</span> /), <span class="hljs-keyword">pad</span> = pad1, order = order2)<br>   <span class="hljs-keyword">call</span> write_matrix(h)<br><br><span class="hljs-keyword">end</span> <span class="hljs-function"><span class="hljs-keyword">program</span></span> arrayReshape<br><br><br><span class="hljs-function"><span class="hljs-keyword">subroutine</span></span> write_matrix(a)<br>   <span class="hljs-keyword">real</span>, <span class="hljs-keyword">dimension</span>(:,:) :: a<br>   <span class="hljs-built_in">write</span>(*,*)<br>   <br>   <span class="hljs-keyword">do</span> i = <span class="hljs-built_in">lbound</span>(a,<span class="hljs-number">1</span>), <span class="hljs-built_in">ubound</span>(a,<span class="hljs-number">1</span>)<br>      <span class="hljs-built_in">write</span>(*,*) (a(i,j), j = <span class="hljs-built_in">lbound</span>(a,<span class="hljs-number">2</span>), <span class="hljs-built_in">ubound</span>(a,<span class="hljs-number">2</span>))<br>   <span class="hljs-keyword">end</span> <span class="hljs-keyword">do</span><br><span class="hljs-keyword">end</span> <span class="hljs-function"><span class="hljs-keyword">subroutine</span></span> write_matrix<br></code></pre></td></tr></table></figure><p>​ 当上述代码被编译和执行时，它产生了以下结果：</p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs dns"><span class="hljs-number">21.0000000</span>  <span class="hljs-number">24.0000000</span>  <span class="hljs-number">27.0000000</span>    <br><span class="hljs-number">22.0000000</span>  <span class="hljs-number">25.0000000</span>  <span class="hljs-number">28.0000000</span>    <br><span class="hljs-number">23.0000000</span>  <span class="hljs-number">26.0000000</span>  <span class="hljs-number">29.0000000</span>    <br><br><span class="hljs-number">21.0000000</span>  <span class="hljs-number">24.0000000</span>  <span class="hljs-number">27.0000000</span>    <br><span class="hljs-number">22.0000000</span>  <span class="hljs-number">25.0000000</span>  <span class="hljs-number">28.0000000</span>    <br><span class="hljs-number">23.0000000</span>  <span class="hljs-number">26.0000000</span>  <span class="hljs-number">29.0000000</span>    <br><br><span class="hljs-number">21.0000000</span>  <span class="hljs-number">22.0000000</span>  <span class="hljs-number">23.0000000</span>    <br><span class="hljs-number">24.0000000</span>  <span class="hljs-number">25.0000000</span>  <span class="hljs-number">26.0000000</span>    <br><span class="hljs-number">27.0000000</span>  <span class="hljs-number">28.0000000</span>  <span class="hljs-number">29.0000000</span>    <br><br><span class="hljs-number">21.0000000</span>  <span class="hljs-number">25.0000000</span>  <span class="hljs-number">29.0000000</span>   -<span class="hljs-number">4.00000000</span>    <br><span class="hljs-number">22.0000000</span>  <span class="hljs-number">26.0000000</span>  -<span class="hljs-number">1.00000000</span>  -<span class="hljs-number">5.00000000</span>    <br><span class="hljs-number">23.0000000</span>  <span class="hljs-number">27.0000000</span>  -<span class="hljs-number">2.00000000</span>  -<span class="hljs-number">6.00000000</span>    <br><span class="hljs-number">24.0000000</span>  <span class="hljs-number">28.0000000</span>  -<span class="hljs-number">3.00000000</span>  -<span class="hljs-number">7.00000000</span>    <br><br><span class="hljs-number">21.0000000</span>  <span class="hljs-number">25.0000000</span>  <span class="hljs-number">29.0000000</span>   -<span class="hljs-number">4.00000000</span>    <br><span class="hljs-number">22.0000000</span>  <span class="hljs-number">26.0000000</span>  -<span class="hljs-number">1.00000000</span>  -<span class="hljs-number">5.00000000</span>    <br><span class="hljs-number">23.0000000</span>  <span class="hljs-number">27.0000000</span>  -<span class="hljs-number">2.00000000</span>  -<span class="hljs-number">6.00000000</span>    <br><span class="hljs-number">24.0000000</span>  <span class="hljs-number">28.0000000</span>  -<span class="hljs-number">3.00000000</span>  -<span class="hljs-number">7.00000000</span>    <br><br><span class="hljs-number">21.0000000</span>  <span class="hljs-number">22.0000000</span>  <span class="hljs-number">23.0000000</span>   <span class="hljs-number">24.0000000</span>    <br><span class="hljs-number">25.0000000</span>  <span class="hljs-number">26.0000000</span>  <span class="hljs-number">27.0000000</span>   <span class="hljs-number">28.0000000</span>    <br><span class="hljs-number">29.0000000</span>  -<span class="hljs-number">1.00000000</span> -<span class="hljs-number">2.00000000</span>  -<span class="hljs-number">3.00000000</span>    <br>-<span class="hljs-number">4.00000000</span> -<span class="hljs-number">5.00000000</span> -<span class="hljs-number">6.00000000</span>  -<span class="hljs-number">7.00000000</span>  <br></code></pre></td></tr></table></figure><h2 id="操作函数">操作函数</h2><p>处理函数平移功能。移位函数返回一个数组不变的形状，但移动元素。</p><table><thead><tr class="header"><th>函数</th><th>描述</th></tr></thead><tbody><tr class="odd"><td><strong>cshift</strong>(array, shift, dim)</td><td>它执行循环移位由移位置的左边，如果移位是正和到右侧，如果它是负的。如果阵列是一个矢量移位正在做以自然的方式中，如果它是一个较高级的阵列则移是沿着维数dim的所有部分。若dim缺少它被认为是1，在其它情况下它必须是1和n(其中n等于阵列的等级)之间的标量整数。该参数换档是一个标量整数或秩n-1个整数的数组和形状相同的阵列中，除沿维数dim(在较低级的，因为它被移除)。不同的部分，因此可以转移在各个方向上，并与各种数目的位置。</td></tr><tr class="even"><td><strong>eoshift</strong>(array, shift, boundary, dim)</td><td>这是端关闭的转变。它执行向左移动，如果移位是正和到右侧，如果它是负的。相反的元素移出新元素均取自边界。如果阵列是一个矢量移位正在做以自然的方式中，如果它是一个较高级的阵列，在所有各节中的移位是以及该维度暗淡。若dim丢失，它被认为是1，但在其它情况下，它为1和n(其中n等于阵列的秩)之间有一个标量的整数值。该参数换档是一个标量整数，如果阵列具有秩1，在其他情况下，它可以是一个标量整数或秩n-1和形状相同的阵列排列的与除沿维数dim的整数数组(其被取出因为较低级的)。</td></tr><tr class="odd"><td><strong>transpose </strong>(matrix)</td><td>其转置矩阵，这是秩2的阵列它取代了的行和列矩阵。</td></tr></tbody></table><p>​ <strong>示例</strong></p><p>​ 下面的例子演示了这一概念：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">program</span> arrayShift<br><span class="hljs-attribute">implicit</span> none<br><br>   <span class="hljs-attribute">real</span>, dimension(<span class="hljs-number">1</span>:<span class="hljs-number">6</span>) :: a = (/ <span class="hljs-number">21</span>.<span class="hljs-number">0</span>, <span class="hljs-number">22</span>.<span class="hljs-number">0</span>, <span class="hljs-number">23</span>.<span class="hljs-number">0</span>, <span class="hljs-number">24</span>.<span class="hljs-number">0</span>, <span class="hljs-number">25</span>.<span class="hljs-number">0</span>, <span class="hljs-number">26</span>.<span class="hljs-number">0</span> /)<br>   <span class="hljs-attribute">real</span>, dimension(<span class="hljs-number">1</span>:<span class="hljs-number">6</span>) :: x, y<br>   <span class="hljs-attribute">write</span>(*,<span class="hljs-number">10</span>) a<br>   <br>   <span class="hljs-attribute">x</span> = cshift ( a, shift = <span class="hljs-number">2</span>)<br>   <span class="hljs-attribute">write</span>(*,<span class="hljs-number">10</span>) x<br>   <br>   <span class="hljs-attribute">y</span> = cshift (a, shift = -<span class="hljs-number">2</span>)<br>   <span class="hljs-attribute">write</span>(*,<span class="hljs-number">10</span>) y<br>   <br>   <span class="hljs-attribute">x</span> = eoshift ( a, shift = <span class="hljs-number">2</span>)<br>   <span class="hljs-attribute">write</span>(*,<span class="hljs-number">10</span>) x<br>   <br>   <span class="hljs-attribute">y</span> = eoshift ( a, shift = -<span class="hljs-number">2</span>)<br>   <span class="hljs-attribute">write</span>(*,<span class="hljs-number">10</span>) y<br>   <br>   <span class="hljs-attribute">10</span> format(<span class="hljs-number">1</span>x,<span class="hljs-number">6</span>f6.<span class="hljs-number">1</span>)<br><br><span class="hljs-attribute">end</span> program arrayShift<br></code></pre></td></tr></table></figure><p>​ 当上述代码被编译和执行时，它产生了以下结果：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">21</span>.<span class="hljs-number">0</span>  <span class="hljs-number">22</span>.<span class="hljs-number">0</span>  <span class="hljs-number">23</span>.<span class="hljs-number">0</span>  <span class="hljs-number">24</span>.<span class="hljs-number">0</span>  <span class="hljs-number">25</span>.<span class="hljs-number">0</span>  <span class="hljs-number">26</span>.<span class="hljs-number">0</span><br><span class="hljs-attribute">23</span>.<span class="hljs-number">0</span>  <span class="hljs-number">24</span>.<span class="hljs-number">0</span>  <span class="hljs-number">25</span>.<span class="hljs-number">0</span>  <span class="hljs-number">26</span>.<span class="hljs-number">0</span>  <span class="hljs-number">21</span>.<span class="hljs-number">0</span>  <span class="hljs-number">22</span>.<span class="hljs-number">0</span><br><span class="hljs-attribute">25</span>.<span class="hljs-number">0</span>  <span class="hljs-number">26</span>.<span class="hljs-number">0</span>  <span class="hljs-number">21</span>.<span class="hljs-number">0</span>  <span class="hljs-number">22</span>.<span class="hljs-number">0</span>  <span class="hljs-number">23</span>.<span class="hljs-number">0</span>  <span class="hljs-number">24</span>.<span class="hljs-number">0</span><br><span class="hljs-attribute">23</span>.<span class="hljs-number">0</span>  <span class="hljs-number">24</span>.<span class="hljs-number">0</span>  <span class="hljs-number">25</span>.<span class="hljs-number">0</span>  <span class="hljs-number">26</span>.<span class="hljs-number">0</span>   <span class="hljs-number">0</span>.<span class="hljs-number">0</span>   <span class="hljs-number">0</span>.<span class="hljs-number">0</span><br><span class="hljs-attribute">0</span>.<span class="hljs-number">0</span>    <span class="hljs-number">0</span>.<span class="hljs-number">0</span>  <span class="hljs-number">21</span>.<span class="hljs-number">0</span>  <span class="hljs-number">22</span>.<span class="hljs-number">0</span>  <span class="hljs-number">23</span>.<span class="hljs-number">0</span>  <span class="hljs-number">24</span>.<span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p>​ <strong>示例</strong></p><p>​ 下面的例子演示了转置矩阵：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">program matrixTranspose<br>implicit none<br><br>   <span class="hljs-keyword">interface</span><br>      <span class="hljs-symbol">subroutine</span> <span class="hljs-symbol">write_matrix</span>(<span class="hljs-symbol">a</span>)<br>         <span class="hljs-symbol">integer</span>, <span class="hljs-symbol">dimension</span>(:,:) :: <span class="hljs-symbol">a</span><br>      <span class="hljs-symbol">end</span> <span class="hljs-symbol">subroutine</span> <span class="hljs-symbol">write_matrix</span><br>   <span class="hljs-symbol">end</span> <span class="hljs-symbol">interface</span><br><br>   <span class="hljs-symbol">integer</span>, <span class="hljs-symbol">dimension</span>(<span class="hljs-symbol">3</span>,<span class="hljs-symbol">3</span>) :: <span class="hljs-symbol">a</span>, <span class="hljs-symbol">b</span><br>   <span class="hljs-symbol">integer</span> :: <span class="hljs-symbol">i</span>, <span class="hljs-symbol">j</span><br>    <br>   <span class="hljs-symbol">do</span> <span class="hljs-symbol">i</span> = <span class="hljs-symbol">1</span>, <span class="hljs-symbol">3</span><br>      <span class="hljs-symbol">do</span> <span class="hljs-symbol">j</span> = <span class="hljs-symbol">1</span>, <span class="hljs-symbol">3</span><br>         <span class="hljs-symbol">a</span>(<span class="hljs-symbol">i</span>, <span class="hljs-symbol">j</span>) = <span class="hljs-symbol">i</span><br>      <span class="hljs-symbol">end</span> <span class="hljs-symbol">do</span><br>   <span class="hljs-symbol">end</span> <span class="hljs-symbol">do</span><br>   <br>   <span class="hljs-symbol">print</span> *, &#x27;<span class="hljs-symbol">Matrix</span> <span class="hljs-symbol">Transpose</span>: <span class="hljs-symbol">A</span> <span class="hljs-symbol">Matrix</span>&#x27;<br>   <br>   <span class="hljs-symbol">call</span> <span class="hljs-symbol">write_matrix</span>(<span class="hljs-symbol">a</span>)<br>   <span class="hljs-symbol">b</span> = <span class="hljs-symbol">transpose</span>(<span class="hljs-symbol">a</span>)<br>   <span class="hljs-symbol">print</span> *, &#x27;<span class="hljs-symbol">Transposed</span> <span class="hljs-symbol">Matrix</span>:&#x27;<br>   <br>   <span class="hljs-symbol">call</span> <span class="hljs-symbol">write_matrix</span>(<span class="hljs-symbol">b</span>)<br><span class="hljs-symbol">end</span> <span class="hljs-symbol">program</span> <span class="hljs-symbol">matrixTranspose</span><br><br><br><span class="hljs-symbol">subroutine</span> <span class="hljs-symbol">write_matrix</span>(<span class="hljs-symbol">a</span>)<br><br>   <span class="hljs-symbol">integer</span>, <span class="hljs-symbol">dimension</span>(:,:) :: <span class="hljs-symbol">a</span><br>   <span class="hljs-symbol">write</span>(*,*)<br>   <br>   <span class="hljs-symbol">do</span> <span class="hljs-symbol">i</span> = <span class="hljs-symbol">lbound</span>(<span class="hljs-symbol">a</span>,<span class="hljs-symbol">1</span>), <span class="hljs-symbol">ubound</span>(<span class="hljs-symbol">a</span>,<span class="hljs-symbol">1</span>)<br>      <span class="hljs-symbol">write</span>(*,*) (<span class="hljs-symbol">a</span>(<span class="hljs-symbol">i</span>,<span class="hljs-symbol">j</span>), <span class="hljs-symbol">j</span> = <span class="hljs-symbol">lbound</span>(<span class="hljs-symbol">a</span>,<span class="hljs-symbol">2</span>), <span class="hljs-symbol">ubound</span>(<span class="hljs-symbol">a</span>,<span class="hljs-symbol">2</span>))<br>   <span class="hljs-symbol">end</span> <span class="hljs-symbol">do</span><br>   <br><span class="hljs-symbol">end</span> <span class="hljs-symbol">subroutine</span> <span class="hljs-symbol">write_matrix</span><br></code></pre></td></tr></table></figure><p>​ 当上述代码被编译和执行时，它产生了以下结果：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">Matrix</span> Transpose: A Matrix<br><br><span class="hljs-attribute">1</span>  <span class="hljs-number">1</span>  <span class="hljs-number">1</span><br><span class="hljs-attribute">2</span>  <span class="hljs-number">2</span>  <span class="hljs-number">2</span><br><span class="hljs-attribute">3</span>  <span class="hljs-number">3</span>  <span class="hljs-number">3</span><br><span class="hljs-attribute">Transposed</span> Matrix:<br><br><span class="hljs-attribute">1</span>  <span class="hljs-number">2</span>  <span class="hljs-number">3</span><br><span class="hljs-attribute">1</span>  <span class="hljs-number">2</span>  <span class="hljs-number">3</span><br><span class="hljs-attribute">1</span>  <span class="hljs-number">2</span>  <span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><h2 id="位置函数">位置函数</h2><p>下表描述了位置函数：</p><table><thead><tr class="header"><th>函数</th><th>描述</th></tr></thead><tbody><tr class="odd"><td><strong>maxloc</strong>(array, mask)</td><td>它返回数组中的最大元素的位置上，如果掩码仅包含那些其中满足条件的掩码，则返回位置，其结果是一个整数向量。</td></tr><tr class="even"><td><strong>minloc</strong>(array, mask)</td><td>它返回数组的数组中的最小元素的位置，如果掩码仅包含那些其中满足条件的掩码，则返回位置，其结果是一个整数向量。</td></tr></tbody></table><p>​ <strong>示例</strong></p><p>​ 下面的例子演示了这一概念：</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs fortran"><span class="hljs-function"><span class="hljs-keyword">program</span></span> arrayLocation<br><span class="hljs-keyword">implicit</span> <span class="hljs-keyword">none</span><br><br>   <span class="hljs-keyword">real</span>, <span class="hljs-keyword">dimension</span>(<span class="hljs-number">1</span>:<span class="hljs-number">6</span>) :: a = (/ <span class="hljs-number">21.0</span>, <span class="hljs-number">12.0</span>,<span class="hljs-number">33.0</span>, <span class="hljs-number">24.0</span>, <span class="hljs-number">15.0</span>, <span class="hljs-number">16.0</span> /)<br>   <span class="hljs-built_in">Print</span> *, <span class="hljs-built_in">maxloc</span>(a)<br>   <span class="hljs-built_in">Print</span> *, <span class="hljs-built_in">minloc</span>(a)<br>   <br><span class="hljs-keyword">end</span> <span class="hljs-function"><span class="hljs-keyword">program</span></span> arrayLocation   <br></code></pre></td></tr></table></figure><p>​ 当上述代码被编译和执行时，它产生了以下结果：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs">3<br>2<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Fortran</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Fortran-子程序</title>
    <link href="/2022/05/23/Fortran-%E5%AD%90%E7%A8%8B%E5%BA%8F/"/>
    <url>/2022/05/23/Fortran-%E5%AD%90%E7%A8%8B%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<p>Fortran 语言中的子程序事实上和其他编程语言的函数有点类似（后面会提到Fortran本身也支持函数）：<strong>把需要重复使用的某些代码都集中成一个子程序，调用时可以给子程序初始化一些变量值从而获得不同的结果</strong>。比如说数值微分或者微分方程组的解法一类的数值计算代码就可以写成子程序的形式。</p><h2 id="定义和调用">定义和调用</h2><p>子程序的一般结构如下所示：</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs Fortran"><span class="hljs-comment">!!! 不带初始化变量的子程序</span><br><span class="hljs-function"><span class="hljs-keyword">subroutine</span></span> subr1<br>    <span class="hljs-keyword">implicit</span> <span class="hljs-keyword">none</span><br>    <span class="hljs-keyword">real</span> a, b<br>    <span class="hljs-keyword">integer</span> i<br>    ......<br>    ......<br><span class="hljs-keyword">end</span> <span class="hljs-function"><span class="hljs-keyword">subroutine</span></span> subr1<br></code></pre></td></tr></table></figure><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs fortran"><span class="hljs-comment">!!! 带初始化变量的子程序</span><br><span class="hljs-function"><span class="hljs-keyword">subroutine</span></span> subr2(x, m, y, n)<br>    <span class="hljs-keyword">implicit</span> <span class="hljs-keyword">none</span><br>    <span class="hljs-keyword">real</span> x, y, a, b, z(<span class="hljs-number">10</span>)<br>    <span class="hljs-keyword">integer</span> m, n, i, k<br>    ......<br>    ......<br><span class="hljs-keyword">end</span> <span class="hljs-function"><span class="hljs-keyword">subroutine</span></span> subr2<br></code></pre></td></tr></table></figure><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs fortran"><span class="hljs-comment">!!! 调用子程序</span><br><span class="hljs-keyword">real</span> z<br><span class="hljs-keyword">integer</span> m<br><span class="hljs-keyword">call</span> subr1<br>m = <span class="hljs-number">21</span><br><span class="hljs-keyword">call</span> subr2(<span class="hljs-number">10.0</span>, <span class="hljs-number">100</span>, z, m*<span class="hljs-number">5</span>+<span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure><p>子程序是以 <code>subroutine</code> 开头、以<code>end subroutine</code>结尾，其中<strong>第一行与一般主程序一样需要添加一行<code>implicit none</code> 的声明</strong>。</p><h5 id="小提示">小提示</h5><p><strong>值得注意</strong>的是，子程序可以在主程序中被任意调用若干次，但同时也是依赖主程序存在的，即<strong>只有子程序的代码无法被执行</strong>。</p><p>从上面的例子可以看出，无论是初始化还是没初始化变量，子程序都可以在主程序中被调用执行。只不过带初始化变量的子程序应该在被调用时给定相应的变量，否则无法正常被调用。</p><p>如下所示是一个完整包含主程序和子程序的代码示例。主程序是以<code>program</code> 开头、以 <code>end program</code>结尾的代码片段。子程序代码不被包含在主程序代码片段中，但与主程序在同一文件中。</p><h5 id="小提示-1">小提示</h5><p><strong>子程序可以位于主程序代码片段之前或之后，不会影响在主程序中的正常调用</strong>。</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs fortran"><span class="hljs-function"><span class="hljs-keyword">program</span></span> stest1<br>    <span class="hljs-keyword">implicit</span> <span class="hljs-keyword">none</span><br>    <span class="hljs-keyword">real</span> x, y<br>    x = <span class="hljs-number">5.0</span><br>    y = <span class="hljs-number">100.0</span><br>    <span class="hljs-keyword">call</span> subr(x, y, <span class="hljs-number">10</span>)<br>    <span class="hljs-built_in">print</span> *, x, y<br><span class="hljs-keyword">end</span> <span class="hljs-function"><span class="hljs-keyword">program</span></span> stest1<br><br><span class="hljs-function"><span class="hljs-keyword">subroutine</span></span> subr(x, y, n)<br>    <span class="hljs-keyword">implicit</span> <span class="hljs-keyword">none</span><br>    <span class="hljs-keyword">real</span> x, y<br>    <span class="hljs-keyword">integer</span> n<br>    x = n<br>    y = y*x<br><span class="hljs-keyword">end</span> <span class="hljs-function"><span class="hljs-keyword">subroutine</span></span> subr<br></code></pre></td></tr></table></figure><p>子程序的调用和主程序的执行顺序是：<strong>主程序 → 子程序 →主程序</strong>。</p><p>由于<strong>子程序被调用时实际上不会与其他正在被执行的子程序相互干扰</strong>，所以可以在一个主程序中重复调用同一子程序。如果在子程序中需要根据某个条件判断中断退出，可以如下所示利用<code>if</code> 语句和 <code>return</code> 关键字来返回主程序。</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs fortran"><span class="hljs-function"><span class="hljs-keyword">subroutine</span></span> subr(x, y, m, n)<br>    <span class="hljs-keyword">implicit</span> <span class="hljs-keyword">none</span><br>    <span class="hljs-keyword">real</span> x, y<br>    <span class="hljs-keyword">integer</span> m, n<br>    ......<br>    <span class="hljs-keyword">if</span> (m &lt; n) <span class="hljs-keyword">return</span><br>    ......<br><span class="hljs-keyword">end</span> <span class="hljs-function"><span class="hljs-keyword">subroutine</span></span> subr<br></code></pre></td></tr></table></figure><h2 id="局部变量">局部变量</h2><h3 id="子程序变量的局部性">子程序变量的局部性</h3><p>子程序中定义的<strong>局部变量和参数独立于主程序</strong>。也就是说，当我们在主程序和子程序中同时定义<strong>相同名称的变量</strong>时，其实它们之间也是不同的。只有当我们在调用子程序时使用主程序中同名的变量对参数进行赋值时，主程序和子程序的同名变量才会具有相同的值。</p><p>如下面的示例 1 所示，编译执行的结果并非是期待的 10.0 和 30.0。</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs fortran"><span class="hljs-comment">!!! 示例 1</span><br><span class="hljs-function"><span class="hljs-keyword">program</span></span> stest1<br>    <span class="hljs-keyword">implicit</span> <span class="hljs-keyword">none</span><br>    <span class="hljs-keyword">real</span> x, y<br>    x = <span class="hljs-number">10.0</span><br>    y = <span class="hljs-number">30.0</span><br>    <span class="hljs-keyword">call</span> subr1<br><span class="hljs-keyword">end</span> <span class="hljs-function"><span class="hljs-keyword">program</span></span> stest1<br><br><span class="hljs-function"><span class="hljs-keyword">subroutine</span></span> subr1<br>    <span class="hljs-keyword">implicit</span> <span class="hljs-keyword">none</span><br>    <span class="hljs-keyword">real</span> x, y<br>    <span class="hljs-built_in">print</span> *, x, y<br><span class="hljs-keyword">end</span> <span class="hljs-function"><span class="hljs-keyword">subroutine</span></span> subr1<br><br><span class="hljs-comment">!!! 执行结果</span><br>&gt;&gt;&gt;    <span class="hljs-number">2.80259693E-45</span>   <span class="hljs-number">0.00000000</span><br></code></pre></td></tr></table></figure><p>当我们修改为带初始化变量的子程序时，如示例 2所示，编译执行的结果和期待的一样。</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs fortran"><span class="hljs-comment">!!! 示例 2</span><br><span class="hljs-function"><span class="hljs-keyword">program</span></span> stest2<br>    <span class="hljs-keyword">implicit</span> <span class="hljs-keyword">none</span><br>    <span class="hljs-keyword">real</span> x, y<br>    x = <span class="hljs-number">10.0</span><br>    y = <span class="hljs-number">30.0</span><br>    <span class="hljs-keyword">call</span> subr2(x, y)<br><span class="hljs-keyword">end</span> <span class="hljs-function"><span class="hljs-keyword">program</span></span> stest2<br><br><span class="hljs-function"><span class="hljs-keyword">subroutine</span></span> subr2(x, y)<br>    <span class="hljs-keyword">implicit</span> <span class="hljs-keyword">none</span><br>    <span class="hljs-keyword">real</span> x, y<br>    <span class="hljs-built_in">print</span> *, x, y<br><span class="hljs-keyword">end</span> <span class="hljs-function"><span class="hljs-keyword">subroutine</span></span> subr2<br><br><span class="hljs-comment">!!! 执行结果</span><br>&gt;&gt;&gt;    <span class="hljs-number">10.0000000</span>       <span class="hljs-number">30.0000000</span><br></code></pre></td></tr></table></figure><p>这两个例子的对比再一次证明了子程序中定义的变量所具有的局部性，<strong>必须通过参数传递的方式才能与主程序同名变量保持一样的初始化值</strong>。同样地，这种局部性也会让主程序的变量值不会因为子程序的同名变量值发生改变而改变。</p><p>有人可能会有疑问，如果子程序中的参数使用的变量名与主程序的变量名不一致，调用能不能成功呢？当然是能够成功的。如下所示，将示例2 中子程序原来的参数 x 和 y 换成 a 和 b，依然可以输出正确结果。</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs fortran"><span class="hljs-function"><span class="hljs-keyword">subroutine</span></span> subr2(a, b)<br>    <span class="hljs-keyword">implicit</span> <span class="hljs-keyword">none</span><br>    <span class="hljs-keyword">real</span> a, b<br>    <span class="hljs-built_in">print</span> *, a, b<br><span class="hljs-keyword">end</span> <span class="hljs-function"><span class="hljs-keyword">subroutine</span></span> subr2<br><br><span class="hljs-comment">!!! 执行结果</span><br>&gt;&gt;&gt;    <span class="hljs-number">10.0000000</span>       <span class="hljs-number">30.0000000</span><br></code></pre></td></tr></table></figure><h3 id="类型声明的一致性">类型声明的一致性</h3><p>主程序中调用带初始化变量的子程序时，需要注意使用相同类型的变量来给子程序初始化参数，否则就会报错。如示例3 中所示，子程序中所定义的参数 x 和 y 为实数、参数 m 和 n为整数。主程序中调用时传递的变量值也是对应的实数和整数，具体如下表所示。</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs fortran"><span class="hljs-comment">!!! 示例 3</span><br><span class="hljs-function"><span class="hljs-keyword">program</span></span> stest3<br>    <span class="hljs-keyword">implicit</span> <span class="hljs-keyword">none</span><br>    <span class="hljs-keyword">real</span> z<br>    <span class="hljs-keyword">integer</span> n<br>    z = <span class="hljs-number">200.0</span><br>    n = <span class="hljs-number">21</span><br>    <span class="hljs-keyword">call</span> subr3(<span class="hljs-number">10.0</span>, z**<span class="hljs-number">2</span>, <span class="hljs-number">100</span>, n*<span class="hljs-number">5</span>+<span class="hljs-number">1</span>)<br><span class="hljs-keyword">end</span> <span class="hljs-function"><span class="hljs-keyword">program</span></span> stest3<br><br><span class="hljs-function"><span class="hljs-keyword">subroutine</span></span> subr3(x, y, m, n)<br>    <span class="hljs-keyword">implicit</span> <span class="hljs-keyword">none</span><br>    <span class="hljs-keyword">real</span> x, y<br>    <span class="hljs-keyword">integer</span> m, n<br>    <span class="hljs-built_in">print</span> *, x, y, m, n<br><span class="hljs-keyword">end</span> <span class="hljs-function"><span class="hljs-keyword">subroutine</span></span> subr3<br></code></pre></td></tr></table></figure><table><thead><tr class="header"><th>调用语句</th><th>子程序语句</th><th>数值类型</th></tr></thead><tbody><tr class="odd"><td>10.0</td><td>x</td><td>实数</td></tr><tr class="even"><td>z**2</td><td>y</td><td>实数</td></tr><tr class="odd"><td>100</td><td>m</td><td>整数</td></tr><tr class="even"><td>n*5+1</td><td>n</td><td>整数</td></tr></tbody></table><h3 id="子程序的返回值">子程序的返回值</h3><p>刚才提到的子程序中定义的变量是局部变量，不会干扰主程序中的其他变量，但是如果我们想要把子程序计算的结果返回给主程序呢？在其他的编程语言中，可能大部分是使用<code>return</code>加变量名的方式来将子程序中的变量传递回主程序。<strong>在 Fortran中，子程序会将参数变量全部返回给主程序，可以认为是地址引用</strong>。如果主程序调用子程序时<strong>用一个算式传递变量给子程序，那么可以认为是值引用</strong>。</p><p>如下面的示例 4 所示，主程序中调用子程序时最后的变量 p就是要保存返回值的变量。从执行结果也可以看出，变量 x 和 y并没有受到子程序的影响，只有变量 p 带着子程序的变量 z的值正确返回了。因为这里 x+y 作为子程序中的 x 存在，而 x+y这个变量实际上在主程序中不存在，所以是值引用。</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs fortran"><span class="hljs-comment">!!! 示例 4</span><br><span class="hljs-function"><span class="hljs-keyword">program</span></span> stest4<br>    <span class="hljs-keyword">implicit</span> <span class="hljs-keyword">none</span><br>    <span class="hljs-keyword">real</span> x, y, p<br>    x = <span class="hljs-number">10.0</span><br>    y = <span class="hljs-number">30.0</span><br>    <span class="hljs-keyword">call</span> subr4(x+y, <span class="hljs-number">20.0</span>, p)<br>    <span class="hljs-built_in">print</span> *, x, y, p<br><span class="hljs-keyword">end</span> <span class="hljs-function"><span class="hljs-keyword">program</span></span> stest4<br><br><span class="hljs-function"><span class="hljs-keyword">subroutine</span></span> subr4(x, y, z)<br>    <span class="hljs-keyword">implicit</span> <span class="hljs-keyword">none</span><br>    <span class="hljs-keyword">real</span> x, y, z<br>    z = x*y<br><span class="hljs-keyword">end</span> <span class="hljs-function"><span class="hljs-keyword">subroutine</span></span> subr4<br><br><span class="hljs-comment">!!! 执行结果</span><br>&gt;&gt;&gt;   <span class="hljs-number">10.0000000</span>       <span class="hljs-number">30.0000000</span>       <span class="hljs-number">800.000000</span><br></code></pre></td></tr></table></figure><h5 id="小提示-2">小提示</h5><p><strong>值引用</strong>和<strong>地址引用</strong>的定义：值引用是指引用值而不引用原来的变量或者存储器中对应的地址，地址引用是指引用原来的变量或者存储器中对应的地址。<strong>值引用</strong>和<strong>地址引用</strong>的区别：前者不会因子程序的操作而发生改变，后者可能会因子程序的操作而发生改变。如果我们仅仅是为了传递某个值给子程序作为输入，可以采用值引用，从而避免对于主程序的干扰。如果我们希望子程序的操作改变变量的值，可以采用地址引用。</p><h2 id="数组变量">数组变量</h2><h3 id="数组作为子程序参数">数组作为子程序参数</h3><p>如果主程序想要用数组变量或数组变量的某个位置的值为调用的子程序赋值，Fortran也是完全支持的。如下所示，第一行是用数组变量初始化子程序参数，第二行是用数组变量a 中编号为 1 的元素初始化子程序参数。</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs fortran"><span class="hljs-keyword">call</span> sub(a)<br><span class="hljs-keyword">call</span> sub(a(<span class="hljs-number">1</span>))<br></code></pre></td></tr></table></figure><p>上面第一行调用方式对应的主程序和子程序可以类似于下面的示例5。主程序和子程序中分别将 a 和 x 都定义为长度为 10的一维数组，并在子程序中使用循环的方式依次为数组 x的每个元素赋值。最后，赋好值的数组 x也会返回给主程序。从执行结果看到，输出结果为期待的 a(3) 值。</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs fortran"><span class="hljs-comment">!!! 示例 5</span><br><span class="hljs-function"><span class="hljs-keyword">program</span></span> stest5<br>    <span class="hljs-keyword">implicit</span> <span class="hljs-keyword">none</span><br>    <span class="hljs-keyword">real</span> a(<span class="hljs-number">10</span>)<br>    <span class="hljs-keyword">call</span> sub(a)<br>    <span class="hljs-built_in">print</span> *, a(<span class="hljs-number">3</span>)<br><span class="hljs-keyword">end</span> <span class="hljs-function"><span class="hljs-keyword">program</span></span> stest5<br><br><span class="hljs-function"><span class="hljs-keyword">subroutine</span></span> sub(x)<br>    <span class="hljs-keyword">implicit</span> <span class="hljs-keyword">none</span><br>    <span class="hljs-keyword">real</span> x(<span class="hljs-number">10</span>)<br>    <span class="hljs-keyword">integer</span> i<br>    <span class="hljs-keyword">do</span> i = <span class="hljs-number">1</span>, <span class="hljs-number">10</span><br>        x(i) = i<br>    <span class="hljs-keyword">enddo</span><br><span class="hljs-keyword">end</span> <span class="hljs-function"><span class="hljs-keyword">subroutine</span></span> sub<br><br><span class="hljs-comment">!!! 执行结果</span><br>&gt;&gt;&gt;   <span class="hljs-number">3.00000000</span><br></code></pre></td></tr></table></figure><p>如果我们在调用时写成了<code>call sub(a(1))</code>，那会怎么样呢？实际上还是会得到一样的结果。</p><h3 id="数组变量的顺序对应">数组变量的顺序对应</h3><p>如果将 <code>a(1)</code> 修改为 <code>a(3)</code> 并保持数组 a的长度为 10，即数组 a 和数组 x不从第一个元素开始对应，那么源代码将无法被编译，如示例 5的变种一所示。</p><p>要想在这种情况下还能正常编译，我们就必须扩充数组 a 的长度至少为12。这样一来，子程序中要赋值的数都能正确存入数组 x并返回给主程序的数组变量 a，如示例 5 的变种二所示。</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs fortran"><span class="hljs-comment">!!! 示例 5 的变种一</span><br><span class="hljs-function"><span class="hljs-keyword">program</span></span> stest5<br>    <span class="hljs-keyword">implicit</span> <span class="hljs-keyword">none</span><br>    <span class="hljs-keyword">real</span> a(<span class="hljs-number">10</span>)<br>    <span class="hljs-keyword">call</span> sub(a(<span class="hljs-number">3</span>))<br>    <span class="hljs-built_in">print</span> *, a(<span class="hljs-number">3</span>)<br><span class="hljs-keyword">end</span> <span class="hljs-function"><span class="hljs-keyword">program</span></span> stest5<br><br><span class="hljs-function"><span class="hljs-keyword">subroutine</span></span> sub(x)<br>    <span class="hljs-keyword">implicit</span> <span class="hljs-keyword">none</span><br>    <span class="hljs-keyword">real</span> x(<span class="hljs-number">10</span>)<br>    <span class="hljs-keyword">integer</span> i<br>    <span class="hljs-keyword">do</span> i = <span class="hljs-number">1</span>, <span class="hljs-number">10</span><br>        x(i) = i<br>    <span class="hljs-keyword">enddo</span><br><span class="hljs-keyword">end</span> <span class="hljs-function"><span class="hljs-keyword">subroutine</span></span> sub <br><br><span class="hljs-comment">!!! 执行结果</span><br>&gt;&gt;&gt; Error: Actual argument <span class="hljs-keyword">contains</span> too few elements for dummy argument <span class="hljs-string">&#x27;x&#x27;</span> (<span class="hljs-number">8</span>/<span class="hljs-number">10</span>) at (<span class="hljs-number">1</span>)<br><br><span class="hljs-comment">!!! 示例 5 的变种二</span><br><span class="hljs-function"><span class="hljs-keyword">program</span></span> stest5<br>    <span class="hljs-keyword">implicit</span> <span class="hljs-keyword">none</span><br>    <span class="hljs-keyword">real</span> a(<span class="hljs-number">12</span>)<br>    <span class="hljs-keyword">call</span> sub(a(<span class="hljs-number">3</span>))<br>    <span class="hljs-built_in">print</span> *, a(<span class="hljs-number">3</span>)<br><span class="hljs-keyword">end</span> <span class="hljs-function"><span class="hljs-keyword">program</span></span> stest5<br><br><span class="hljs-function"><span class="hljs-keyword">subroutine</span></span> sub(x)<br>    <span class="hljs-keyword">implicit</span> <span class="hljs-keyword">none</span><br>    <span class="hljs-keyword">real</span> x(<span class="hljs-number">10</span>)<br>    <span class="hljs-keyword">integer</span> i<br>    <span class="hljs-keyword">do</span> i = <span class="hljs-number">1</span>, <span class="hljs-number">10</span><br>        x(i) = i<br>    <span class="hljs-keyword">enddo</span><br><span class="hljs-keyword">end</span> <span class="hljs-function"><span class="hljs-keyword">subroutine</span></span> sub <br><br><span class="hljs-comment">!!! 执行结果</span><br>&gt;&gt;&gt;   <span class="hljs-number">1.00000000</span><br></code></pre></td></tr></table></figure><p>其实，<strong>在子程序中也可以不定义数组的长度，将长度设置为<code>*</code></strong>。</p><p>如下示例 6 所示，子程序的功能是将数组 a 中的前 n 个元素复制给数组b。</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs fortran"><span class="hljs-comment">!!! 示例 6</span><br><span class="hljs-function"><span class="hljs-keyword">subroutine</span></span> copy(a, b, n)<br>    <span class="hljs-keyword">implicit</span> <span class="hljs-keyword">none</span><br>    <span class="hljs-keyword">real</span> a(*), b(*)<br>    <span class="hljs-keyword">integer</span> n, i<br>    <span class="hljs-keyword">do</span> i = i, n<br>        b(i) = a(i)<br>    <span class="hljs-keyword">enddo</span><br><span class="hljs-keyword">end</span> <span class="hljs-function"><span class="hljs-keyword">subroutine</span></span> copy<br></code></pre></td></tr></table></figure><h3 id="二维数组变量">二维数组变量</h3><p>当然，除了一维数组，我们也可能会想在<strong>主程序中传递二维数组给子程序，但是<code>a(*, *)</code>的写法在 Fortran中是不支持的</strong>。因此，我们需要把二维数组的维度也传递给子程序。</p><p>如下示例 7 所示，数组 a 和 b 为二维数组，m 和 n是它们的维度。子程序中使用数组变量名和给定的维度定义出二维数组。示例 7的主程序定义了四个二维数组及它们的维度大小，调用子程序时不仅传递了数组本身，也传递了维度大小。而子程序采用了两个for 循环叠加的方式来交替给二维数组中的每一行每一列的元素赋值。</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs fortran"><span class="hljs-comment">!!! 示例 7</span><br><span class="hljs-function"><span class="hljs-keyword">program</span></span> stest1<br>    <span class="hljs-keyword">implicit</span> <span class="hljs-keyword">none</span><br>    <span class="hljs-keyword">real</span> a(<span class="hljs-number">10</span>, <span class="hljs-number">20</span>), b(<span class="hljs-number">10</span>, <span class="hljs-number">20</span>), c(<span class="hljs-number">100</span>, <span class="hljs-number">200</span>), d(<span class="hljs-number">100</span>, <span class="hljs-number">200</span>)<br>    ......<br>    <span class="hljs-keyword">call</span> copy2d(a, b, <span class="hljs-number">10</span>, <span class="hljs-number">20</span>)<br>    <span class="hljs-keyword">call</span> copy2d(c, d, <span class="hljs-number">100</span>, <span class="hljs-number">200</span>)<br><span class="hljs-keyword">end</span> <span class="hljs-function"><span class="hljs-keyword">program</span></span> stest1<br><br><span class="hljs-function"><span class="hljs-keyword">subroutine</span></span> copy2d(a, b, m, n)<br>    <span class="hljs-keyword">implicit</span> <span class="hljs-keyword">none</span><br>    <span class="hljs-keyword">real</span> a(m, n), b(m, n)<br>    <span class="hljs-keyword">integer</span> m, n, i, j<br>    <span class="hljs-keyword">do</span> j = i, n<br>        <span class="hljs-keyword">do</span> i = i, m<br>            b(i, j) = a(i, j)<br>        <span class="hljs-keyword">enddo</span><br>    <span class="hljs-keyword">enddo</span><br><span class="hljs-keyword">end</span> <span class="hljs-function"><span class="hljs-keyword">subroutine</span></span> copy2d<br></code></pre></td></tr></table></figure><p>数组 a(m, n) 的定义表示数组的行号是从 1 到 m、列号是从 1 到n。如果想要行号和列号从 0 开始，则应该将数组定义为 a(0:m-1,0:n-1)。一维数组时可以定义为 a(0:*)。</p><h2 id="函数副程序">函数副程序</h2><p><strong>函数副程序，这个称呼不一定十分准确，实际上就是其他编程语言中常用的函数</strong>。在某种程度上，函数只是子程序的替代，但是对于Fortran来说，函数必须将函数名作为变量进行声明，并将计算的结果赋给这个函数名同名变量。一个完整的例子如下示例8 所示。</p><h5 id="小提示-3">小提示</h5><p><strong>函数副程序只能返回一个结果，而子程序可以返回多个结果</strong>。所以如果只是用来计算某个公式或者求解某个结果，可以优先采用函数副程序。如果需要同时返回多个变量，则优先采用子程序。</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs fortran"><span class="hljs-comment">!!! 示例 8</span><br><span class="hljs-function"><span class="hljs-keyword">function</span></span> square(x)<br>    <span class="hljs-keyword">implicit</span> <span class="hljs-keyword">none</span><br>    <span class="hljs-keyword">real</span> square, x         <span class="hljs-comment">! 声明函数名同名变量</span><br>    square = x*x           <span class="hljs-comment">! 将计算结果赋给函数名同名变量</span><br><span class="hljs-keyword">end</span> <span class="hljs-function"><span class="hljs-keyword">function</span></span> square<br><br><span class="hljs-function"><span class="hljs-keyword">program</span></span> ftest1<br>    <span class="hljs-keyword">implicit</span> <span class="hljs-keyword">none</span><br>    <span class="hljs-keyword">real</span> x, y, square      <span class="hljs-comment">! 声明使用的函数名同名变量</span><br>    x = <span class="hljs-number">4.0</span><br>    y = <span class="hljs-number">3.0</span>*square(x+<span class="hljs-number">1.0</span>) + <span class="hljs-number">50.5</span><br>    <span class="hljs-built_in">print</span> *, x, y<br><span class="hljs-keyword">end</span> <span class="hljs-function"><span class="hljs-keyword">program</span></span> ftest1<br><br><span class="hljs-comment">!!! 执行结果</span><br>&gt;&gt;&gt;   <span class="hljs-number">4.00000000</span>       <span class="hljs-number">125.500000</span><br></code></pre></td></tr></table></figure><h5 id="小提示-4">小提示</h5><p>Fortran中的函数使用需要严格遵守函数名同名变量在主程序和函数中的相同类型声明，否则就无法通过编译。</p><h2 id="全局变量">全局变量</h2><p>虽然我们在不同的子程序中使用同名的局部变量不会相互影响，但是有的时候也希望一些变量能在不同的子程序中共享使用，这类变量我们可以称之为<strong>全局变量</strong>。</p><p>Fortran 语言中全局变量必须使用 <code>module</code>的方式单独定义。当在主程序或子程序中需要使用这些已定义的全局变量时，首先要使用<code>use &lt;module 名&gt;</code> 来声明引用，并且该声明应在<code>implicit none</code> 之前。如下所示，定义了两个整数类型的变量 nmin和 nmax，以及实数类型的变量 tinitial 和 二维数组 amatrix。</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs fortran"><span class="hljs-keyword">module</span> data1<br>    <span class="hljs-keyword">integer</span> nmin, nmax<br>    <span class="hljs-keyword">real</span> tinitial, amatrix(<span class="hljs-number">20</span>, <span class="hljs-number">30</span>)<br><span class="hljs-keyword">end</span> <span class="hljs-keyword">module</span> data1<br></code></pre></td></tr></table></figure><p>示例 9是一个完整的全局变量定义和使用的例子。可以看到，子程序并没有声明任何参数，而是利用定义的全局变量xais 和 yais来从主程序中传递值到子程序中。这里的程序执行顺序是：<strong>主程序 →调用子程序 → 子程序中的打印 → 子程序修改 yais 变量 → 主程序中的打印 →程序结束</strong>。所以最终的执行结果的第一行是子程序中打印还未修改的两个全局变量，而第二行是主程序中打印已被子程序修改的两个全局变量，符合预期效果。</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs fortran"><span class="hljs-comment">!!! 示例 9</span><br><span class="hljs-keyword">module</span> global<br>    <span class="hljs-keyword">real</span> xais, yais<br><span class="hljs-keyword">end</span> <span class="hljs-keyword">module</span> global<br><br><span class="hljs-function"><span class="hljs-keyword">program</span></span> stest4<br>    <span class="hljs-keyword">use</span> global<br>    <span class="hljs-keyword">implicit</span> <span class="hljs-keyword">none</span><br>    xais = <span class="hljs-number">5.0</span><br>    yais = <span class="hljs-number">100.0</span><br>    <span class="hljs-keyword">call</span> subr4<br>    <span class="hljs-built_in">print</span> *, xais, yais<br><span class="hljs-keyword">end</span> <span class="hljs-function"><span class="hljs-keyword">program</span></span> stest4<br><br><span class="hljs-function"><span class="hljs-keyword">subroutine</span></span> subr4<br>    <span class="hljs-keyword">use</span> global<br>    <span class="hljs-keyword">implicit</span> <span class="hljs-keyword">none</span><br>    <span class="hljs-built_in">print</span> *, xais, yais<br>    yais = <span class="hljs-number">25.0</span><br><span class="hljs-keyword">end</span> <span class="hljs-function"><span class="hljs-keyword">subroutine</span></span> subr4<br><br><span class="hljs-comment">!!! 执行结果</span><br>&gt;&gt;&gt;   <span class="hljs-number">5.00000000</span>       <span class="hljs-number">100.000000</span>    <br>&gt;&gt;&gt;   <span class="hljs-number">5.00000000</span>       <span class="hljs-number">25.0000000</span><br></code></pre></td></tr></table></figure><h5 id="小提示-5">小提示</h5><p>有的时候子程序中可能并不需要 module中定义的所有全局变量，只想引入几个有关的全局变量。在 Fortran语言中可以用 <code>only</code>的语法来限定引入的全局变量，如下所示。</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs fortran"><span class="hljs-keyword">use</span> 模块名, <span class="hljs-keyword">only</span> : 变量<span class="hljs-number">1</span>, 变量<span class="hljs-number">2</span>, ...<br><span class="hljs-keyword">use</span> global, <span class="hljs-keyword">only</span> : yaxsis<br></code></pre></td></tr></table></figure><h2 id="混合嵌套调用">混合嵌套调用</h2><p>一般地，子程序或者函数的参数都是一些来自主程序的局部变量，那么子程序中调用函数是否也需要在参数中进行声明呢？是的，子程序如果想要使用某个函数，需要将函数名作为参数引用。</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs fortran"><span class="hljs-comment">!!! 示例 10</span><br><span class="hljs-function"><span class="hljs-keyword">subroutine</span></span> subrout(subr, xmin, xmax, n)<br>    <span class="hljs-keyword">implicit</span> <span class="hljs-keyword">none</span><br>    <span class="hljs-keyword">real</span> xmin, xmax, dx, y<br>    <span class="hljs-keyword">integer</span> n, i<br>    dx = (xmax - xmin)/n<br>    <span class="hljs-keyword">do</span> i = <span class="hljs-number">0</span>, n<br>        <span class="hljs-keyword">call</span> subr(dx*i+xmin, y)<br>        <span class="hljs-built_in">print</span> *, i, y<br>    <span class="hljs-keyword">enddo</span><br><span class="hljs-keyword">end</span> <span class="hljs-function"><span class="hljs-keyword">subroutine</span></span> subrout<br><br><span class="hljs-function"><span class="hljs-keyword">subroutine</span></span> funcout(fun, xmin, xmax, n)<br>    <span class="hljs-keyword">implicit</span> <span class="hljs-keyword">none</span><br>    <span class="hljs-keyword">real</span> fun, xmin, xmax, x, dx, y<br>    <span class="hljs-keyword">integer</span> n, i<br>    dx = (xmax-xmin)/n<br>    <span class="hljs-keyword">do</span> i = <span class="hljs-number">0</span>, n<br>        x = dx*i + xmin<br>        y = func(x)**<span class="hljs-number">3</span><br>        <span class="hljs-built_in">print</span> *, x, y<br>    <span class="hljs-keyword">enddo</span><br><span class="hljs-keyword">end</span> <span class="hljs-function"><span class="hljs-keyword">subroutine</span></span> funcout<br><br><span class="hljs-function"><span class="hljs-keyword">subroutine</span></span> sub(x, y)<br>    <span class="hljs-keyword">implicit</span> <span class="hljs-keyword">none</span><br>    <span class="hljs-keyword">real</span> y, x<br>    y = <span class="hljs-number">2</span>*<span class="hljs-built_in">sin</span>(x) + <span class="hljs-built_in">cos</span>(x**<span class="hljs-number">2</span>)<br><span class="hljs-keyword">end</span> <span class="hljs-function"><span class="hljs-keyword">subroutine</span></span> sub<br><br><span class="hljs-function"><span class="hljs-keyword">function</span></span> fun(x)<br>    <span class="hljs-keyword">implicit</span> <span class="hljs-keyword">none</span><br>    <span class="hljs-keyword">real</span> fun, x<br>    fun = <span class="hljs-built_in">sin</span>(x)**<span class="hljs-number">3</span><br><span class="hljs-keyword">end</span> <span class="hljs-function"><span class="hljs-keyword">function</span></span> fun<br><br><span class="hljs-function"><span class="hljs-keyword">program</span></span> test_func<br>    <span class="hljs-keyword">implicit</span> <span class="hljs-keyword">none</span><br>    <span class="hljs-keyword">real</span>, <span class="hljs-keyword">external</span> :: fun<br>    <span class="hljs-keyword">external</span> sub<br>    <span class="hljs-keyword">call</span> subrout(sub, <span class="hljs-number">0.0</span>, <span class="hljs-number">3.0</span>, <span class="hljs-number">10</span>)<br>    <span class="hljs-keyword">call</span> funcout(fun, <span class="hljs-number">0.0</span>, <span class="hljs-number">3.0</span>, <span class="hljs-number">10</span>)<br><span class="hljs-keyword">end</span> <span class="hljs-function"><span class="hljs-keyword">program</span></span> test_func<br><br><span class="hljs-comment">!!! 执行结果</span><br>&gt;&gt;&gt;        <span class="hljs-number">0</span>   <span class="hljs-number">1.00000000</span>    <br>           <span class="hljs-number">1</span>   <span class="hljs-number">1.58699322</span>    <br>           <span class="hljs-number">2</span>   <span class="hljs-number">2.06518173</span>    <br>           <span class="hljs-number">3</span>   <span class="hljs-number">2.25615215</span>    <br>           <span class="hljs-number">4</span>   <span class="hljs-number">1.99450183</span>    <br>           <span class="hljs-number">5</span>   <span class="hljs-number">1.36681640</span>    <br>           <span class="hljs-number">6</span>  <span class="hljs-number">0.952533364</span>    <br>           <span class="hljs-number">7</span>   <span class="hljs-number">1.42861772</span>    <br>           <span class="hljs-number">8</span>   <span class="hljs-number">2.21715832</span>    <br>           <span class="hljs-number">9</span>   <span class="hljs-number">1.38931477</span>    <br>          <span class="hljs-number">10</span> -<span class="hljs-number">0.628890276</span>    <br>   <span class="hljs-number">0.00000000</span>       <span class="hljs-number">0.00000000</span>    <br>  <span class="hljs-number">0.300000012</span>       <span class="hljs-number">1.71903503E-05</span><br>  <span class="hljs-number">0.600000024</span>       <span class="hljs-number">5.83394058E-03</span><br>  <span class="hljs-number">0.900000036</span>      <span class="hljs-number">0.111042053</span>    <br>   <span class="hljs-number">1.20000005</span>      <span class="hljs-number">0.530770957</span>    <br>   <span class="hljs-number">1.50000000</span>      <span class="hljs-number">0.977679431</span>    <br>   <span class="hljs-number">1.80000007</span>      <span class="hljs-number">0.787805617</span>    <br>   <span class="hljs-number">2.10000014</span>      <span class="hljs-number">0.266100109</span>    <br>   <span class="hljs-number">2.40000010</span>       <span class="hljs-number">2.92694476E-02</span><br>   <span class="hljs-number">2.70000005</span>       <span class="hljs-number">4.75692534E-04</span><br>   <span class="hljs-number">3.00000000</span>       <span class="hljs-number">2.21971472E-08</span><br></code></pre></td></tr></table></figure><p>上面的示例 10是子程序和函数副程序的混合嵌套使用的一个范例，上述代码的主要结构如下所示：在主程序<code>test_func</code> 中调用子程序 <code>subrout</code> 和<code>funcout</code>，再由子程序 <code>subrout</code> 调用子程序<code>sub</code> 以及子程序 <code>funcout</code> 调用函数副程序<code>fun</code>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">test_func（主程序）<br>├── subrout（子程序）<br>│   └── sub（子程序）<br>└── funcout（子程序）<br>    └── fun（函数副程序）<br></code></pre></td></tr></table></figure><h5 id="小提示-6">小提示</h5><p>这里比较重要的是，在主程序中需要对递归调用的子程序和函数副程序进行声明。主程序中的递归子程序调用声明只需要<code>external</code>加上子程序名即可，而主程序中的递归函数副程序调用声明需要同时定义函数变量和函数名，因此写为<code>real, external ::</code> 加上函数副程序名。</p><p>当然在直接调用函数副程序 <code>fun</code> 的子程序<code>funcout</code> 中也需要定义函数同名变量，写为<code>real fun</code>。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Fortran</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Fortran-条件与循环语句</title>
    <link href="/2022/05/23/Fortran-%E6%9D%A1%E4%BB%B6%E4%B8%8E%E5%BE%AA%E7%8E%AF%E8%AF%AD%E5%8F%A5/"/>
    <url>/2022/05/23/Fortran-%E6%9D%A1%E4%BB%B6%E4%B8%8E%E5%BE%AA%E7%8E%AF%E8%AF%AD%E5%8F%A5/</url>
    
    <content type="html"><![CDATA[<h2 id="循环语句">循环语句</h2><p>Fortran 语言中的循环语句与其他高级编程语言中的 For 循环、while循环有点类似，但也略有不同。</p><h3 id="do-循环">do 循环</h3><p>Fortran 的最简单的循环语句称为 do 语句，其形式如下所示：</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs fortran"><span class="hljs-comment">!!! 不设置步长，默认为 1</span><br><span class="hljs-keyword">do</span> 整数型变量 = 起始值, 结束值<br>    ......<br>    ......<br><span class="hljs-keyword">enddo</span> <br></code></pre></td></tr></table></figure><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs fortran"><span class="hljs-comment">!!! 示例 1</span><br><span class="hljs-keyword">integer</span> a(<span class="hljs-number">10</span>)<br><span class="hljs-keyword">do</span> n = <span class="hljs-number">1</span>, <span class="hljs-number">10</span>      <span class="hljs-comment">! 计算 1，2，3，4，5，6，7，8，9，10</span><br>    a(n) = n<br><span class="hljs-keyword">enddo</span><br><br><span class="hljs-comment">!!! 设置步长，可以设置正整数和负整数，不能为 0</span><br><span class="hljs-keyword">do</span> 整数型变量 = 初始值, 结束值, 步长<br>    ......<br>    ......<br><span class="hljs-keyword">enddo</span><br><br><span class="hljs-comment">!!! 示例 2</span><br><span class="hljs-keyword">integer</span> a(<span class="hljs-number">5</span>)<br><span class="hljs-keyword">do</span> n = <span class="hljs-number">1</span>, <span class="hljs-number">10</span>, <span class="hljs-number">2</span>   <span class="hljs-comment">! 计算 1，3，5，7，9</span><br>    a(<span class="hljs-built_in">nint</span>(n/<span class="hljs-number">2</span>)) = n<br><span class="hljs-keyword">enddo</span><br><br><span class="hljs-comment">!!! 示例 3</span><br><span class="hljs-keyword">integer</span> a(<span class="hljs-number">5</span>)<br><span class="hljs-keyword">do</span> n = <span class="hljs-number">10</span>, <span class="hljs-number">1</span>, -<span class="hljs-number">2</span>   <span class="hljs-comment">! 计算 10，8，6，4，2</span><br>    a(n/<span class="hljs-number">2</span>) = n<br><span class="hljs-keyword">enddo</span><br></code></pre></td></tr></table></figure><h5 id="小提示">小提示</h5><p>在使用 do循环语句的时候，我们需要注意在<strong>结束循环语句后循环条件变量 n仍然存在</strong>。如果后续计算中还<strong>使用到了相同变量，务必要进行重新初始化赋值</strong>，否则可能造成数据上的污染。我们可以拿示例3 举个例子，当循环结束后，n 的值其实为 0 (不是 2)。虽然此时的 n值并不满足循环继续的条件，但是已经完成了对步长的迭代计算，所以如果后续还是使用相同的变量n，我们期待的 n 初始值与循环结束后的 n值就可能不一样。<strong>建议在将某个变量设置为循环条件变量之后，循环外尽量不要使用同一个变量</strong>，从而避免这一可能存在的干扰。</p><p>do 循环语句实际上也<strong>可以存在嵌套，即一个 do循环语句包含了其他的 do 循环语句</strong>，如下示例 4所示。其中需要注意的是，在多重 do循环语句中，循环语句的<strong>条件变量不要使用相同的</strong>，否则很可能出现了我们意料之外的问题。建议同一个do 循环嵌套语句中使用不同的条件变量。如果不在同一个 do循环嵌套语句中，使用相同的条件变量产生问题的可能性比较小。</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs fortran"><span class="hljs-comment">!!! 示例 4</span><br><span class="hljs-keyword">integer</span> a(<span class="hljs-number">10</span>)<br><span class="hljs-keyword">integer</span> b(<span class="hljs-number">10</span>, <span class="hljs-number">5</span>)<br><span class="hljs-keyword">do</span> n = <span class="hljs-number">1</span>, <span class="hljs-number">10</span><br>    a(n) = n<br>    <span class="hljs-keyword">do</span> m = <span class="hljs-number">1</span>, <span class="hljs-number">10</span>, <span class="hljs-number">2</span><br>        b(n, <span class="hljs-built_in">nint</span>(m/<span class="hljs-number">2</span>)) = a(n) + m<br>    <span class="hljs-keyword">enddo</span><br><span class="hljs-keyword">enddo</span><br></code></pre></td></tr></table></figure><h5 id="小提示-1">小提示</h5><p>其实在 do循环中所指定的条件变量的初始值、结束值及步长也可以用已有值的变量来代替，如下所示。</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs fortran"><span class="hljs-keyword">integer</span> m, <span class="hljs-built_in">sum</span><br>m = <span class="hljs-number">10</span><br><span class="hljs-built_in">sum</span> = <span class="hljs-number">0</span><br><span class="hljs-keyword">do</span> n = <span class="hljs-number">1</span>, m<br>    <span class="hljs-built_in">sum</span> = <span class="hljs-built_in">sum</span> + n<br><span class="hljs-keyword">enddo</span><br></code></pre></td></tr></table></figure><h3 id="while-循环">while 循环</h3><p>通过上面的内容，不难发现上述的 do 循环确实看起来有点像 C、C++ 中的For 循环，那么 Fortran 语言中是否也存在 while循环呢？答案是<strong>当然了</strong>，其形式如下所示。</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs fortran"><span class="hljs-keyword">do</span> <span class="hljs-keyword">while</span> (条件)<br>   ......<br>    ......<br><span class="hljs-keyword">enddo</span><br></code></pre></td></tr></table></figure><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs fortran"><span class="hljs-comment">!!! 示例 5</span><br><span class="hljs-comment">!!! 计算并输出 10，9，8，7，6，5，4，3，2，1 的平方</span><br><span class="hljs-keyword">integer</span> n<br>n = <span class="hljs-number">10</span><br><span class="hljs-keyword">do</span> <span class="hljs-keyword">while</span> (n &gt; <span class="hljs-number">0</span>)   <br>    <span class="hljs-built_in">print</span> *, n**<span class="hljs-number">2</span><br>    n = n - <span class="hljs-number">1</span><br><span class="hljs-keyword">enddo</span><br></code></pre></td></tr></table></figure><p>我们可以从示例 5 中发现，while 循环其实就是变化后的 do 循环。do循环中判断条件紧跟着 do字符串，当符合条件时进入循环体内部继续执行，否则跳出循环。while 循环中将do 循环的初始值放置在了循环语句的前面进行声明，while循环的条件中只有对于结束值的声明，而原来 do循环的步长自增或自减操作则放置在了循环体中。这里有一点不同的是，如果自增或自减语句被放置在循环体的第一行，那么最后的执行结果就与do 循环的不一致了。这是因为 <strong>do循环实际上是在循环体执行完成后执行的步长自增或自减操作，而 while循环中则可以自行设置自增或自减操作在循环体中的位置</strong>。</p><h2 id="条件语句">条件语句</h2><p>Fortran语言中的条件语句可以分为<strong>有条件</strong>和<strong>无条件</strong>两种。我们所熟知的if 语句就是有条件的，而无条件的则是类似于汇编语言的 goto 语句、exit语句、cycle 语句，甚至还有无条件 do 循环语句。</p><h3 id="if-语句">if 语句</h3><p>if语句最简单的方式就是，将条件判断语句与执行语句放在同一行，如下所示。这也是因为执行语句比较短，放置在同一行反而代码更加美观。当然一般来说执行语句可能不是一行，甚至是多分支、多重的，因此也有单分支if 语句、双分支 if 语句、多重 if 语句，如下所示。</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs fortran"><span class="hljs-comment">!!! 最简单的 if 语句</span><br><span class="hljs-keyword">if</span> (条件) 执行语句<br><br></code></pre></td></tr></table></figure><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs fortran"><span class="hljs-comment">!!! 示例 6</span><br><span class="hljs-keyword">integer</span> n<br><span class="hljs-keyword">integer</span> i<br>n = <span class="hljs-number">10</span><br>i = -<span class="hljs-number">4</span><br><span class="hljs-keyword">if</span> (i &lt; <span class="hljs-number">0</span>) n = <span class="hljs-number">5</span><br><span class="hljs-built_in">print</span> *, n<br><br><br><span class="hljs-comment">!!! 单分支 if 语句</span><br><span class="hljs-keyword">if</span> (条件) <span class="hljs-keyword">then</span><br>    ......<br>    ......<br><span class="hljs-keyword">endif</span><br><br><span class="hljs-comment">!!! 示例 7</span><br><span class="hljs-keyword">if</span> (i &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">then</span><br>    n = <span class="hljs-number">5</span><br><span class="hljs-keyword">endif</span><br><span class="hljs-built_in">print</span> *, n<br><br><br><span class="hljs-comment">!!! 双分支 if 语句 (一般)</span><br><span class="hljs-keyword">if</span> (条件) <span class="hljs-keyword">then</span><br>    ......<br><span class="hljs-keyword">else</span><br>    ......<br><span class="hljs-keyword">endif</span><br><br><span class="hljs-comment">!!! 示例 8</span><br><span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span>) <span class="hljs-keyword">then</span><br>    n = <span class="hljs-number">8</span><br><span class="hljs-keyword">else</span><br>    n = <span class="hljs-number">5</span><br><span class="hljs-keyword">endif</span><br><span class="hljs-built_in">print</span> *, n<br><br><br><span class="hljs-comment">!!! 多重 if 语句</span><br><span class="hljs-keyword">if</span> (条件 <span class="hljs-number">1</span>) <span class="hljs-keyword">then</span><br>    .....<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (条件 <span class="hljs-number">2</span>) <span class="hljs-keyword">then</span><br>        ......<br>    <span class="hljs-keyword">else</span><br>        .....<br>    <span class="hljs-keyword">endif</span><br><span class="hljs-keyword">endif</span><br><br><span class="hljs-comment">!!! 示例 9</span><br><span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span>) <span class="hljs-keyword">then</span><br>    n = <span class="hljs-number">8</span><br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (i &gt; -<span class="hljs-number">2</span>) <span class="hljs-keyword">then</span><br>        n = <span class="hljs-number">6</span><br>    <span class="hljs-keyword">else</span><br>        n = <span class="hljs-number">5</span><br>    <span class="hljs-keyword">endif</span><br><span class="hljs-keyword">endif</span><br><span class="hljs-built_in">print</span> *, n<br></code></pre></td></tr></table></figure><p>在使用条件语句对条件变量进行比较判断时，除了我们常用的<code>&gt;</code>、<code>&lt;</code>之外，也有其他比较符号可以使用，如下表所示。</p><table><thead><tr class="header"><th>比较条件符号</th><th>含义</th><th>示例</th></tr></thead><tbody><tr class="odd"><td>==</td><td>左边等于右边</td><td>n == 10</td></tr><tr class="even"><td>/=</td><td>左边不等于右边</td><td>n /= 10</td></tr><tr class="odd"><td>&gt;</td><td>左边大于右边</td><td>n &gt; 10</td></tr><tr class="even"><td>&gt;=</td><td>左边大于或等于右边</td><td>n &gt;=10</td></tr><tr class="odd"><td>&lt;</td><td>左边小于右边</td><td>n &lt; 10</td></tr><tr class="even"><td>&lt;=</td><td>左边小于或等于右边</td><td>n &lt;= 10</td></tr></tbody></table><h5 id="小提示-2">小提示</h5><p>这里需要注意一点，如果我们想要<strong>比较左右两边是否相等，不是使用<code>=</code>，而是使用<code>==</code></strong>。其实这一点也比较容易理解，<code>=</code>的含义是将等号右边的值或者计算结果赋值给左边的变量，为了加以区分，比较左右两边时则使用<code>==</code>。另外，根据使用其他高级编程语言的经验来看，<code>==</code>是恒等于的意思，即左右两边不仅值相等、类型也相等，这不正是最稳妥的比较是否相等的方式吗？</p><p>当我们使用条件语句的时候还有一类使用场景，就是<strong>判断一个变量值是否在一个区间，即存在一个下限值和一个上限值</strong>。如果使用我们上述的if 语句恐怕只有多重 if语句才能满足我们的需求了，但是这代码写起来可能有点显得多余，毕竟我们在逻辑上是想要同时判断变量值与上下限值的大小。所以Fortran 语言的 if 语句中也<strong>存在逻辑运算符<code>.and.</code>、<code>.or.</code> 和<code>.not.</code></strong>，具体如下表所示。</p><table><thead><tr class="header"><th>逻辑运算符</th><th>含义</th></tr></thead><tbody><tr class="odd"><td>条件 1 .and. 条件 2</td><td>同时满足条件 1 和条件 2</td></tr><tr class="even"><td>条件 1 .or. 条件 2</td><td>满足条件 1 和条件 2 之一即可</td></tr><tr class="odd"><td>.not. 条件</td><td>不满足条件，即满足条件的相反条件</td></tr></tbody></table><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs fortran"><span class="hljs-comment">!!! 示例 10</span><br><span class="hljs-keyword">if</span> (i &lt; <span class="hljs-number">0</span> .and. i &gt; -<span class="hljs-number">2</span>) <span class="hljs-keyword">then</span><br>    n = <span class="hljs-number">5</span><br><span class="hljs-keyword">else</span><br>    n = <span class="hljs-number">10</span><br><span class="hljs-keyword">endif</span><br></code></pre></td></tr></table></figure><h5 id="小提示-3">小提示</h5><p>我们在其他高级编程语言中可能已经习惯了类似于<strong><code>-2 &lt; n &lt; 0</code> </strong>这样的写法，有的时候在Fortran 语言中也会不自觉地写成这样。但是在 Fortran语言中这种<strong>写法是不被支持的</strong>，我们需要使用逻辑运算符<code>.and.</code> 来把上下限值判断连接起来，而不能写在一起。</p><h2 id="无条件语句">无条件语句</h2><p>无条件语句一般来说与条件语句的作用是不相同的，主要是为了程序可以跳转、中途退出，但也有类似于do 循环这样的，只不过还是需要 if语句来帮助完成跳出循环的判断。<strong>无条件语句有 goto 语句、exit语句、 cycle 语句三种</strong>。</p><h3 id="goto-语句">goto 语句</h3><p>如下所示，这里的 goto 语句的用法与汇编语言的 goto语句有点类似，<strong>指定一个行号即可无条件跳转到该行执行</strong>。如果是像下面这样<strong>调用goto语句的行在跳转到的行之前，那么它们之间的行都会被完全忽略</strong>。如示例11 所示，<code>a = 15</code> 的赋值语句会被忽略所以 a 的值是在 goto语句执行之前赋的值 10；同理，<code>b = 11</code> 的赋值语句在 goto语句和跳转行之间会被忽略，跳转行的 <code>b = 20</code> 生效。如示例 12所示，当 goto 语句跳转到它之前行执行时，就会造成无限循环，每次执行到goto 语句就会又跳转到前面，这样 goto 语句后面的命令都不会被执行。</p><h5 id="小提示-4">小提示</h5><p>我们在使用 goto语句时对跳转的行一定要非常注意，一不小心很容易造成死循环。建议使用 goto语句的时候跳转到其后的行，杜绝跳转到前面的行。</p><p>为了提高代码可读性，我们<strong>不想将 goto语句跳转的行直接指向一个操作或者命令，这时我们就可以用 continue来代替跳转行</strong>，如示例 13 所示。</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs fortran"><span class="hljs-keyword">goto</span> 行号<br><br>行号 操作或命令<br><br><span class="hljs-comment">!!! 示例 11</span><br>   a = <span class="hljs-number">10</span><br>   <span class="hljs-keyword">goto</span> <span class="hljs-number">8</span><br>   b = <span class="hljs-number">11</span><br>   a = <span class="hljs-number">15</span><br><span class="hljs-number">8</span>  b = <span class="hljs-number">20</span><br>   <span class="hljs-built_in">print</span> *, a, b  <span class="hljs-comment">! 此处输出 a 的值为 10，b 的值为 20</span><br><br><span class="hljs-comment">!!! 示例 12</span><br><br><span class="hljs-number">8</span> a = <span class="hljs-number">10</span><br>  b = <span class="hljs-number">11</span><br>  a = a + b<br>  <span class="hljs-keyword">goto</span> <span class="hljs-number">8</span><br>  b = b - a       <span class="hljs-comment">! 永远不会被执行</span><br>  <span class="hljs-built_in">print</span> *, a, b   <span class="hljs-comment">! 永远不会被执行</span><br><br><span class="hljs-comment">!!! 示例 13</span><br><span class="hljs-number">8</span> <span class="hljs-keyword">continue</span><br>  a = <span class="hljs-number">10</span><br>  b = <span class="hljs-number">11</span><br>  a = a + b<br>  <span class="hljs-keyword">goto</span> <span class="hljs-number">8</span><br></code></pre></td></tr></table></figure><h3 id="exit-语句">exit 语句</h3><p>当我们在使用 do循环语句时，如果<strong>想要在某个与循环条件无关的条件满足时提前退出循环，就要使用if 语句和 exit 语句的组合</strong>了。如示例 14 所示，当 sum 的值超过 10时循环就会被提前终止。由于 <code>1+2+3+4=10</code>，所以 i 加到 5才会使得 sum 值超过 10，此时的 sum 则为 <code>1+2+3+4+5=15</code>，而 i也因为提前退出循环而不会执行自增操作，所以此时输出的 i 值为最后的5。如果将原来的 exit 语句换成 goto 语句，并将 goto语句指向的跳转行设为循环外的下一行，则最后的效果也是一样的，如示例 15所示。</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs fortran"><span class="hljs-comment">!!! 示例 14</span><br><span class="hljs-built_in">sum</span> = <span class="hljs-number">0</span><br><span class="hljs-keyword">do</span> i = <span class="hljs-number">1</span>, <span class="hljs-number">10</span><br>    <span class="hljs-built_in">sum</span> = <span class="hljs-built_in">sum</span> + i<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">sum</span> &gt; <span class="hljs-number">10</span>) <span class="hljs-keyword">exit</span><br><span class="hljs-keyword">enddo</span><br><span class="hljs-built_in">print</span> *, i, <span class="hljs-built_in">sum</span>      <span class="hljs-comment">! 输出 i 的值为 5，sum 的值为 15</span><br><br><span class="hljs-comment">!!! 示例 15</span><br>    <span class="hljs-built_in">sum</span> = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">do</span> i = <span class="hljs-number">1</span>, <span class="hljs-number">10</span><br>        <span class="hljs-built_in">sum</span> = <span class="hljs-built_in">sum</span> + i<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">sum</span> &gt; <span class="hljs-number">10</span>) <span class="hljs-keyword">goto</span> <span class="hljs-number">8</span><br>    <span class="hljs-keyword">enddo</span><br><span class="hljs-number">8</span>   <span class="hljs-built_in">print</span> *, i, <span class="hljs-built_in">sum</span>  <span class="hljs-comment">! 输出 i 的值仍为 5，sum 的值仍为 15</span><br></code></pre></td></tr></table></figure><h3 id="cycle-语句">cycle 语句</h3><p>cycle 语句与 exit语句正好表示了<strong>相反</strong>的意思，它指示程序在<strong>满足条件时继续执行循环、不满足条件时跳出循环</strong>。如示例16 所示，这个 cycle 语句的效果与示例 14、15 的完全一致。</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs fortran"><span class="hljs-comment">!!! 示例 16</span><br><span class="hljs-built_in">sum</span> = <span class="hljs-number">0</span><br><span class="hljs-keyword">do</span> i = <span class="hljs-number">1</span>, <span class="hljs-number">10</span><br>    <span class="hljs-built_in">sum</span> = <span class="hljs-built_in">sum</span> + i<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">sum</span> &lt;= <span class="hljs-number">10</span>) <span class="hljs-keyword">cycle</span><br><span class="hljs-keyword">enddo</span><br><span class="hljs-built_in">print</span> *, i, <span class="hljs-built_in">sum</span>      <span class="hljs-comment">! 输出 i 的值仍为 5，sum 的值仍为 15</span><br></code></pre></td></tr></table></figure><p>Copy</p><h3 id="多重循环下的-exit-与-goto-语句">多重循环下的 exit 与 goto语句</h3><p>一般来说在复杂的行列式计算中经常会遇到多重循环，这与以上 goto 和 exit语句的场景稍显不同。goto语句的跳转行因为可以指定任何一行，所以不会被多重循环影响，可以直接跳转到多重循环之外或者某一重循环之中的某一行，如示例17 所示。而<strong>exit语句如果还是按照上面的用法每次只能退出一重循环，碰到需要同时退出多重循环时就比较麻烦</strong>。所以Fortran 语言为了尽量避免这一问题，就给 exit 语句添加一种<strong>类似于goto 语句指示跳转行的方法 <code>exit out</code></strong>，如示例 18所示。</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs fortran"><span class="hljs-comment">!!! 示例 17</span><br>    <span class="hljs-built_in">sum</span> = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">do</span> i = <span class="hljs-number">1</span>, <span class="hljs-number">10</span><br>        <span class="hljs-keyword">do</span> j = <span class="hljs-number">1</span>, <span class="hljs-number">10</span><br>            <span class="hljs-built_in">sum</span> = <span class="hljs-built_in">sum</span> + i + j<br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">sum</span> &gt; <span class="hljs-number">10</span>) go <span class="hljs-number">10</span><br>        <span class="hljs-keyword">enddo</span><br>    <span class="hljs-keyword">enddo</span><br><span class="hljs-number">10</span>  <span class="hljs-built_in">print</span> *, i, j, <span class="hljs-built_in">sum</span>   <span class="hljs-comment">! 输出 i 的值为 1，j 的值为 4，sum 的值为 11</span><br><br><span class="hljs-comment">!!! 示例 18</span><br><span class="hljs-built_in">sum</span> = <span class="hljs-number">0</span><br><span class="hljs-keyword">out</span>: <span class="hljs-keyword">do</span> i = <span class="hljs-number">1</span>, <span class="hljs-number">10</span><br>        <span class="hljs-keyword">do</span> j = <span class="hljs-number">1</span>, <span class="hljs-number">10</span><br>            <span class="hljs-built_in">sum</span> = <span class="hljs-built_in">sum</span> + i + j<br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">sum</span> &gt; <span class="hljs-number">10</span>) <span class="hljs-keyword">exit</span> <span class="hljs-keyword">out</span><br>        <span class="hljs-keyword">enddo</span><br>     <span class="hljs-keyword">enddo</span> <span class="hljs-keyword">out</span><br><span class="hljs-built_in">print</span> *, i, j, <span class="hljs-built_in">sum</span>       <span class="hljs-comment">! 输出 i 的值为 1，j 的值为 4，sum 的值为 11 </span><br></code></pre></td></tr></table></figure><h5 id="小提示-5">小提示</h5><p>这里需要注意的是，<strong>当使用 <code>exit out</code> 方法时，out是对应于循环的一个别名，需要同时在 do 前和 enddo 后添加 out的声明</strong>。当然，这里的别名也可以使用其他符合规则的字符串，只要不与同一个代码文件中的其他别名或变量名等相同即可。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Fortran</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Fortran 基础知识</title>
    <link href="/2022/05/23/Fortran-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    <url>/2022/05/23/Fortran-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
    
    <content type="html"><![CDATA[<h2 id="主函数">主函数</h2><p>一个完整的Fortran代码，一般来说，<strong>以<code>program code_name</code> 开始，以<code>end program code_name</code>结束的首末声明</strong>，<strong>变量声明</strong>以及<strong>需要执行的命令或者操作</strong>三个部分组成。通用的Fortran 代码文件的文件后缀可以是<code>.f90</code>、<code>.f</code>、<code>.g95</code>等等，但通常为了统一和适应不同版本的 Fortran 编译环境<strong>建议采用<code>.f90</code> 后缀</strong>。和 C、C++ 语言比较类似，Fortran代码也是通过编译执行。比如对如下所示的示例代码执行<strong><code>gfortran code_name.f90 -o code_name</code></strong>即可生成可执行程序 <code>code_name</code>，再执行<strong><code>./code_name</code> </strong>则会输出代码执行结果如下。</p><p>code_name.f90</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs fortran"><span class="hljs-function"><span class="hljs-keyword">program</span></span> code_name<br>    <span class="hljs-keyword">implicit</span> <span class="hljs-keyword">none</span><br>    <span class="hljs-keyword">real</span> x, y, z<br>    x = <span class="hljs-number">2</span><br>    y = <span class="hljs-number">3</span><br>    z = x + y * <span class="hljs-number">5</span><br>    <span class="hljs-built_in">print</span> *, x, y<br>    <span class="hljs-built_in">print</span> *, <span class="hljs-string">&#x27;z = &#x27;</span>, z <br><span class="hljs-keyword">end</span> <span class="hljs-function"><span class="hljs-keyword">program</span></span> code_name<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">  2.00000000       3.00000000    <br>z =    17.0000000<br></code></pre></td></tr></table></figure><p>上面给出的示例代码中有一行<code>implicit none</code>，明明本来的代码已经符合三个部分了，为什么要多加这一行呢？这是因为在旧Fortran 中存在隐式类型声明，为了规避在 Fortran 95以后的版本中可能出现错误，特意在每个开头声明之后都加上这么一行。这样我们在写代码的过程中如果使用到了未提前声明或者打错字符的变量名，编译程序就会报错告知我们。这对于形成良好的代码习惯和增强代码可维护性有很大的帮助，因此此行声明必不可少。</p><h2 id="运算符">运算符</h2><p>Fortran语言和别的高级编程语言一样，都拥有完整的运算符，包括简单的加减乘除、复杂的乘方等运算。如下表所示是Fortran语言中的运算符的写法和使用方法，其中运算符的计算优先顺序与数学计算中一致：<strong>乘方运算&gt; 乘除运算 &gt; 加减运算</strong>。</p><h2 id="数据类型与变量声明">数据类型与变量声明</h2><p>Fortran语言的数据类型比较简单，没有像其他高级编程语言那样分得那么细，主要分为<strong>整数型</strong>和<strong>实数型</strong>两个大类。整数型的计算与C、C++、Python中有点类似，整数与整数的商还是一个整数。<strong>即使当不整除的时候，为了保持结果和参与运算的变量类型一致Fortran编译器会只取正常数学运算结果的整数部分</strong>。实数型其实与数学意义上的实数是一致的，既<strong>包括整数也包括小数</strong>，所以当不整除的除法中的两个变量<strong>有一个为实数型</strong>时，Fortran编译器会将两个变量类型对应成实数型并<strong>计算出正常的带小数的结果</strong>。</p><p><strong>所有变量都要在使用之前声明类型</strong>，所以<strong>当属于同一种类型时我们可以按照下面那样写在同一行</strong>，不同变量之间用逗号分隔开。为了代码美观，<strong>建议在逗号与后一个变量名之间留一个空格</strong>。</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs fortran"><span class="hljs-comment">!!! 两个整数型相除</span><br><span class="hljs-keyword">integer</span> x, y<br>x = <span class="hljs-number">2</span><br>y = <span class="hljs-number">3</span><br><span class="hljs-built_in">print</span> *, x/y   <span class="hljs-comment">! 结果为 0</span><br><span class="hljs-built_in">print</span> *, y/x   <span class="hljs-comment">! 结果为 1</span><br><br><span class="hljs-comment">!!! 被除数为实数型，除数为整数型</span><br><span class="hljs-keyword">real</span> m <br><span class="hljs-keyword">integer</span> n <br>m = <span class="hljs-number">10</span><br>n = <span class="hljs-number">3</span><br><span class="hljs-built_in">print</span> *, m/n   <span class="hljs-comment">! 结果为  3.33333325</span><br><br><span class="hljs-comment">!!! 被除数为整数型，除数为实数型</span><br><span class="hljs-keyword">integer</span> m <br><span class="hljs-keyword">real</span> n <br>m = <span class="hljs-number">10</span><br>n = <span class="hljs-number">3</span><br><span class="hljs-built_in">print</span> *, m/n   <span class="hljs-comment">! 结果为  3.33333325</span><br><br><span class="hljs-comment">!!! 被除数和除数均为实数型</span><br><span class="hljs-keyword">real</span> m, n<br>m = <span class="hljs-number">10</span><br>n = <span class="hljs-number">3</span><br><span class="hljs-built_in">print</span> *, m/n   <span class="hljs-comment">! 结果为  3.33333325</span><br></code></pre></td></tr></table></figure><p>实际上，Fortran语言除了整数型和实数型两个大类之外，还有一些小类，比如说<strong>复数类型、布尔类型、字符串类型</strong>。因为操作系统一般使用实数型或者复数类型时都<strong>默认采用单精度</strong>，如果需要使用双精度则需要特殊声明。所有数据类型总结如下：</p><table><thead><tr class="header"><th>数据类型</th><th>标识符</th><th>示例</th></tr></thead><tbody><tr class="odd"><td>整数型</td><td>integer</td><td>2</td></tr><tr class="even"><td>实数型</td><td>real</td><td>2.0</td></tr><tr class="odd"><td>双精度实数型</td><td>double precision</td><td>2.0</td></tr><tr class="even"><td>复数型</td><td>complex</td><td>(1.0, 2.0)</td></tr><tr class="odd"><td>双精度复数型</td><td>complex(kind(0d0))</td><td>(1.0, 2.0)</td></tr><tr class="even"><td>布尔型</td><td>logical</td><td>true/false</td></tr><tr class="odd"><td>字符串型</td><td>character</td><td>"Text"</td></tr></tbody></table><h5 id="小提示">小提示</h5><p>这里有一点值得十分注意：一个 Fortran文件的<strong>变量声明必须在最开始</strong>，如果多个变量声明行之间掺杂了其他的操作行或者命令行，则<strong>后续的变量声明将会无效</strong>，在编译的过程中就会直接报错。</p><h2 id="数学函数">数学函数</h2><p>Fortran既然是为数值计算而生的，那么自然就包含了对初等数学函数和数据类型变化函数的完整支持。如下表所示为有关初等数学函数的写法和用法。</p><table><thead><tr class="header"><th>写法</th><th>函数名称</th><th>数学表达</th><th>必要条件</th><th>函数值的范围</th></tr></thead><tbody><tr class="odd"><td>sqrt(x)</td><td>平方根</td><td><em>x</em></td><td>x <em>x</em>≧0</td><td></td></tr><tr class="even"><td>sin(x)</td><td>正弦函数</td><td>xsin<em>x</em></td><td></td><td></td></tr><tr class="odd"><td>cos(x)</td><td>余弦函数</td><td>xcos<em>x</em></td><td></td><td></td></tr><tr class="even"><td>tan(x)</td><td>正切函数</td><td>xtan<em>x</em></td><td></td><td></td></tr><tr class="odd"><td>asin(x)</td><td>反正弦函数</td><td>^{-1}xsin−1<em>x</em></td><td>-1x −1≦<em>x</em>≦1</td><td>- f −2<em>π</em>≦<em>f</em>≦2<em>π</em></td></tr><tr class="even"><td>acos(x)</td><td>反余弦函数</td><td>^{-1}xcos−1<em>x</em></td><td>-1x −1≦<em>x</em>≦1</td><td>0 f ≦<em>f</em>≦<em>π</em></td></tr><tr class="odd"><td>atan(x)</td><td>反正切函数</td><td>^{-1}xtan−1<em>x</em></td><td></td><td>- &lt; f &lt; −2<em>π</em>&lt;<em>f</em>&lt;2<em>π</em></td></tr><tr class="even"><td>atan2(y, x)</td><td>反正切函数</td><td>^{-1}(y/x)tan−1(<em>y</em>/<em>x</em>)</td><td></td><td>-&lt; f &lt; −<em>π</em>&lt;<em>f</em>&lt;<em>π</em></td></tr><tr class="odd"><td>exp(x)</td><td>指数函数</td><td>e^x*e**x*</td><td></td><td></td></tr><tr class="even"><td>log(x)</td><td>对数函数</td><td>_{e}xlog*e**x*</td><td>x &gt; 0<em>x</em>&gt;0</td><td></td></tr><tr class="odd"><td>log10(x)</td><td>常用对数函数</td><td>_{10}xlog10<em>x</em></td><td>x &gt; 0<em>x</em>&gt;0</td><td></td></tr><tr class="even"><td>sinh(x)</td><td>双曲正弦函数</td><td>xsinh<em>x</em></td><td></td><td></td></tr><tr class="odd"><td>cosh(x)</td><td>双曲余弦函数</td><td>xcosh<em>x</em></td><td></td><td></td></tr><tr class="even"><td>tanh(x)</td><td>双曲正切函数</td><td>xtanh<em>x</em></td><td></td><td></td></tr></tbody></table><p>下表为有关数据类型变化函数的写法和用法。</p><table><thead><tr class="header"><th>写法</th><th>函数名称</th><th>输入类型</th><th>输出类型</th><th>函数的含义</th></tr></thead><tbody><tr class="odd"><td>real(n)</td><td>实数化</td><td>整数</td><td>实数</td><td>变成实数型</td></tr><tr class="even"><td>abs(n)</td><td>绝对值</td><td>整数</td><td>整数</td><td>n<em>n</em> 的绝对值</td></tr><tr class="odd"><td>mod(m, n)</td><td>求余</td><td>2个整数</td><td>整数</td><td>m<em>m</em> 对 n<em>n</em> 求余</td></tr><tr class="even"><td>int(x)</td><td>整数化</td><td>实数</td><td>整数</td><td>变成整数型(去尾)</td></tr><tr class="odd"><td>nint(x)</td><td>整数化</td><td>实数</td><td>整数</td><td>变成整数型(四舍五入)</td></tr><tr class="even"><td>sign(x, s)</td><td>符号变更</td><td>实数</td><td>实数</td><td>s , x ; s &lt; 0, -xs<em>≧0,∣</em>x<em>∣;</em>s<em>&lt;0,−∣</em>x*∣</td></tr><tr class="odd"><td>abs(x)</td><td>绝对值</td><td>实数或复数</td><td>实数</td><td>x<em>x</em> 的绝对值</td></tr><tr class="even"><td>mod(x, y)</td><td>求余</td><td>2个实数</td><td>实数</td><td>x<em>x</em> 对 y<em>y</em> 求余</td></tr><tr class="odd"><td>real(z)</td><td>复数的实部</td><td>复数</td><td>实数</td><td>z<em>z</em> 的实部</td></tr><tr class="even"><td>imag(z)</td><td>复数的虚部</td><td>复数</td><td>实数</td><td>z<em>z</em> 的虚部</td></tr><tr class="odd"><td>cmplx(x, y)</td><td>复数化</td><td>两个实数</td><td>复数</td><td>x+iy<em>x</em>+*i**y*</td></tr><tr class="even"><td>conjg(z)</td><td>共轭复数</td><td>复数</td><td>复数</td><td>z<em>z</em> 的共轭复数</td></tr></tbody></table><h2 id="打印输出">打印输出</h2><p>Fortran 的打印输出其实已经在前面的示例代码中已经提到了，就是所谓的<code>print</code> 语句。<strong><code>print</code> 语句必须紧接着<code>*</code></strong>，其含义是按照标准格式输出，如果缺失这个的话在编译时就会报出<code>Error: Expected comma in I/O list at (1)</code>的错误。正确的打印输出示例代码如下：</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs fortran"><span class="hljs-keyword">integer</span> n<br>n = <span class="hljs-number">2</span><br><span class="hljs-built_in">print</span> *, <span class="hljs-number">1</span>+<span class="hljs-number">2</span>, n, n-<span class="hljs-number">1</span>, n/<span class="hljs-number">1</span>, n**<span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><p>输出结果如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">3           2           1           2           <br></code></pre></td></tr></table></figure><p>如果需要和其他高级编程语言那样<strong>在输出的过程中加入字符串到其中</strong>，则按如下设置：</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs fortran"><span class="hljs-keyword">real</span> m<br>m = <span class="hljs-number">5</span><br><span class="hljs-built_in">print</span> *, <span class="hljs-string">&#x27;m = &#x27;</span>, m, <span class="hljs-string">&#x27;  m*2 = &#x27;</span>, m*<span class="hljs-number">2</span><br><span class="hljs-built_in">print</span> *, <span class="hljs-string">&#x27;m = &#x27;</span>,m, <span class="hljs-string">&#x27;  m*2 = &#x27;</span>,m*<span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><p>输出结果如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">m =    5.00000000       m*2 =    10.0000000<br>m =    5.00000000       m*2 =    10.0000000<br></code></pre></td></tr></table></figure><p>根据以上输出结果我们可以看出，<code>m</code> 与 <code>=</code>之间的一个空格与实际输出时是一致的，而输出变量 <code>m</code>时不管与前一个逗号之间是否有空格，输出结果都不会发生改变，都存在超过一个以上的空格。实际上，这也是Fortran编译器为了能够区分输出内容，而特意在标准输出时对逗号分割的内容上添加这样的空格。不过为了代码阅读上的美观，建议在代码编写时还是保持变量与逗号之间的一个空格。</p><h5 id="小提示-1">小提示</h5><p>这里输出字符串的时候引用字符串的符号<strong>可以使用<code>'</code>，也可以使用<code>"</code></strong>。本质上没有什么区别，只是需要成对使用，不然就会报错。</p><h2 id="数组">数组</h2><h3 id="数组的定义">数组的定义</h3><p>前面我们所介绍的有关数据类型基本上能够涵盖一般的日常使用，但是对于科研人员来说，矩阵、行列式等等才是计算过程中不可缺少的数据类型。为此，Fortran也有了数组一样的数据类型来支持这一需求。如下所示，我们可以直接采用原有的整数型、实数型和复数型定义数组。<strong>当括号中只有一个数字时，表示是一维数组；当括号中有逗号分割的两个数字时，表示是二维数组；三维数组以此类推</strong>。二维数组可以用于表示我们所熟知的矩阵、行列式等数据类型。</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs fortran"><span class="hljs-keyword">integer</span> m(<span class="hljs-number">10</span>)         <span class="hljs-comment">! 长度为 10 的整数型数组</span><br><span class="hljs-keyword">real</span> x(<span class="hljs-number">20</span>), y(<span class="hljs-number">4</span>, <span class="hljs-number">5</span>)   <span class="hljs-comment">! 长度为 20 的实数型数组， 4 行 x 5 列的二维实数型数组</span><br><span class="hljs-keyword">complex</span> matrix(<span class="hljs-number">5</span>, <span class="hljs-number">5</span>)  <span class="hljs-comment">! 5 行 x 5 列的二维复数型数组</span><br></code></pre></td></tr></table></figure><h5 id="小提示-2">小提示</h5><p>这里需要注意的是，在定义数组的时候<strong>不仅可以用正整数，也可以用负整数和0</strong>。比如 <code>real n(-3:5)</code> 表示定义一个长度为 9、序号从-3 到 5 (包括 0)的一维数组，<code>real m(-2:1, 0:4)</code> 表示定义一个3 行 x 4 列、行序号从 -2 到 0、列序号从 1 到 4的二维数组。一般来说，为了与实际数学运算中的理解保持一致，建议采用正整数来定义数组更加方便。</p><h3 id="数组元素的选取">数组元素的选取</h3><p>既然定义了数组，那么我们就需要有对于数组的增加、选择这样的基本操作。<strong>Fortran数组中的序号是从 1 开始的，即写作n(1)</strong>，这点与其他高级编程语言略有不同，不过符合人类的数学认识。因此如下所示，当定义一个长度为10 的数组 n 时，数组 n 的最后一个元素就是n(10)。在实际的存储中，我们能够很容易理解一维数组是按照 1 到 10的顺序从左往右排列的，但是在二维数组中又会是怎么样呢？是行优先还是列优先呢？一般来说，在我们接触过的高级编程语言中几乎都是行优先的，即先存储第一行再存储第二行，以此类推。但是，在Fortran 中则是<strong>列优先</strong>的，也就是说 Fortran的二维数组<strong>存储时会先存储第一列再存储第二列</strong>，再以此类推。</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs fortran"><span class="hljs-keyword">real</span> n(<span class="hljs-number">10</span>)     <span class="hljs-comment">! n(1) ~ n(10)</span><br><span class="hljs-keyword">real</span> m(<span class="hljs-number">4</span>, <span class="hljs-number">4</span>)   <span class="hljs-comment">! m(1, 1) m(2, 1) m(3, 1) ... m(4, 4)</span><br></code></pre></td></tr></table></figure><h5 id="小提示-3">小提示</h5><p>如果我们在使用数组 n的过程中忘记了加上序号，那么程序<strong>默认就会对整个数组的全部元素进行操作</strong>，而非像其他高级编程语言可能会指向数组的第一个元素。</p><p>当我们想要去选取数组中的某一个元素时，可以直接通过对应的序号进行选取。但是如果想要选多个元素或者某一行、某一列时，这就有点不同了。比如说，现在有一个长度为10 的一维数组 n，我们想要获取到从第 3 个元素到第 5 个元素的 3个元素，<strong>应该使用 <code>:</code>来将序号的上下限分隔开同时选中，即 n(3:5)</strong>。如果有一个 3 行 x 4列 的二维数组 m，我们想要获取到第 2 行到第 3 行的所有元素，则应该使用m(2:3, 1:4) 来选取。</p><h2 id="跨行与注释">跨行与注释</h2><p>有的时候我们编写的<strong>计算式可能会比较长</strong>，这个时候为了代码和公式的高可阅读性，我们通常采用Fortran语言所提供的跨行功能。比如说如下所示的原打印输出，就可以在<strong>中途使用<code>&amp;</code>符号来声明下一行是前一行的后续</strong>，这样的执行结果是一致的。</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs fortran"><span class="hljs-built_in">print</span> *, zhang, qian, sun, li, zhou, wu, zhen, wang<br><br><span class="hljs-comment">!!! 可以换成</span><br><span class="hljs-built_in">print</span> *, zhang, qian, sun, li &amp;<br>       , zhou, wu, zhen, wang<br></code></pre></td></tr></table></figure><p>上面的例子是变量的跨行输出，如果是一个长字符串，也是可以使用一样的方式的，<strong>只是需要在中断的前一行末尾和下一行开头同时加上<code>&amp;</code> 符号</strong>，如下所示。</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs fortran"><span class="hljs-built_in">print</span> *, <span class="hljs-string">&#x27;Fortran is so good for the scientific calculation.&#x27;</span><br><br><span class="hljs-comment">!!! 可以换成</span><br><span class="hljs-built_in">print</span> *, <span class="hljs-string">&#x27;Fortran is so good &amp;</span><br><span class="hljs-string">          &amp;for the scientific calculation.&#x27;</span><br></code></pre></td></tr></table></figure><p>我们之前在定义变量的时候已经提过，为了代码整洁性可能会同时将同一类型的变量放置在同一行，之间用逗号分割即可。如果是在给变量赋值的时候，是不是也能够将赋值式放置在同一行呢？原则上来说，<strong>如果赋值式比较短的话，是可以将多行赋值式缩短在同一行的</strong>，它们之间使用<code>;</code>进行连接。这里值得注意的是，<strong>最后一个赋值式后面一定不要多加<code>;</code></strong>，如下所示。</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs fortran"><span class="hljs-comment">!!! 修改前</span><br>x = <span class="hljs-number">3</span><br>y = <span class="hljs-number">4</span><br>z = <span class="hljs-number">5</span><br><br><span class="hljs-comment">!!! 修改后</span><br>x = <span class="hljs-number">3</span>; y = <span class="hljs-number">4</span>; z = <span class="hljs-number">5</span><br></code></pre></td></tr></table></figure><p>Fortran语言中的注释其实在上面的内容中也已经接触到了，<strong><code>!</code>之后的内容将会被 Fortran 编译器认为是注释内容</strong>。一般来说，一个<code>!</code>的注释其实就已经足够了，但是为了区分行注释与行末注释，建议在<strong>行注释的时候使用三个<code>!</code></strong>，而在<strong>行末注释时使用一个<code>!</code></strong>。当然如果存在相邻多行同时进行注释，或者在一个可视窗口内有多个行末注释，建议协调成同一列以增强代码整洁性。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Fortran</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++ 多态</title>
    <link href="/2022/05/22/C++/"/>
    <url>/2022/05/22/C++/</url>
    
    <content type="html"><![CDATA[<p>​有了虚函数，基类指针指向基类对象时就使用基类的成员（包括成员函数和成员变量），指向派生类对象时就使用派生类的成员。换句话说，基类指针可以按照基类的方式来做事，也可以按照派生类的方式来做事，它有多种形态，或者说有多种表现方式，我们将这种现象称为<strong>多态（Polymorphism）</strong>。</p><p>​C++提供多态的目的是：可以通过基类指针对所有派生类（包括直接派生和间接派生）的成员变量和成员函数进行“全方位”的访问，尤其是成员函数。如果没有多态，我们只能访问成员变量。</p><p>​除了指针，<strong>引用也可以实现多态</strong>。不过引用不像指针灵活，指针可以随时改变指向，而引用只能指代固定的对象，在多态性方面缺乏表现力，所以以后我们再谈及多态时一般是说指针。</p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
