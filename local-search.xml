<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>大气光学湍流模型研究与实践-笔记</title>
    <link href="/2022/05/24/%E5%A4%A7%E6%B0%94%E5%85%89%E5%AD%A6%E6%B9%8D%E6%B5%81%E6%A8%A1%E5%9E%8B%E7%A0%94%E7%A9%B6%E4%B8%8E%E5%AE%9E%E8%B7%B5-%E7%AC%94%E8%AE%B0/"/>
    <url>/2022/05/24/%E5%A4%A7%E6%B0%94%E5%85%89%E5%AD%A6%E6%B9%8D%E6%B5%81%E6%A8%A1%E5%9E%8B%E7%A0%94%E7%A9%B6%E4%B8%8E%E5%AE%9E%E8%B7%B5-%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<p>大气光学湍流强度在垂直方向的分布，称为<strong>大气光学湍流廓线</strong>，通常记为 $C_{n}^{2}$廓线</p><p>大气相干长度 $r_0$,也被称为Fried常数，表征<strong>分辨率不再受大气湍流影响的望远镜的等效口径</strong>。$C_n^2$廓线直接对高度积分，就可以得到大气相干长度。$r_0$进行简单的变化，就是我们经常使用的大气视宁度。$ε&#x3D;0.98\frac{λ}{r_0}$,<strong>大气视宁度</strong>表示大口径望远镜焦面上星象的半峰全宽。</p><p>自适应光学技术通过实时补偿大气扰动造成的波前畸变，来改善成像质量。对天文选址提出新的要求，高空湍流及其相关的参数：等晕角、大气相干时间则变得更加重要。</p><p>**等晕角 $θ_{AO}$**表示在望远镜的入瞳处具有近似波前的两个星象的最大角距。高空 $C_n^2$值越大，等晕角的值越小。等晕角$θ_{AO}$对于N个变形镜的自适应光学系统，能够归一化到$θ_{N}$,它对应的改正后的等晕区的视场，能够影响覆盖天区的大小。</p><p>**大气相干时间 $τ_{AO}$**表示波前保持相干时间。V(h)表示大气风速廓线。湍流强度所在位置的风速越大，大气相干时间的值越小。</p><p>**湍流外尺度 $L_0$,内尺度 $l_0$。温度结构函数 $C_t^2$**。</p><p>位温θ，位温的结构函数$D_θ（l）$，其中 $\overline{ N}$表示位温扰动方差的耗散率，$\epsilon$为湍动能耗散率。$C_θ^2$表示位温结构常数。</p><p>**理查德森数 $R_i$**来表示大气光学湍流的稳定程度。</p><p>目前已有许多成熟的技术设备来测量 $C_{n}^{2}$廓线及其积分参数值：</p><p><strong>DIMM(Differential Image Motion Monitor)</strong>,SLODAR等通过测量波前倾斜来获取光学湍流参数；可以测量大气相干长度，或者视宁度。</p><p><strong>MASS（Multi-Aperture Scintillation Senor）</strong>,SCIDAR(Scintillation Detection and Ranging)等通过测量闪烁；可以测量 $C_{n}^{2}$廓线、大气相干长度、大气相干时间、等晕角。</p><p>SODAR，<strong>SNODAR（Surface layer Non-Doppler Acoustic Radar）</strong>等通过向空间发射声波，通过接受回波来计算官学湍流信息。可以测量 $C_{n}^{2}$廓线、大气相干长度、大气相干时间、等晕角。</p><p>探空气不适合研究天文台址的光学湍流参数。目前用于计算光学湍流参数的气象模式主要有Meso-NH（Non-Hydrostatic Mesoscale Atmospheric Model）、&#x3D;&#x3D;WRF（Weather Research and Forecasting Moel）&#x3D;&#x3D;和MM5（Mesoscale Model 5）；</p><p>WRF是由美国开发的新一代中尺度非静力学天气预报模式。WRF模式分为两种，<strong>ARF（the Advanced Research）和NMM（the Nonhydrostatic Mesoscale Model）</strong>，即&#x3D;&#x3D;高级研究和业务预报&#x3D;&#x3D;两种模式，水平方向采用Arakawa C网格点，垂直方向则采用地形跟随质量坐标。在时间积分方面采用三阶或者四阶的Runge-Kutta算法。WRF模式的源代码以及所需地形、气象数据都可以由NCAR和NCEP的网站下载。</p><p>英文对照</p><p>相干时间  coherent time  COH_TIME</p><p>等晕角 isohalo angle ISO_ANGLE</p><p>边界层视宁度 boundary layer seeing</p><p>经纬度 Longitude and latitude</p><p>地表高度 surface height</p><p>相干长度 coherence length</p><p>自由大气视宁角 Free Atmospheric Seeing Angle</p><p>高度 high</p><p>厚度 thickness</p><p>风速 wind speed</p><p>风向 wind direction</p><p>风速梯度 wind speed gradient</p><p>温度 temperature</p><p>气温 air temperature</p><p>位温 Potential temperature</p><p>位温梯度 Potential temperature gradient</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Fortran-动态数组&amp;导出数据类型&amp;指针</title>
    <link href="/2022/05/23/Fortran-%E5%8A%A8%E6%80%81%E6%95%B0%E7%BB%84-%E5%AF%BC%E5%87%BA%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B-%E6%8C%87%E9%92%88/"/>
    <url>/2022/05/23/Fortran-%E5%8A%A8%E6%80%81%E6%95%B0%E7%BB%84-%E5%AF%BC%E5%87%BA%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B-%E6%8C%87%E9%92%88/</url>
    
    <content type="html"><![CDATA[<h2 id="动态数组"><a href="#动态数组" class="headerlink" title="动态数组"></a>动态数组</h2><p>动态数组是一种数组，其尺寸在编译时不知道，而是在执行时才已知&#x2F;确定的。</p><p>​动态数组的属性使用 allocatable 声明。 .</p><p>​例如，</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs fortran"><span class="hljs-keyword">real</span>, <span class="hljs-keyword">dimension</span> (:,:), <span class="hljs-keyword">allocatable</span> :: darray    <br></code></pre></td></tr></table></figure><p>​数组的秩，即尺寸，必须提到但是，分配内存以这样的阵列，可以使用allocate函数。</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs fortran"><span class="hljs-built_in">allocate</span> ( darray(s1,s2) )      <br></code></pre></td></tr></table></figure><p>​该阵列使用后，在该程序中，所创建的存储器应该使用 deallocate 函数解除</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs fortran"><span class="hljs-built_in">deallocate</span> (darray)  <br></code></pre></td></tr></table></figure><p>​<strong>示例</strong></p><p>​下面的例子演示了上面讨论的概念。</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs fortran"><span class="hljs-function"><span class="hljs-keyword">program</span></span> dynamic_array <br><span class="hljs-keyword">implicit</span> <span class="hljs-keyword">none</span> <br><br>   <span class="hljs-comment">!rank is 2, but size not known   </span><br>   <span class="hljs-keyword">real</span>, <span class="hljs-keyword">dimension</span> (:,:), <span class="hljs-keyword">allocatable</span> :: darray    <br>   <span class="hljs-keyword">integer</span> :: s1, s2     <br>   <span class="hljs-keyword">integer</span> :: i, j     <br>   <br>   <span class="hljs-built_in">print</span>*, <span class="hljs-string">&quot;Enter the size of the array:&quot;</span>     <br>   read*, s1, s2      <br>   <br>   <span class="hljs-comment">! allocate memory      </span><br>   <span class="hljs-built_in">allocate</span> ( darray(s1,s2) )      <br>   <br>   <span class="hljs-keyword">do</span> i = <span class="hljs-number">1</span>, s1           <br>      <span class="hljs-keyword">do</span> j = <span class="hljs-number">1</span>, s2                <br>         darray(i,j) = i*j               <br>         <span class="hljs-built_in">print</span>*, <span class="hljs-string">&quot;darray(&quot;</span>,i,<span class="hljs-string">&quot;,&quot;</span>,j,<span class="hljs-string">&quot;) = &quot;</span>, darray(i,j)           <br>      <span class="hljs-keyword">end</span> <span class="hljs-keyword">do</span>      <br>   <span class="hljs-keyword">end</span> <span class="hljs-keyword">do</span>      <br>   <br>   <span class="hljs-built_in">deallocate</span> (darray)  <br><span class="hljs-keyword">end</span> <span class="hljs-function"><span class="hljs-keyword">program</span></span> dynamic_array<br></code></pre></td></tr></table></figure><p>​当上述代码被编译和执行时，它产生了以下结果：</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs fortran">Enter the <span class="hljs-built_in">size</span> of the array: <span class="hljs-number">3</span>,<span class="hljs-number">4</span><br>darray( <span class="hljs-number">1</span> , <span class="hljs-number">1</span> ) = <span class="hljs-number">1.00000000</span>    <br>darray( <span class="hljs-number">1</span> , <span class="hljs-number">2</span> ) = <span class="hljs-number">2.00000000</span>    <br>darray( <span class="hljs-number">1</span> , <span class="hljs-number">3</span> ) = <span class="hljs-number">3.00000000</span>    <br>darray( <span class="hljs-number">1</span> , <span class="hljs-number">4</span> ) = <span class="hljs-number">4.00000000</span>    <br>darray( <span class="hljs-number">2</span> , <span class="hljs-number">1</span> ) = <span class="hljs-number">2.00000000</span>    <br>darray( <span class="hljs-number">2</span> , <span class="hljs-number">2</span> ) = <span class="hljs-number">4.00000000</span>    <br>darray( <span class="hljs-number">2</span> , <span class="hljs-number">3</span> ) = <span class="hljs-number">6.00000000</span>    <br>darray( <span class="hljs-number">2</span> , <span class="hljs-number">4</span> ) = <span class="hljs-number">8.00000000</span>    <br>darray( <span class="hljs-number">3</span> , <span class="hljs-number">1</span> ) = <span class="hljs-number">3.00000000</span>    <br>darray( <span class="hljs-number">3</span> , <span class="hljs-number">2</span> ) = <span class="hljs-number">6.00000000</span>    <br>darray( <span class="hljs-number">3</span> , <span class="hljs-number">3</span> ) = <span class="hljs-number">9.00000000</span>    <br>darray( <span class="hljs-number">3</span> , <span class="hljs-number">4</span> ) = <span class="hljs-number">12.0000000</span>   <br></code></pre></td></tr></table></figure><h3 id="使用data语句"><a href="#使用data语句" class="headerlink" title="使用data语句"></a>使用data语句</h3><p>​data 语句可用于初始化多个阵列，或用于阵列部分的初始化。</p><p>​data 语句的语法是：</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs fortran"><span class="hljs-keyword">data</span> variable / list / ...<br></code></pre></td></tr></table></figure><p>​<strong>示例</strong></p><p>​下面的例子演示了这一概念：</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs fortran"><span class="hljs-function"><span class="hljs-keyword">program</span></span> dataStatement<br><span class="hljs-keyword">implicit</span> <span class="hljs-keyword">none</span><br><br>   <span class="hljs-keyword">integer</span> :: a(<span class="hljs-number">5</span>), b(<span class="hljs-number">3</span>,<span class="hljs-number">3</span>), c(<span class="hljs-number">10</span>),i, j<br>   <span class="hljs-keyword">data</span> a /<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>,<span class="hljs-number">10</span>,<span class="hljs-number">11</span>/ <br>   <br>   <span class="hljs-keyword">data</span> b(<span class="hljs-number">1</span>,:) /<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>/ <br>   <span class="hljs-keyword">data</span> b(<span class="hljs-number">2</span>,:)/<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>/ <br>   <span class="hljs-keyword">data</span> b(<span class="hljs-number">3</span>,:)/<span class="hljs-number">3</span>,<span class="hljs-number">3</span>,<span class="hljs-number">3</span>/ <br>   <span class="hljs-keyword">data</span> (c(i),i=<span class="hljs-number">1</span>,<span class="hljs-number">10</span>,<span class="hljs-number">2</span>) /<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>/ <br>   <span class="hljs-keyword">data</span> (c(i),i=<span class="hljs-number">2</span>,<span class="hljs-number">10</span>,<span class="hljs-number">2</span>)/<span class="hljs-number">5</span>*<span class="hljs-number">2</span>/<br>   <br>   <span class="hljs-built_in">Print</span> *, <span class="hljs-string">&#x27;The A array:&#x27;</span><br>   <span class="hljs-keyword">do</span> j = <span class="hljs-number">1</span>, <span class="hljs-number">5</span>                <br>      <span class="hljs-built_in">print</span>*, a(j)           <br>   <span class="hljs-keyword">end</span> <span class="hljs-keyword">do</span> <br>   <br>   <span class="hljs-built_in">Print</span> *, <span class="hljs-string">&#x27;The B array:&#x27;</span><br>   <span class="hljs-keyword">do</span> i = <span class="hljs-built_in">lbound</span>(b,<span class="hljs-number">1</span>), <span class="hljs-built_in">ubound</span>(b,<span class="hljs-number">1</span>)<br>      <span class="hljs-built_in">write</span>(*,*) (b(i,j), j = <span class="hljs-built_in">lbound</span>(b,<span class="hljs-number">2</span>), <span class="hljs-built_in">ubound</span>(b,<span class="hljs-number">2</span>))<br>   <span class="hljs-keyword">end</span> <span class="hljs-keyword">do</span><br><br>   <span class="hljs-built_in">Print</span> *, <span class="hljs-string">&#x27;The C array:&#x27;</span> <br>   <span class="hljs-keyword">do</span> j = <span class="hljs-number">1</span>, <span class="hljs-number">10</span>                <br>      <span class="hljs-built_in">print</span>*, c(j)           <br>   <span class="hljs-keyword">end</span> <span class="hljs-keyword">do</span>      <br>   <br><span class="hljs-keyword">end</span> <span class="hljs-function"><span class="hljs-keyword">program</span></span> dataStatement<br></code></pre></td></tr></table></figure><p>​当上述代码被编译和执行时，它产生了以下结果：</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs fortran">The A array:<br><span class="hljs-number">7</span><br><span class="hljs-number">8</span><br><span class="hljs-number">9</span><br><span class="hljs-number">10</span><br><span class="hljs-number">11</span><br>The B array:<br><span class="hljs-number">1</span>  <span class="hljs-number">1</span>  <span class="hljs-number">1</span><br><span class="hljs-number">2</span>  <span class="hljs-number">2</span>  <span class="hljs-number">2</span><br><span class="hljs-number">3</span>  <span class="hljs-number">3</span>  <span class="hljs-number">3</span><br>The C array:<br><span class="hljs-number">4</span><br><span class="hljs-number">2</span><br><span class="hljs-number">5</span><br><span class="hljs-number">2</span><br><span class="hljs-number">6</span><br><span class="hljs-number">2</span><br><span class="hljs-number">7</span><br><span class="hljs-number">2</span><br><span class="hljs-number">8</span><br><span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><h3 id="使用where语句"><a href="#使用where语句" class="headerlink" title="使用where语句"></a>使用where语句</h3><p>​where语句可以使用数组中的某些元素在一个表达式，根据一些逻辑条件的结果。它允许表达的执行在一个元素上，如果给定的条件为真。</p><p>​<strong>例子</strong></p><p>​下面的例子演示了这一概念：</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs fortran"><span class="hljs-function"><span class="hljs-keyword">program</span></span> whereStatement<br><span class="hljs-keyword">implicit</span> <span class="hljs-keyword">none</span><br><br>   <span class="hljs-keyword">integer</span> :: a(<span class="hljs-number">3</span>,<span class="hljs-number">5</span>), i , j<br>   <br>   <span class="hljs-keyword">do</span> i = <span class="hljs-number">1</span>,<span class="hljs-number">3</span><br>      <span class="hljs-keyword">do</span> j = <span class="hljs-number">1</span>, <span class="hljs-number">5</span>                <br>         a(i,j) = j-i          <br>      <span class="hljs-keyword">end</span> <span class="hljs-keyword">do</span> <br>   <span class="hljs-keyword">end</span> <span class="hljs-keyword">do</span><br>   <br>   <span class="hljs-built_in">Print</span> *, <span class="hljs-string">&#x27;The A array:&#x27;</span><br>   <br>   <span class="hljs-keyword">do</span> i = <span class="hljs-built_in">lbound</span>(a,<span class="hljs-number">1</span>), <span class="hljs-built_in">ubound</span>(a,<span class="hljs-number">1</span>)<br>      <span class="hljs-built_in">write</span>(*,*) (a(i,j), j = <span class="hljs-built_in">lbound</span>(a,<span class="hljs-number">2</span>), <span class="hljs-built_in">ubound</span>(a,<span class="hljs-number">2</span>))<br>   <span class="hljs-keyword">end</span> <span class="hljs-keyword">do</span><br>   <br>   <span class="hljs-keyword">where</span>( a&lt;<span class="hljs-number">0</span> ) <br>      a = <span class="hljs-number">1</span> <br>   <span class="hljs-keyword">elsewhere</span><br>      a = <span class="hljs-number">5</span><br>   <span class="hljs-keyword">end</span> <span class="hljs-keyword">where</span><br>  <br>   <span class="hljs-built_in">Print</span> *, <span class="hljs-string">&#x27;The A array:&#x27;</span><br>   <span class="hljs-keyword">do</span> i = <span class="hljs-built_in">lbound</span>(a,<span class="hljs-number">1</span>), <span class="hljs-built_in">ubound</span>(a,<span class="hljs-number">1</span>)<br>      <span class="hljs-built_in">write</span>(*,*) (a(i,j), j = <span class="hljs-built_in">lbound</span>(a,<span class="hljs-number">2</span>), <span class="hljs-built_in">ubound</span>(a,<span class="hljs-number">2</span>))<br>   <span class="hljs-keyword">end</span> <span class="hljs-keyword">do</span>   <br>   <br><span class="hljs-keyword">end</span> <span class="hljs-function"><span class="hljs-keyword">program</span></span> whereStatement<br></code></pre></td></tr></table></figure><p>​当上述代码被编译和执行时，它产生了以下结果：</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs fortran">The A array:<br><span class="hljs-number">0</span>   <span class="hljs-number">1</span>   <span class="hljs-number">2</span>  <span class="hljs-number">3</span>  <span class="hljs-number">4</span><br>-<span class="hljs-number">1</span>  <span class="hljs-number">0</span>   <span class="hljs-number">1</span>  <span class="hljs-number">2</span>  <span class="hljs-number">3</span><br>-<span class="hljs-number">2</span>  -<span class="hljs-number">1</span>  <span class="hljs-number">0</span>  <span class="hljs-number">1</span>  <span class="hljs-number">2</span><br>The A array:<br><span class="hljs-number">5</span>   <span class="hljs-number">5</span>   <span class="hljs-number">5</span>  <span class="hljs-number">5</span>  <span class="hljs-number">5</span><br><span class="hljs-number">1</span>   <span class="hljs-number">5</span>   <span class="hljs-number">5</span>  <span class="hljs-number">5</span>  <span class="hljs-number">5</span><br><span class="hljs-number">1</span>   <span class="hljs-number">1</span>   <span class="hljs-number">5</span>  <span class="hljs-number">5</span>  <span class="hljs-number">5</span><br></code></pre></td></tr></table></figure><h2 id="导出数据类型"><a href="#导出数据类型" class="headerlink" title="导出数据类型"></a>导出数据类型</h2><p>Fortran语言可以定义导出的数据类型。导出的数据类型也被称为一个结构，它可以包含不同类型的数据对象。</p><p>​导出的数据类型被用来代表一个记录。例如要跟踪在图书馆的书，可能希望跟踪的每本书有如下属性：</p><ul><li>​标题- Title</li><li>​作者 - Author</li><li>​科目 - Subject</li><li>​编号 - Book ID</li></ul><h2 id="定义一个导出的数据类型"><a href="#定义一个导出的数据类型" class="headerlink" title="定义一个导出的数据类型"></a>定义一个导出的数据类型</h2><p>​定义一个派生数据类型，类型和端类型的语句被使用。类型语句定义了一个新的数据类型，项目不止一个成员。类型声明的格式是这样的：</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs fortran"><span class="hljs-keyword">type</span> type_name      <br>   declarations<br><span class="hljs-keyword">end</span> <span class="hljs-keyword">type</span> <br></code></pre></td></tr></table></figure><p>​这里是会声明书的结构方式：</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs fortran"><span class="hljs-keyword">type</span> Books<br>   <span class="hljs-keyword">character</span>(len=<span class="hljs-number">50</span>) :: title<br>   <span class="hljs-keyword">character</span>(len=<span class="hljs-number">50</span>) :: author<br>   <span class="hljs-keyword">character</span>(len=<span class="hljs-number">150</span>) :: subject<br>   <span class="hljs-keyword">integer</span> :: book_id<br><span class="hljs-keyword">end</span> <span class="hljs-keyword">type</span> Books<br></code></pre></td></tr></table></figure><h2 id="访问结构成员"><a href="#访问结构成员" class="headerlink" title="访问结构成员"></a>访问结构成员</h2><p>​一个派生数据类型的对象被称为结构</p><p>​类型书籍(Books) 的结构像一个类型声明语句创建如下：</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs fortran"><span class="hljs-keyword">type</span>(Books) :: book1 <br></code></pre></td></tr></table></figure><p>​结构的组成部分可以使用该组件选择字符(%)进行访问 :</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs fortran">book1%title = <span class="hljs-string">&quot;C Programming&quot;</span><br>book1%author = <span class="hljs-string">&quot;Nuha Ali&quot;</span><br>book1%subject = <span class="hljs-string">&quot;C Programming Tutorial&quot;</span><br>book1%book_id = <span class="hljs-number">6495407</span><br></code></pre></td></tr></table></figure><p>​<strong>请注意，</strong>％符号前后没有空格。</p><p>​<strong>示例</strong></p><p>​下面的程序说明了上述概念：</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs fortran"><span class="hljs-function"><span class="hljs-keyword">program</span></span> deriveDataType<br><br>   <span class="hljs-comment">!type declaration</span><br>   <span class="hljs-keyword">type</span> Books<br>      <span class="hljs-keyword">character</span>(len=<span class="hljs-number">50</span>) :: title<br>      <span class="hljs-keyword">character</span>(len=<span class="hljs-number">50</span>) :: author<br>      <span class="hljs-keyword">character</span>(len=<span class="hljs-number">150</span>) :: subject<br>      <span class="hljs-keyword">integer</span> :: book_id<br>   <span class="hljs-keyword">end</span> <span class="hljs-keyword">type</span> Books<br>   <br>   <span class="hljs-comment">!declaring type variables</span><br>   <span class="hljs-keyword">type</span>(Books) :: book1 <br>   <span class="hljs-keyword">type</span>(Books) :: book2 <br>   <br>   <span class="hljs-comment">!accessing the components of the structure</span><br>   <br>   book1%title = <span class="hljs-string">&quot;C Programming&quot;</span><br>   book1%author = <span class="hljs-string">&quot;Nuha Ali&quot;</span><br>   book1%subject = <span class="hljs-string">&quot;C Programming Tutorial&quot;</span><br>   book1%book_id = <span class="hljs-number">6495407</span> <br>   <br>   book2%title = <span class="hljs-string">&quot;Telecom Billing&quot;</span><br>   book2%author = <span class="hljs-string">&quot;Zara Ali&quot;</span><br>   book2%subject = <span class="hljs-string">&quot;Telecom Billing Tutorial&quot;</span><br>   book2%book_id = <span class="hljs-number">6495700</span><br>  <br>   <span class="hljs-comment">!display book info</span><br>   <br>   <span class="hljs-built_in">Print</span> *, book1%title <br>   <span class="hljs-built_in">Print</span> *, book1%author <br>   <span class="hljs-built_in">Print</span> *, book1%subject <br>   <span class="hljs-built_in">Print</span> *, book1%book_id  <br>   <br>   <span class="hljs-built_in">Print</span> *, book2%title <br>   <span class="hljs-built_in">Print</span> *, book2%author <br>   <span class="hljs-built_in">Print</span> *, book2%subject <br>   <span class="hljs-built_in">Print</span> *, book2%book_id  <br><br><span class="hljs-keyword">end</span> <span class="hljs-function"><span class="hljs-keyword">program</span></span> deriveDataType<br></code></pre></td></tr></table></figure><p>​当上述代码被编译和执行时，它产生了以下结果：</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs fortran"><span class="hljs-comment">C Programming                                     </span><br>Nuha Ali                                          <br><span class="hljs-comment">C Programming Tutorial            </span><br>    <span class="hljs-number">6495407</span><br>Telecom Billing                                   <br>Zara Ali                                          <br>Telecom Billing Tutorial            <br>    <span class="hljs-number">6495700</span><br></code></pre></td></tr></table></figure><h2 id="结构数组"><a href="#结构数组" class="headerlink" title="结构数组"></a>结构数组</h2><p>​还可以创建一个派生类型的数组：</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs fortran"><span class="hljs-keyword">type</span>(Books), <span class="hljs-keyword">dimension</span>(<span class="hljs-number">2</span>) :: list<br></code></pre></td></tr></table></figure><p>​数组的单个元素，可以访问如下：</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs fortran">list(<span class="hljs-number">1</span>)%title = <span class="hljs-string">&quot;C Programming&quot;</span><br>list(<span class="hljs-number">1</span>)%author = <span class="hljs-string">&quot;Nuha Ali&quot;</span><br>list(<span class="hljs-number">1</span>)%subject = <span class="hljs-string">&quot;C Programming Tutorial&quot;</span><br>list(<span class="hljs-number">1</span>)%book_id = <span class="hljs-number">6495407</span><br></code></pre></td></tr></table></figure><p>​下面的程序说明了这个概念：</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs fortran"><span class="hljs-function"><span class="hljs-keyword">program</span></span> deriveDataType<br><br>   <span class="hljs-comment">!type declaration</span><br>   <span class="hljs-keyword">type</span> Books<br>      <span class="hljs-keyword">character</span>(len=<span class="hljs-number">50</span>) :: title<br>      <span class="hljs-keyword">character</span>(len=<span class="hljs-number">50</span>) :: author<br>      <span class="hljs-keyword">character</span>(len=<span class="hljs-number">150</span>) :: subject<br>      <span class="hljs-keyword">integer</span> :: book_id<br>   <span class="hljs-keyword">end</span> <span class="hljs-keyword">type</span> Books<br>   <br>   <span class="hljs-comment">!declaring array of books</span><br>   <span class="hljs-keyword">type</span>(Books), <span class="hljs-keyword">dimension</span>(<span class="hljs-number">2</span>) :: list <br>    <br>   <span class="hljs-comment">!accessing the components of the structure</span><br>   <br>   list(<span class="hljs-number">1</span>)%title = <span class="hljs-string">&quot;C Programming&quot;</span><br>   list(<span class="hljs-number">1</span>)%author = <span class="hljs-string">&quot;Nuha Ali&quot;</span><br>   list(<span class="hljs-number">1</span>)%subject = <span class="hljs-string">&quot;C Programming Tutorial&quot;</span><br>   list(<span class="hljs-number">1</span>)%book_id = <span class="hljs-number">6495407</span> <br>   <br>   list(<span class="hljs-number">2</span>)%title = <span class="hljs-string">&quot;Telecom Billing&quot;</span><br>   list(<span class="hljs-number">2</span>)%author = <span class="hljs-string">&quot;Zara Ali&quot;</span><br>   list(<span class="hljs-number">2</span>)%subject = <span class="hljs-string">&quot;Telecom Billing Tutorial&quot;</span><br>   list(<span class="hljs-number">2</span>)%book_id = <span class="hljs-number">6495700</span><br>  <br>   <span class="hljs-comment">!display book info</span><br>   <br>   <span class="hljs-built_in">Print</span> *, list(<span class="hljs-number">1</span>)%title <br>   <span class="hljs-built_in">Print</span> *, list(<span class="hljs-number">1</span>)%author <br>   <span class="hljs-built_in">Print</span> *, list(<span class="hljs-number">1</span>)%subject <br>   <span class="hljs-built_in">Print</span> *, list(<span class="hljs-number">1</span>)%book_id  <br>   <br>   <span class="hljs-built_in">Print</span> *, list(<span class="hljs-number">1</span>)%title <br>   <span class="hljs-built_in">Print</span> *, list(<span class="hljs-number">2</span>)%author <br>   <span class="hljs-built_in">Print</span> *, list(<span class="hljs-number">2</span>)%subject <br>   <span class="hljs-built_in">Print</span> *, list(<span class="hljs-number">2</span>)%book_id  <br><br><span class="hljs-keyword">end</span> <span class="hljs-function"><span class="hljs-keyword">program</span></span> deriveDataType<br></code></pre></td></tr></table></figure><p>​当上述代码被编译和执行时，它产生了以下结果：</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs fortran"><span class="hljs-comment">C Programming                                     </span><br>Nuha Ali                                          <br><span class="hljs-comment">C Programming Tutorial               </span><br>   <span class="hljs-number">6495407</span><br><span class="hljs-comment">C Programming                                     </span><br>Zara Ali                                          <br>Telecom Billing Tutorial                                      <br>   <span class="hljs-number">6495700</span><br></code></pre></td></tr></table></figure><h2 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h2><p>在大多数编程语言中，一个指针变量存储对象的内存地址。然而，在Fortran中，指针是具有不是仅仅存储存储器地址多功能性的数据对象。它包含有关特定对象的详细信息，如类型，等级，扩展和存储器地址。</p><p>​指针是通过分配或指针赋值的目标相关联。</p><h3 id="声明一个指针变量"><a href="#声明一个指针变量" class="headerlink" title="声明一个指针变量"></a>声明一个指针变量</h3><p>​一个指针变量与指针属性声明。</p><p>​下面的实施例示出了声明指针变量：</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs fortran"><span class="hljs-keyword">integer</span>, <span class="hljs-keyword">pointer</span> :: p1 <span class="hljs-comment">! pointer to integer  </span><br><span class="hljs-keyword">real</span>, <span class="hljs-keyword">pointer</span>, <span class="hljs-keyword">dimension</span> (:) :: pra <span class="hljs-comment">! pointer to 1-dim real array  </span><br><span class="hljs-keyword">real</span>, <span class="hljs-keyword">pointer</span>, <span class="hljs-keyword">dimension</span> (:,:) :: pra2 <span class="hljs-comment">! pointer to 2-dim real array</span><br></code></pre></td></tr></table></figure><p>​指针可以指向：</p><ul><li><p>​动态分配的内存区域</p></li><li><p>​数据对象与目标属性相同类型的指针</p><h3 id="分配指针的空间"><a href="#分配指针的空间" class="headerlink" title="分配指针的空间"></a>分配指针的空间</h3></li></ul><p>​allocate语句可以分配指针对象空间。例如：</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs fortran"><span class="hljs-function"><span class="hljs-keyword">program</span></span> pointerExample<br><span class="hljs-keyword">implicit</span> <span class="hljs-keyword">none</span><br><br>   <span class="hljs-keyword">integer</span>, <span class="hljs-keyword">pointer</span> :: p1<br>   <span class="hljs-built_in">allocate</span>(p1)<br>   <br>   p1 = <span class="hljs-number">1</span><br>   <span class="hljs-built_in">Print</span> *, p1<br>   <br>   p1 = p1 + <span class="hljs-number">4</span><br>   <span class="hljs-built_in">Print</span> *, p1<br>   <br><span class="hljs-keyword">end</span> <span class="hljs-function"><span class="hljs-keyword">program</span></span> pointerExample<br></code></pre></td></tr></table></figure><p>​当上述代码被编译和执行时，它产生了以下结果：</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs fortran"><span class="hljs-number">1</span><br><span class="hljs-number">5</span><br></code></pre></td></tr></table></figure><p>​应该解除分配语句清空该分配的存储空间当它不再需要，并避免未使用的和不可用的存储器空间的积累。</p><h3 id="目标和关联"><a href="#目标和关联" class="headerlink" title="目标和关联"></a>目标和关联</h3><p>​目标是另一个正态变量，空间预留给它。目标变量必须与目标属性进行声明。</p><p>​一个指针变量使用的关联操作符使目标变量相关联(&#x3D;&gt;)。</p><p>​让我们重写前面的例子中，以说明这个概念：</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs fortran"><span class="hljs-function"><span class="hljs-keyword">program</span></span> pointerExample<br><span class="hljs-keyword">implicit</span> <span class="hljs-keyword">none</span><br><br>   <span class="hljs-keyword">integer</span>, <span class="hljs-keyword">pointer</span> :: p1<br>   <span class="hljs-keyword">integer</span>, <span class="hljs-keyword">target</span> :: t1 <br>   <br>   p1=&gt;t1<br>   p1 = <span class="hljs-number">1</span><br>   <br>   <span class="hljs-built_in">Print</span> *, p1<br>   <span class="hljs-built_in">Print</span> *, t1<br>   <br>   p1 = p1 + <span class="hljs-number">4</span><br>   <br>   <span class="hljs-built_in">Print</span> *, p1<br>   <span class="hljs-built_in">Print</span> *, t1<br>   <br>   t1 = <span class="hljs-number">8</span><br>   <br>   <span class="hljs-built_in">Print</span> *, p1<br>   <span class="hljs-built_in">Print</span> *, t1<br>   <br><span class="hljs-keyword">end</span> <span class="hljs-function"><span class="hljs-keyword">program</span></span> pointerExample<br></code></pre></td></tr></table></figure><p>​当上述代码被编译和执行时，它产生了以下结果：</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs fortran"><span class="hljs-number">1</span><br><span class="hljs-number">1</span><br><span class="hljs-number">5</span><br><span class="hljs-number">5</span><br><span class="hljs-number">8</span><br><span class="hljs-number">8</span><br></code></pre></td></tr></table></figure><p>​指针可以是：</p><ul><li>​未定义的</li><li>​关联的</li><li>​未关联的</li></ul><p>​在上面的程序中，我们使用associated的指针p1与目标t1时，使用&#x3D;&gt;运算符。相关的函数，测试指针的关联状态。</p><p>​这个声明无效的关联从一个目标一个指针。</p><p>​无效非空目标，因为可能有多个指针指向同一个目标。然而空指针指也是无效的。</p><p>​示例 1</p><p>​下面的例子演示了概念：</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs fortran"><span class="hljs-function"><span class="hljs-keyword">program</span></span> pointerExample<br><span class="hljs-keyword">implicit</span> <span class="hljs-keyword">none</span><br><br>   <span class="hljs-keyword">integer</span>, <span class="hljs-keyword">pointer</span> :: p1<br>   <span class="hljs-keyword">integer</span>, <span class="hljs-keyword">target</span> :: t1 <br>   <span class="hljs-keyword">integer</span>, <span class="hljs-keyword">target</span> :: t2<br>   <br>   p1=&gt;t1<br>   p1 = <span class="hljs-number">1</span><br>   <br>   <span class="hljs-built_in">Print</span> *, p1<br>   <span class="hljs-built_in">Print</span> *, t1<br>   <br>   p1 = p1 + <span class="hljs-number">4</span><br>   <span class="hljs-built_in">Print</span> *, p1<br>   <span class="hljs-built_in">Print</span> *, t1<br>   <br>   t1 = <span class="hljs-number">8</span><br>   <span class="hljs-built_in">Print</span> *, p1<br>   <span class="hljs-built_in">Print</span> *, t1<br>   <br>   <span class="hljs-built_in">nullify</span>(p1)<br>   <span class="hljs-built_in">Print</span> *, t1<br>   <br>   p1=&gt;t2<br>   <span class="hljs-built_in">Print</span> *, <span class="hljs-built_in">associated</span>(p1)<br>   <span class="hljs-built_in">Print</span>*, <span class="hljs-built_in">associated</span>(p1, t1)<br>   <span class="hljs-built_in">Print</span>*, <span class="hljs-built_in">associated</span>(p1, t2)<br>   <br>   <span class="hljs-comment">!what is the value of p1 at present</span><br>   <span class="hljs-built_in">Print</span> *, p1<br>   <span class="hljs-built_in">Print</span> *, t2<br>   <br>   p1 = <span class="hljs-number">10</span><br>   <span class="hljs-built_in">Print</span> *, p1<br>   <span class="hljs-built_in">Print</span> *, t2<br>   <br><span class="hljs-keyword">end</span> <span class="hljs-function"><span class="hljs-keyword">program</span></span> pointerExample<br></code></pre></td></tr></table></figure><p>​当上述代码被编译和执行时，它产生了以下结果：</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs fortran"><span class="hljs-number">1</span><br><span class="hljs-number">1</span><br><span class="hljs-number">5</span><br><span class="hljs-number">5</span><br><span class="hljs-number">8</span><br><span class="hljs-number">8</span><br><span class="hljs-number">8</span><br>T<br>F<br>T<br><span class="hljs-number">952754640</span><br><span class="hljs-number">952754640</span><br><span class="hljs-number">10</span><br><span class="hljs-number">10</span><br></code></pre></td></tr></table></figure><p>​请注意，每次运行该代码时，内存地址会有所不同。</p><p>​<strong>示例 2</strong></p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs fortran"><span class="hljs-function"><span class="hljs-keyword">program</span></span> pointerExample<br><span class="hljs-keyword">implicit</span> <span class="hljs-keyword">none</span><br><br>   <span class="hljs-keyword">integer</span>, <span class="hljs-keyword">pointer</span> :: a, b<br>   <span class="hljs-keyword">integer</span>, <span class="hljs-keyword">target</span> :: t<br>   <span class="hljs-keyword">integer</span> :: n<br>   <br>   t= <span class="hljs-number">1</span><br>   a=&gt;t<br>   t = <span class="hljs-number">2</span><br>   b =&gt; t<br>   n = a + b<br>   <br>   <span class="hljs-built_in">Print</span> *, a, b, t, n <br>   <br><span class="hljs-keyword">end</span> <span class="hljs-function"><span class="hljs-keyword">program</span></span> pointerExample<br></code></pre></td></tr></table></figure><p>​当上述代码被编译和执行时，它产生了以下结果：</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs fortran"><span class="hljs-number">2</span>  <span class="hljs-number">2</span>  <span class="hljs-number">2</span>  <span class="hljs-number">4</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Fortran</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Fortran-函数</title>
    <link href="/2022/05/23/Fortran-%E5%87%BD%E6%95%B0/"/>
    <url>/2022/05/23/Fortran-%E5%87%BD%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="向量和矩阵乘法函数"><a href="#向量和矩阵乘法函数" class="headerlink" title="向量和矩阵乘法函数"></a>向量和矩阵乘法函数</h2><p><strong>下表描述了向量和矩阵乘法函数：</strong></p><table><thead><tr><th>函数</th><th>描述</th></tr></thead><tbody><tr><td><strong>dot_product</strong>(vector_a, vector_b)</td><td>函数返回两个输入向量，它必须具有相同长度的标量积。</td></tr><tr><td>**matmul **(matrix_a, matrix_b)</td><td>它返回两个矩阵的矩阵乘积，它必须是一致的，即具有相似大小 (m, k) 和 (k, n)</td></tr></tbody></table><p>​<strong>实例</strong></p><p>​下面的例子演示了内积：</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs fortran"><span class="hljs-function"><span class="hljs-keyword">program</span></span> arrayDotProduct<br><br>   <span class="hljs-keyword">real</span>, <span class="hljs-keyword">dimension</span>(<span class="hljs-number">5</span>) :: a, b<br>   <span class="hljs-keyword">integer</span>:: i, asize, bsize<br>   <br>   asize = <span class="hljs-built_in">size</span>(a)<br>   bsize = <span class="hljs-built_in">size</span>(b)<br>   <br>   <span class="hljs-keyword">do</span> i = <span class="hljs-number">1</span>, asize<br>      a(i) = i<br>   <span class="hljs-keyword">end</span> <span class="hljs-keyword">do</span><br>   <br>   <span class="hljs-keyword">do</span> i = <span class="hljs-number">1</span>, bsize<br>      b(i) = i*<span class="hljs-number">2</span><br>   <span class="hljs-keyword">end</span> <span class="hljs-keyword">do</span><br>   <br>   <span class="hljs-keyword">do</span> i = <span class="hljs-number">1</span>, asize<br>      <span class="hljs-built_in">Print</span> *, a(i)<br>   <span class="hljs-keyword">end</span> <span class="hljs-keyword">do</span><br>   <br>   <span class="hljs-keyword">do</span> i = <span class="hljs-number">1</span>, bsize<br>      <span class="hljs-built_in">Print</span> *, b(i)<br>   <span class="hljs-keyword">end</span> <span class="hljs-keyword">do</span><br>   <br>   <span class="hljs-built_in">Print</span>*, <span class="hljs-string">&#x27;Vector Multiplication: Dot Product:&#x27;</span><br>   <span class="hljs-built_in">Print</span>*, <span class="hljs-built_in">dot_product</span>(a, b)<br>   <br><span class="hljs-keyword">end</span> <span class="hljs-function"><span class="hljs-keyword">program</span></span> arrayDotProduct<br></code></pre></td></tr></table></figure><p>​当上述代码被编译和执行时，它产生了以下结果：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">1</span>.<span class="hljs-number">00000000</span>    <br><span class="hljs-attribute">2</span>.<span class="hljs-number">00000000</span>    <br><span class="hljs-attribute">3</span>.<span class="hljs-number">00000000</span>    <br><span class="hljs-attribute">4</span>.<span class="hljs-number">00000000</span>    <br><span class="hljs-attribute">5</span>.<span class="hljs-number">00000000</span>    <br><span class="hljs-attribute">2</span>.<span class="hljs-number">00000000</span>    <br><span class="hljs-attribute">4</span>.<span class="hljs-number">00000000</span>    <br><span class="hljs-attribute">6</span>.<span class="hljs-number">00000000</span>    <br><span class="hljs-attribute">8</span>.<span class="hljs-number">00000000</span>    <br><span class="hljs-attribute">10</span>.<span class="hljs-number">0000000</span>    <br><span class="hljs-attribute">Vector</span> Multiplication: Dot Product:<br><span class="hljs-attribute">110</span>.<span class="hljs-number">000000</span>   <br></code></pre></td></tr></table></figure><p>​<strong>实例</strong></p><p>​下面的例子演示了矩阵乘法：</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs fortran"><span class="hljs-function"><span class="hljs-keyword">program</span></span> matMulProduct<br><br>   <span class="hljs-keyword">integer</span>, <span class="hljs-keyword">dimension</span>(<span class="hljs-number">3</span>,<span class="hljs-number">3</span>) :: a, b, c<br>   <span class="hljs-keyword">integer</span> :: i, j<br>    <br>   <span class="hljs-keyword">do</span> i = <span class="hljs-number">1</span>, <span class="hljs-number">3</span><br>      <span class="hljs-keyword">do</span> j = <span class="hljs-number">1</span>, <span class="hljs-number">3</span><br>         a(i, j) = i+j<br>      <span class="hljs-keyword">end</span> <span class="hljs-keyword">do</span><br>   <span class="hljs-keyword">end</span> <span class="hljs-keyword">do</span><br>   <br>   <span class="hljs-built_in">print</span> *, <span class="hljs-string">&#x27;Matrix Multiplication: A Matrix&#x27;</span><br>   <br>   <span class="hljs-keyword">do</span> i = <span class="hljs-number">1</span>, <span class="hljs-number">3</span><br>      <span class="hljs-keyword">do</span> j = <span class="hljs-number">1</span>, <span class="hljs-number">3</span><br>         <span class="hljs-built_in">print</span>*, a(i, j)<br>      <span class="hljs-keyword">end</span> <span class="hljs-keyword">do</span><br>   <span class="hljs-keyword">end</span> <span class="hljs-keyword">do</span><br>   <br>   <span class="hljs-keyword">do</span> i = <span class="hljs-number">1</span>, <span class="hljs-number">3</span><br>      <span class="hljs-keyword">do</span> j = <span class="hljs-number">1</span>, <span class="hljs-number">3</span><br>         b(i, j) = i*j<br>      <span class="hljs-keyword">end</span> <span class="hljs-keyword">do</span><br>   <span class="hljs-keyword">end</span> <span class="hljs-keyword">do</span><br>   <br>   <span class="hljs-built_in">Print</span>*, <span class="hljs-string">&#x27;Matrix Multiplication: B Matrix&#x27;</span><br>   <br>   <span class="hljs-keyword">do</span> i = <span class="hljs-number">1</span>, <span class="hljs-number">3</span><br>      <span class="hljs-keyword">do</span> j = <span class="hljs-number">1</span>, <span class="hljs-number">3</span><br>         <span class="hljs-built_in">print</span>*, b(i, j)<br>      <span class="hljs-keyword">end</span> <span class="hljs-keyword">do</span><br>   <span class="hljs-keyword">end</span> <span class="hljs-keyword">do</span><br>   <br>   c = <span class="hljs-built_in">matmul</span>(a, b)<br>   <span class="hljs-built_in">Print</span>*, <span class="hljs-string">&#x27;Matrix Multiplication: Result Matrix&#x27;</span><br>   <br>   <span class="hljs-keyword">do</span> i = <span class="hljs-number">1</span>, <span class="hljs-number">3</span><br>      <span class="hljs-keyword">do</span> j = <span class="hljs-number">1</span>, <span class="hljs-number">3</span><br>         <span class="hljs-built_in">print</span>*, c(i, j)<br>      <span class="hljs-keyword">end</span> <span class="hljs-keyword">do</span><br>   <span class="hljs-keyword">end</span> <span class="hljs-keyword">do</span><br>   <br><span class="hljs-keyword">end</span> <span class="hljs-function"><span class="hljs-keyword">program</span></span> matMulProduct<br></code></pre></td></tr></table></figure><p>​当上述代码被编译和执行时，它产生了以下结果：</p><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs gauss"><span class="hljs-keyword">Matrix</span> Multiplication: A <span class="hljs-keyword">Matrix</span><br><span class="hljs-number">2</span><br><span class="hljs-number">3</span><br><span class="hljs-number">4</span><br><span class="hljs-number">3</span><br><span class="hljs-number">4</span><br><span class="hljs-number">5</span><br><span class="hljs-number">4</span><br><span class="hljs-number">5</span><br><span class="hljs-number">6</span><br> <span class="hljs-keyword">Matrix</span> Multiplication: B <span class="hljs-keyword">Matrix</span><br><span class="hljs-number">1</span><br><span class="hljs-number">2</span><br><span class="hljs-number">3</span><br><span class="hljs-number">2</span><br><span class="hljs-number">4</span><br><span class="hljs-number">6</span><br><span class="hljs-number">3</span><br><span class="hljs-number">6</span><br><span class="hljs-number">9</span><br><span class="hljs-keyword">Matrix</span> Multiplication: Result <span class="hljs-keyword">Matrix</span><br><span class="hljs-number">20</span><br><span class="hljs-number">40</span><br><span class="hljs-number">60</span><br><span class="hljs-number">26</span><br><span class="hljs-number">52</span><br><span class="hljs-number">78</span><br><span class="hljs-number">32</span><br><span class="hljs-number">64</span><br><span class="hljs-number">96</span><br></code></pre></td></tr></table></figure><h2 id="还原函数"><a href="#还原函数" class="headerlink" title="还原函数"></a>还原函数</h2><p><strong>下表描述了还原功能</strong>：</p><table><thead><tr><th>函数</th><th>描述</th></tr></thead><tbody><tr><td><strong>all</strong>(mask, dim)</td><td>它返回一个逻辑值，指明掩码的所有关系是 .true。以及只有所需的维度，如果第二个参数是给定的。</td></tr><tr><td><strong>any</strong>(mask, dim)</td><td>它返回一个逻辑值，指明掩码的任何关系是.true。以及只有所需的维度，如果第二个参数是给定的。</td></tr><tr><td><strong>count</strong>(mask, dim)</td><td>它返回一个数字值，该值为掩码为 .true 关系的数目。以及所需的维数，如果第二个参数给出。</td></tr><tr><td><strong>maxval</strong>(array, dim, mask)</td><td>它返回 的数组的数组中最大的值，那些遵守于第三个参数掩码的关系，如果一个给定的，以及具有只有所需的维数，如果第二个参数 dim给出的。</td></tr><tr><td><strong>minval</strong>(array, dim, mask)</td><td>它返回数组的数组中那些遵守于第三个参数掩码的关系的最小值，如果一个给定的，以及具有仅在第二个参数 dim 给出所期望的维度。</td></tr><tr><td><strong>product</strong>(array, dim, mask)</td><td>它返回该产品遵守于第三个参数掩码的关系，如果一个给定的，以及具有只有所需的维数，如果第二个参数 dim 给出的所有数组的数组中的元素，。</td></tr><tr><td>**sum **(array, dim, mask)</td><td>它返回 遵守于第三个参数掩码关系的总和，如果给定以及具有只有所需的维数，如果第二个参数 dim给出的所有数组的数组中的元素。</td></tr></tbody></table><p>​例子</p><p>​下面的例子演示了这一概念：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">program</span> arrayReduction<br><br>   <span class="hljs-attribute">real</span>, dimension(<span class="hljs-number">3</span>,<span class="hljs-number">2</span>) :: a <br>   <span class="hljs-attribute">a</span> = reshape( (/<span class="hljs-number">5</span>,<span class="hljs-number">9</span>,<span class="hljs-number">6</span>,<span class="hljs-number">10</span>,<span class="hljs-number">8</span>,<span class="hljs-number">12</span>/), (/<span class="hljs-number">3</span>,<span class="hljs-number">2</span>/) ) <br>   <br>   <span class="hljs-attribute">Print</span> *, <span class="hljs-literal">all</span>(a&gt;<span class="hljs-number">5</span>)<br>   <span class="hljs-attribute">Print</span> *, any(a&gt;<span class="hljs-number">5</span>)<br>   <span class="hljs-attribute">Print</span> *, count(a&gt;<span class="hljs-number">5</span>)<br>   <span class="hljs-attribute">Print</span> *, <span class="hljs-literal">all</span>(a&gt;=<span class="hljs-number">5</span> .and. a&lt;<span class="hljs-number">10</span>)<br>  <br><span class="hljs-attribute">end</span> program arrayReduction<br></code></pre></td></tr></table></figure><p>​当上述代码被编译和执行时，它产生了以下结果：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs r"><span class="hljs-built_in">F</span><br><span class="hljs-built_in">T</span><br><span class="hljs-number">5</span><br><span class="hljs-built_in">F</span><br></code></pre></td></tr></table></figure><p>​<strong>实例</strong></p><p>​下面的例子演示了这一概念：</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs fortran"><span class="hljs-function"><span class="hljs-keyword">program</span></span> arrayReduction<br><span class="hljs-keyword">implicit</span> <span class="hljs-keyword">none</span><br><br>   <span class="hljs-keyword">real</span>, <span class="hljs-keyword">dimension</span>(<span class="hljs-number">1</span>:<span class="hljs-number">6</span>) :: a = (/ <span class="hljs-number">21.0</span>, <span class="hljs-number">12.0</span>,<span class="hljs-number">33.0</span>, <span class="hljs-number">24.0</span>, <span class="hljs-number">15.0</span>, <span class="hljs-number">16.0</span> /)<br>   <span class="hljs-built_in">Print</span> *, <span class="hljs-built_in">maxval</span>(a)<br>   <span class="hljs-built_in">Print</span> *, <span class="hljs-built_in">minval</span>(a)<br>   <span class="hljs-built_in">Print</span> *, <span class="hljs-built_in">sum</span>(a)<br>   <span class="hljs-built_in">Print</span> *, <span class="hljs-built_in">product</span>(a)<br>   <br><span class="hljs-keyword">end</span> <span class="hljs-function"><span class="hljs-keyword">program</span></span> arrayReduction <br></code></pre></td></tr></table></figure><p>​当上述代码被编译和执行时，它产生了以下结果：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">33</span>.<span class="hljs-number">0000000</span>    <br><span class="hljs-attribute">12</span>.<span class="hljs-number">0000000</span>    <br><span class="hljs-attribute">121</span>.<span class="hljs-number">000000</span>    <br><span class="hljs-attribute">47900160</span>.<span class="hljs-number">0</span> <br></code></pre></td></tr></table></figure><h2 id="查询函数"><a href="#查询函数" class="headerlink" title="查询函数"></a>查询函数</h2><p>下表描述了查询功能：</p><table><thead><tr><th>函数</th><th>描述</th></tr></thead><tbody><tr><td><strong>allocated</strong>(array)</td><td>它是一个逻辑功能，它指示该阵列被分配。</td></tr><tr><td><strong>lbound</strong>(array, dim)</td><td>它返回的数组的维数较低的限制。如果dim(尺寸)不给出一个参数，会得到一个整数向量，如果dim计算在内，得到的整数值正好具有较低维数的限制。</td></tr><tr><td><strong>shape</strong>(source)</td><td>它返回一个阵列源为一个整数向量的形状。</td></tr><tr><td><strong>size</strong>(array, dim)</td><td>它返回在数组元素的数目。如果dim没有给出，并在相关维数的元素个数，如果dim也包括在内。</td></tr><tr><td><strong>ubound</strong>(array, dim)</td><td>它返回尺寸的限制。</td></tr></tbody></table><p>​例子</p><p>​下面的例子演示了这一概念：</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs fortran"><span class="hljs-function"><span class="hljs-keyword">program</span></span> arrayInquiry<br><br>   <span class="hljs-keyword">real</span>, <span class="hljs-keyword">dimension</span>(<span class="hljs-number">3</span>,<span class="hljs-number">2</span>) :: a <br>   a = <span class="hljs-built_in">reshape</span>( (/<span class="hljs-number">5</span>,<span class="hljs-number">9</span>,<span class="hljs-number">6</span>,<span class="hljs-number">10</span>,<span class="hljs-number">8</span>,<span class="hljs-number">12</span>/), (/<span class="hljs-number">3</span>,<span class="hljs-number">2</span>/) ) <br>   <br>   <span class="hljs-built_in">Print</span> *, <span class="hljs-built_in">lbound</span>(a, <span class="hljs-built_in">dim</span>=<span class="hljs-number">1</span>)<br>   <span class="hljs-built_in">Print</span> *, <span class="hljs-built_in">ubound</span>(a, <span class="hljs-built_in">dim</span>=<span class="hljs-number">1</span>)<br>   <span class="hljs-built_in">Print</span> *, <span class="hljs-built_in">shape</span>(a)<br>   <span class="hljs-built_in">Print</span> *, <span class="hljs-built_in">size</span>(a,<span class="hljs-built_in">dim</span>=<span class="hljs-number">1</span>)<br>   <br><span class="hljs-keyword">end</span> <span class="hljs-function"><span class="hljs-keyword">program</span></span> arrayInquiry<br></code></pre></td></tr></table></figure><p>​当上述代码被编译和执行时，它产生了以下结果：</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-number">1</span><br><span class="hljs-number">3</span><br><span class="hljs-symbol">3 </span><span class="hljs-number">2</span><br><span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><p>下表介绍了结构功能：</p><table><thead><tr><th>函数</th><th>描述</th></tr></thead><tbody><tr><td><strong>merge</strong>(tsource, fsource, mask)</td><td>该功能连接两个阵列。它给出了tsource及元素，如果mask条件是.true。如果掩码的条件是.false。这两个字段tsource 和fsource 必须是相同的类型并具有相同的形状。其结果也就是这种类型和形状。还掩码必须具有相同的形状。</td></tr><tr><td><strong>pack</strong>(array, mask, vector)</td><td>它包一个阵列，以使用掩码的控制向量。逻辑阵列掩模的形状，具有以符合一个用于阵列，要不然掩码必须是一个标量。如果载体被包括在内，它必须是秩1与至少一样多的元素是在掩码为真，并且具有相同的类型的数组的数组(即一个向量)。如果掩码的值为.true。然后矢量代替必须的元件阵列的数量相同。</td></tr><tr><td><strong>spread</strong>(source, dim, ncopies)</td><td>它返回相同类型作为参数源与秩增加一个阵列。参数dim 和ncopies都是整数。如果ncopies是负则用零值来代替。如果source是一个标量，然后扩散变得所有具有相同值 ncopies 元素的向量。参数dim 指示哪个索引将被延长。它必须是范围为1和1+(源级)中，如果 source 是一个标量，dim 必须是1。参数 ncopies 是在新的尺寸元素的数量。</td></tr><tr><td><strong>unpack</strong>(vector, mask, array)</td><td>它散射一个载体，掩码下的控制阵列。逻辑阵列掩模的形状具有以符合一个用于数组。阵列载体必须具有等级1(即它是一个向量)与至少一样多的元素是那些掩码内值都为true，并且还必须具有相同类型阵列。如果阵列被给定为一个标量，然后它被认为是使用相同形状的掩码，并在同一标量元素无处不在的阵列。  其结果将是具有相同形状的掩码和类型相同的矢量阵列。该值将是那些从所接受的载体，而在阵列的剩余位置的旧值被保留。</td></tr></tbody></table><p>​<strong>示例</strong></p><p>​下面的例子演示了这一概念：</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs fortran"><span class="hljs-function"><span class="hljs-keyword">program</span></span> arrayConstruction<br><span class="hljs-keyword">implicit</span> <span class="hljs-keyword">none</span><br>   <span class="hljs-keyword">interface</span><br>      <span class="hljs-function"><span class="hljs-keyword">subroutine</span></span> write_array (a)<br>         <span class="hljs-keyword">real</span> :: a(:,:)<br>      <span class="hljs-keyword">end</span> <span class="hljs-function"><span class="hljs-keyword">subroutine</span></span> write_array<br>      <br>      <span class="hljs-function"><span class="hljs-keyword">subroutine</span></span> write_l_array (a)<br>         <span class="hljs-keyword">logical</span> :: a(:,:)<br>      <span class="hljs-keyword">end</span> <span class="hljs-function"><span class="hljs-keyword">subroutine</span></span> write_l_array<br>   <span class="hljs-keyword">end</span> <span class="hljs-keyword">interface</span><br><br>   <span class="hljs-keyword">real</span>, <span class="hljs-keyword">dimension</span>(<span class="hljs-number">2</span>,<span class="hljs-number">3</span>) :: tsource, fsource, result<br>   <span class="hljs-keyword">logical</span>, <span class="hljs-keyword">dimension</span>(<span class="hljs-number">2</span>,<span class="hljs-number">3</span>) :: mask<br>   <br>   tsource = <span class="hljs-built_in">reshape</span>( (/ <span class="hljs-number">35</span>, <span class="hljs-number">23</span>, <span class="hljs-number">18</span>, <span class="hljs-number">28</span>, <span class="hljs-number">26</span>, <span class="hljs-number">39</span> /), &amp;<br>                    (/ <span class="hljs-number">2</span>, <span class="hljs-number">3</span> /) )<br>   fsource = <span class="hljs-built_in">reshape</span>( (/ -<span class="hljs-number">35</span>, -<span class="hljs-number">23</span>, -<span class="hljs-number">18</span>, -<span class="hljs-number">28</span>, -<span class="hljs-number">26</span>, -<span class="hljs-number">39</span> /), &amp;<br>                    (/ <span class="hljs-number">2</span>,<span class="hljs-number">3</span> /) )<br>   mask = <span class="hljs-built_in">reshape</span>( (/ .true., .false., .false., .true., &amp;<br>                 .false., .false. /), (/ <span class="hljs-number">2</span>,<span class="hljs-number">3</span> /) )<br><br>   result = <span class="hljs-built_in">merge</span>(tsource, fsource, mask)<br>   <span class="hljs-keyword">call</span> write_array(tsource)<br>   <span class="hljs-keyword">call</span> write_array(fsource)<br>   <span class="hljs-keyword">call</span> write_l_array(mask)<br>   <span class="hljs-keyword">call</span> write_array(result)<br>   <br><span class="hljs-keyword">end</span> <span class="hljs-function"><span class="hljs-keyword">program</span></span> arrayConstruction<br><br><br><br><span class="hljs-function"><span class="hljs-keyword">subroutine</span></span> write_array (a)<br><br>   <span class="hljs-keyword">real</span> :: a(:,:)<br>   <span class="hljs-keyword">do</span> i = <span class="hljs-built_in">lbound</span>(a,<span class="hljs-number">1</span>), <span class="hljs-built_in">ubound</span>(a,<span class="hljs-number">1</span>)<br>      <span class="hljs-built_in">write</span>(*,*) (a(i, j), j = <span class="hljs-built_in">lbound</span>(a,<span class="hljs-number">2</span>), <span class="hljs-built_in">ubound</span>(a,<span class="hljs-number">2</span>) )<br>   <span class="hljs-keyword">end</span> <span class="hljs-keyword">do</span><br>   <span class="hljs-keyword">return</span><br>   <br><span class="hljs-keyword">end</span> <span class="hljs-function"><span class="hljs-keyword">subroutine</span></span> write_array<br><br><br><span class="hljs-function"><span class="hljs-keyword">subroutine</span></span> write_l_array (a)<br><br>   <span class="hljs-keyword">logical</span> :: a(:,:)<br>   <span class="hljs-keyword">do</span> i = <span class="hljs-built_in">lbound</span>(a,<span class="hljs-number">1</span>), <span class="hljs-built_in">ubound</span>(a,<span class="hljs-number">1</span>)<br>      <span class="hljs-built_in">write</span>(*,*) (a(i, j), j= <span class="hljs-built_in">lbound</span>(a,<span class="hljs-number">2</span>), <span class="hljs-built_in">ubound</span>(a,<span class="hljs-number">2</span>))<br>   <span class="hljs-keyword">end</span> <span class="hljs-keyword">do</span><br>   <span class="hljs-keyword">return</span><br>   <br><span class="hljs-keyword">end</span> <span class="hljs-function"><span class="hljs-keyword">subroutine</span></span> write_l_array<br></code></pre></td></tr></table></figure><p>​当上述代码被编译和执行时，它产生了以下结果：</p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs dns"><span class="hljs-number">35.0000000</span>   <span class="hljs-number">18.0000000</span>   <span class="hljs-number">26.0000000</span>    <br><span class="hljs-number">23.0000000</span>   <span class="hljs-number">28.0000000</span>   <span class="hljs-number">39.0000000</span>    <br>-<span class="hljs-number">35.0000000</span>  -<span class="hljs-number">18.0000000</span>  -<span class="hljs-number">26.0000000</span>    <br>-<span class="hljs-number">23.0000000</span>  -<span class="hljs-number">28.0000000</span>  -<span class="hljs-number">39.0000000</span>    <br>T F F<br>F T F<br><span class="hljs-number">35.0000000</span>   -<span class="hljs-number">18.0000000</span>  -<span class="hljs-number">26.0000000</span>    <br></code></pre></td></tr></table></figure><h2 id="重塑函数"><a href="#重塑函数" class="headerlink" title="重塑函数"></a>重塑函数</h2><p>下表描述了重塑函数：</p><table><thead><tr><th>函数</th><th>描述</th></tr></thead><tbody><tr><td><strong>reshape</strong>(source, shape, pad, order)</td><td>它构造一个特定形状的形状，从一个给定source阵列中的元素开始的数组。如果垫不包含则soure的尺寸必须至少为产物(形状)。如果pad包括在内，它必须具有相同的类型的soure。如果order被包括，它必须使用相同的形状的形状的整数数组，值必须是一个排列(1,2,3，…，n)，其中n是在形状要素的数量，它必须小于或等于7。</td></tr></tbody></table><p>​<strong>示例</strong></p><p>​下面的例子演示了这一概念：</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs fortran"><span class="hljs-function"><span class="hljs-keyword">program</span></span> arrayReshape<br><span class="hljs-keyword">implicit</span> <span class="hljs-keyword">none</span><br><br><span class="hljs-keyword">interface</span><br>   <span class="hljs-function"><span class="hljs-keyword">subroutine</span></span> write_matrix(a)<br>   <span class="hljs-keyword">real</span>, <span class="hljs-keyword">dimension</span>(:,:) :: a<br>   <span class="hljs-keyword">end</span> <span class="hljs-function"><span class="hljs-keyword">subroutine</span></span> write_matrix<br>   <span class="hljs-keyword">end</span> <span class="hljs-keyword">interface</span><br><br>   <span class="hljs-keyword">real</span>, <span class="hljs-keyword">dimension</span> (<span class="hljs-number">1</span>:<span class="hljs-number">9</span>) :: b = (/ <span class="hljs-number">21</span>, <span class="hljs-number">22</span>, <span class="hljs-number">23</span>, <span class="hljs-number">24</span>, <span class="hljs-number">25</span>, <span class="hljs-number">26</span>, <span class="hljs-number">27</span>, <span class="hljs-number">28</span>, <span class="hljs-number">29</span> /)<br>   <span class="hljs-keyword">real</span>, <span class="hljs-keyword">dimension</span> (<span class="hljs-number">1</span>:<span class="hljs-number">3</span>, <span class="hljs-number">1</span>:<span class="hljs-number">3</span>) :: c, d, e<br>   <span class="hljs-keyword">real</span>, <span class="hljs-keyword">dimension</span> (<span class="hljs-number">1</span>:<span class="hljs-number">4</span>, <span class="hljs-number">1</span>:<span class="hljs-number">4</span>) :: f, g, h<br><br>   <span class="hljs-keyword">integer</span>, <span class="hljs-keyword">dimension</span> (<span class="hljs-number">1</span>:<span class="hljs-number">2</span>) :: order1 = (/ <span class="hljs-number">1</span>, <span class="hljs-number">2</span> /)<br>   <span class="hljs-keyword">integer</span>, <span class="hljs-keyword">dimension</span> (<span class="hljs-number">1</span>:<span class="hljs-number">2</span>) :: order2 = (/ <span class="hljs-number">2</span>, <span class="hljs-number">1</span> /)<br>   <span class="hljs-keyword">real</span>, <span class="hljs-keyword">dimension</span> (<span class="hljs-number">1</span>:<span class="hljs-number">16</span>) :: pad1 = (/ -<span class="hljs-number">1</span>, -<span class="hljs-number">2</span>, -<span class="hljs-number">3</span>, -<span class="hljs-number">4</span>, -<span class="hljs-number">5</span>, -<span class="hljs-number">6</span>, -<span class="hljs-number">7</span>, -<span class="hljs-number">8</span>, &amp;<br>                                 &amp; -<span class="hljs-number">9</span>, -<span class="hljs-number">10</span>, -<span class="hljs-number">11</span>, -<span class="hljs-number">12</span>, -<span class="hljs-number">13</span>, -<span class="hljs-number">14</span>, -<span class="hljs-number">15</span>, -<span class="hljs-number">16</span> /)<br><br>   c = <span class="hljs-built_in">reshape</span>( b, (/ <span class="hljs-number">3</span>, <span class="hljs-number">3</span> /) )<br>   <span class="hljs-keyword">call</span> write_matrix(c)<br><br>   d = <span class="hljs-built_in">reshape</span>( b, (/ <span class="hljs-number">3</span>, <span class="hljs-number">3</span> /), order = order1)<br>   <span class="hljs-keyword">call</span> write_matrix(d)<br><br>   e = <span class="hljs-built_in">reshape</span>( b, (/ <span class="hljs-number">3</span>, <span class="hljs-number">3</span> /), order = order2)<br>   <span class="hljs-keyword">call</span> write_matrix(e)<br><br>   f = <span class="hljs-built_in">reshape</span>( b, (/ <span class="hljs-number">4</span>, <span class="hljs-number">4</span> /), <span class="hljs-keyword">pad</span> = pad1)<br>   <span class="hljs-keyword">call</span> write_matrix(f)<br><br>   g = <span class="hljs-built_in">reshape</span>( b, (/ <span class="hljs-number">4</span>, <span class="hljs-number">4</span> /), <span class="hljs-keyword">pad</span> = pad1, order = order1)<br>   <span class="hljs-keyword">call</span> write_matrix(g)<br><br>   h = <span class="hljs-built_in">reshape</span>( b, (/ <span class="hljs-number">4</span>, <span class="hljs-number">4</span> /), <span class="hljs-keyword">pad</span> = pad1, order = order2)<br>   <span class="hljs-keyword">call</span> write_matrix(h)<br><br><span class="hljs-keyword">end</span> <span class="hljs-function"><span class="hljs-keyword">program</span></span> arrayReshape<br><br><br><span class="hljs-function"><span class="hljs-keyword">subroutine</span></span> write_matrix(a)<br>   <span class="hljs-keyword">real</span>, <span class="hljs-keyword">dimension</span>(:,:) :: a<br>   <span class="hljs-built_in">write</span>(*,*)<br>   <br>   <span class="hljs-keyword">do</span> i = <span class="hljs-built_in">lbound</span>(a,<span class="hljs-number">1</span>), <span class="hljs-built_in">ubound</span>(a,<span class="hljs-number">1</span>)<br>      <span class="hljs-built_in">write</span>(*,*) (a(i,j), j = <span class="hljs-built_in">lbound</span>(a,<span class="hljs-number">2</span>), <span class="hljs-built_in">ubound</span>(a,<span class="hljs-number">2</span>))<br>   <span class="hljs-keyword">end</span> <span class="hljs-keyword">do</span><br><span class="hljs-keyword">end</span> <span class="hljs-function"><span class="hljs-keyword">subroutine</span></span> write_matrix<br></code></pre></td></tr></table></figure><p>​当上述代码被编译和执行时，它产生了以下结果：</p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs dns"><span class="hljs-number">21.0000000</span>  <span class="hljs-number">24.0000000</span>  <span class="hljs-number">27.0000000</span>    <br><span class="hljs-number">22.0000000</span>  <span class="hljs-number">25.0000000</span>  <span class="hljs-number">28.0000000</span>    <br><span class="hljs-number">23.0000000</span>  <span class="hljs-number">26.0000000</span>  <span class="hljs-number">29.0000000</span>    <br><br><span class="hljs-number">21.0000000</span>  <span class="hljs-number">24.0000000</span>  <span class="hljs-number">27.0000000</span>    <br><span class="hljs-number">22.0000000</span>  <span class="hljs-number">25.0000000</span>  <span class="hljs-number">28.0000000</span>    <br><span class="hljs-number">23.0000000</span>  <span class="hljs-number">26.0000000</span>  <span class="hljs-number">29.0000000</span>    <br><br><span class="hljs-number">21.0000000</span>  <span class="hljs-number">22.0000000</span>  <span class="hljs-number">23.0000000</span>    <br><span class="hljs-number">24.0000000</span>  <span class="hljs-number">25.0000000</span>  <span class="hljs-number">26.0000000</span>    <br><span class="hljs-number">27.0000000</span>  <span class="hljs-number">28.0000000</span>  <span class="hljs-number">29.0000000</span>    <br><br><span class="hljs-number">21.0000000</span>  <span class="hljs-number">25.0000000</span>  <span class="hljs-number">29.0000000</span>   -<span class="hljs-number">4.00000000</span>    <br><span class="hljs-number">22.0000000</span>  <span class="hljs-number">26.0000000</span>  -<span class="hljs-number">1.00000000</span>  -<span class="hljs-number">5.00000000</span>    <br><span class="hljs-number">23.0000000</span>  <span class="hljs-number">27.0000000</span>  -<span class="hljs-number">2.00000000</span>  -<span class="hljs-number">6.00000000</span>    <br><span class="hljs-number">24.0000000</span>  <span class="hljs-number">28.0000000</span>  -<span class="hljs-number">3.00000000</span>  -<span class="hljs-number">7.00000000</span>    <br><br><span class="hljs-number">21.0000000</span>  <span class="hljs-number">25.0000000</span>  <span class="hljs-number">29.0000000</span>   -<span class="hljs-number">4.00000000</span>    <br><span class="hljs-number">22.0000000</span>  <span class="hljs-number">26.0000000</span>  -<span class="hljs-number">1.00000000</span>  -<span class="hljs-number">5.00000000</span>    <br><span class="hljs-number">23.0000000</span>  <span class="hljs-number">27.0000000</span>  -<span class="hljs-number">2.00000000</span>  -<span class="hljs-number">6.00000000</span>    <br><span class="hljs-number">24.0000000</span>  <span class="hljs-number">28.0000000</span>  -<span class="hljs-number">3.00000000</span>  -<span class="hljs-number">7.00000000</span>    <br><br><span class="hljs-number">21.0000000</span>  <span class="hljs-number">22.0000000</span>  <span class="hljs-number">23.0000000</span>   <span class="hljs-number">24.0000000</span>    <br><span class="hljs-number">25.0000000</span>  <span class="hljs-number">26.0000000</span>  <span class="hljs-number">27.0000000</span>   <span class="hljs-number">28.0000000</span>    <br><span class="hljs-number">29.0000000</span>  -<span class="hljs-number">1.00000000</span> -<span class="hljs-number">2.00000000</span>  -<span class="hljs-number">3.00000000</span>    <br>-<span class="hljs-number">4.00000000</span> -<span class="hljs-number">5.00000000</span> -<span class="hljs-number">6.00000000</span>  -<span class="hljs-number">7.00000000</span>  <br></code></pre></td></tr></table></figure><h2 id="操作函数"><a href="#操作函数" class="headerlink" title="操作函数"></a>操作函数</h2><p>处理函数平移功能。移位函数返回一个数组不变的形状，但移动元素。</p><table><thead><tr><th>函数</th><th>描述</th></tr></thead><tbody><tr><td><strong>cshift</strong>(array, shift, dim)</td><td>它执行循环移位由移位置的左边，如果移位是正和到右侧，如果它是负的。如果阵列是一个矢量移位正在做以自然的方式中，如果它是一个较高级的阵列则移是沿着维数dim的所有部分。若dim缺少它被认为是1，在其它情况下它必须是1和n(其中n等于阵列的等级)之间的标量整数。该参数换档是一个标量整数或秩n-1个整数的数组和形状相同的阵列中，除沿维数dim(在较低级的，因为它被移除)。不同的部分，因此可以转移在各个方向上，并与各种数目的位置。</td></tr><tr><td><strong>eoshift</strong>(array, shift, boundary, dim)</td><td>这是端关闭的转变。它执行向左移动，如果移位是正和到右侧，如果它是负的。相反的元素移出新元素均取自边界。如果阵列是一个矢量移位正在做以自然的方式中，如果它是一个较高级的阵列，在所有各节中的移位是以及该维度暗淡。若 dim 丢失，它被认为是1，但在其它情况下，它为1和n(其中n等于阵列的秩)之间有一个标量的整数值。该参数换档是一个标量整数，如果阵列具有秩1，在其他情况下，它可以是一个标量整数或秩n-1和形状相同的阵列排列的与除沿维数dim 的整数数组(其被取出因为较低级的)。</td></tr><tr><td>**transpose **(matrix)</td><td>其转置矩阵，这是秩2的阵列它取代了的行和列矩阵。</td></tr></tbody></table><p>​<strong>示例</strong></p><p>​下面的例子演示了这一概念：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">program</span> arrayShift<br><span class="hljs-attribute">implicit</span> none<br><br>   <span class="hljs-attribute">real</span>, dimension(<span class="hljs-number">1</span>:<span class="hljs-number">6</span>) :: a = (/ <span class="hljs-number">21</span>.<span class="hljs-number">0</span>, <span class="hljs-number">22</span>.<span class="hljs-number">0</span>, <span class="hljs-number">23</span>.<span class="hljs-number">0</span>, <span class="hljs-number">24</span>.<span class="hljs-number">0</span>, <span class="hljs-number">25</span>.<span class="hljs-number">0</span>, <span class="hljs-number">26</span>.<span class="hljs-number">0</span> /)<br>   <span class="hljs-attribute">real</span>, dimension(<span class="hljs-number">1</span>:<span class="hljs-number">6</span>) :: x, y<br>   <span class="hljs-attribute">write</span>(*,<span class="hljs-number">10</span>) a<br>   <br>   <span class="hljs-attribute">x</span> = cshift ( a, shift = <span class="hljs-number">2</span>)<br>   <span class="hljs-attribute">write</span>(*,<span class="hljs-number">10</span>) x<br>   <br>   <span class="hljs-attribute">y</span> = cshift (a, shift = -<span class="hljs-number">2</span>)<br>   <span class="hljs-attribute">write</span>(*,<span class="hljs-number">10</span>) y<br>   <br>   <span class="hljs-attribute">x</span> = eoshift ( a, shift = <span class="hljs-number">2</span>)<br>   <span class="hljs-attribute">write</span>(*,<span class="hljs-number">10</span>) x<br>   <br>   <span class="hljs-attribute">y</span> = eoshift ( a, shift = -<span class="hljs-number">2</span>)<br>   <span class="hljs-attribute">write</span>(*,<span class="hljs-number">10</span>) y<br>   <br>   <span class="hljs-attribute">10</span> format(<span class="hljs-number">1</span>x,<span class="hljs-number">6</span>f6.<span class="hljs-number">1</span>)<br><br><span class="hljs-attribute">end</span> program arrayShift<br></code></pre></td></tr></table></figure><p>​当上述代码被编译和执行时，它产生了以下结果：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">21</span>.<span class="hljs-number">0</span>  <span class="hljs-number">22</span>.<span class="hljs-number">0</span>  <span class="hljs-number">23</span>.<span class="hljs-number">0</span>  <span class="hljs-number">24</span>.<span class="hljs-number">0</span>  <span class="hljs-number">25</span>.<span class="hljs-number">0</span>  <span class="hljs-number">26</span>.<span class="hljs-number">0</span><br><span class="hljs-attribute">23</span>.<span class="hljs-number">0</span>  <span class="hljs-number">24</span>.<span class="hljs-number">0</span>  <span class="hljs-number">25</span>.<span class="hljs-number">0</span>  <span class="hljs-number">26</span>.<span class="hljs-number">0</span>  <span class="hljs-number">21</span>.<span class="hljs-number">0</span>  <span class="hljs-number">22</span>.<span class="hljs-number">0</span><br><span class="hljs-attribute">25</span>.<span class="hljs-number">0</span>  <span class="hljs-number">26</span>.<span class="hljs-number">0</span>  <span class="hljs-number">21</span>.<span class="hljs-number">0</span>  <span class="hljs-number">22</span>.<span class="hljs-number">0</span>  <span class="hljs-number">23</span>.<span class="hljs-number">0</span>  <span class="hljs-number">24</span>.<span class="hljs-number">0</span><br><span class="hljs-attribute">23</span>.<span class="hljs-number">0</span>  <span class="hljs-number">24</span>.<span class="hljs-number">0</span>  <span class="hljs-number">25</span>.<span class="hljs-number">0</span>  <span class="hljs-number">26</span>.<span class="hljs-number">0</span>   <span class="hljs-number">0</span>.<span class="hljs-number">0</span>   <span class="hljs-number">0</span>.<span class="hljs-number">0</span><br><span class="hljs-attribute">0</span>.<span class="hljs-number">0</span>    <span class="hljs-number">0</span>.<span class="hljs-number">0</span>  <span class="hljs-number">21</span>.<span class="hljs-number">0</span>  <span class="hljs-number">22</span>.<span class="hljs-number">0</span>  <span class="hljs-number">23</span>.<span class="hljs-number">0</span>  <span class="hljs-number">24</span>.<span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p>​<strong>示例</strong></p><p>​下面的例子演示了转置矩阵：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">program matrixTranspose<br>implicit none<br><br>   <span class="hljs-keyword">interface</span><br>      <span class="hljs-symbol">subroutine</span> <span class="hljs-symbol">write_matrix</span>(<span class="hljs-symbol">a</span>)<br>         <span class="hljs-symbol">integer</span>, <span class="hljs-symbol">dimension</span>(:,:) :: <span class="hljs-symbol">a</span><br>      <span class="hljs-symbol">end</span> <span class="hljs-symbol">subroutine</span> <span class="hljs-symbol">write_matrix</span><br>   <span class="hljs-symbol">end</span> <span class="hljs-symbol">interface</span><br><br>   <span class="hljs-symbol">integer</span>, <span class="hljs-symbol">dimension</span>(<span class="hljs-symbol">3</span>,<span class="hljs-symbol">3</span>) :: <span class="hljs-symbol">a</span>, <span class="hljs-symbol">b</span><br>   <span class="hljs-symbol">integer</span> :: <span class="hljs-symbol">i</span>, <span class="hljs-symbol">j</span><br>    <br>   <span class="hljs-symbol">do</span> <span class="hljs-symbol">i</span> = <span class="hljs-symbol">1</span>, <span class="hljs-symbol">3</span><br>      <span class="hljs-symbol">do</span> <span class="hljs-symbol">j</span> = <span class="hljs-symbol">1</span>, <span class="hljs-symbol">3</span><br>         <span class="hljs-symbol">a</span>(<span class="hljs-symbol">i</span>, <span class="hljs-symbol">j</span>) = <span class="hljs-symbol">i</span><br>      <span class="hljs-symbol">end</span> <span class="hljs-symbol">do</span><br>   <span class="hljs-symbol">end</span> <span class="hljs-symbol">do</span><br>   <br>   <span class="hljs-symbol">print</span> *, &#x27;<span class="hljs-symbol">Matrix</span> <span class="hljs-symbol">Transpose</span>: <span class="hljs-symbol">A</span> <span class="hljs-symbol">Matrix</span>&#x27;<br>   <br>   <span class="hljs-symbol">call</span> <span class="hljs-symbol">write_matrix</span>(<span class="hljs-symbol">a</span>)<br>   <span class="hljs-symbol">b</span> = <span class="hljs-symbol">transpose</span>(<span class="hljs-symbol">a</span>)<br>   <span class="hljs-symbol">print</span> *, &#x27;<span class="hljs-symbol">Transposed</span> <span class="hljs-symbol">Matrix</span>:&#x27;<br>   <br>   <span class="hljs-symbol">call</span> <span class="hljs-symbol">write_matrix</span>(<span class="hljs-symbol">b</span>)<br><span class="hljs-symbol">end</span> <span class="hljs-symbol">program</span> <span class="hljs-symbol">matrixTranspose</span><br><br><br><span class="hljs-symbol">subroutine</span> <span class="hljs-symbol">write_matrix</span>(<span class="hljs-symbol">a</span>)<br><br>   <span class="hljs-symbol">integer</span>, <span class="hljs-symbol">dimension</span>(:,:) :: <span class="hljs-symbol">a</span><br>   <span class="hljs-symbol">write</span>(*,*)<br>   <br>   <span class="hljs-symbol">do</span> <span class="hljs-symbol">i</span> = <span class="hljs-symbol">lbound</span>(<span class="hljs-symbol">a</span>,<span class="hljs-symbol">1</span>), <span class="hljs-symbol">ubound</span>(<span class="hljs-symbol">a</span>,<span class="hljs-symbol">1</span>)<br>      <span class="hljs-symbol">write</span>(*,*) (<span class="hljs-symbol">a</span>(<span class="hljs-symbol">i</span>,<span class="hljs-symbol">j</span>), <span class="hljs-symbol">j</span> = <span class="hljs-symbol">lbound</span>(<span class="hljs-symbol">a</span>,<span class="hljs-symbol">2</span>), <span class="hljs-symbol">ubound</span>(<span class="hljs-symbol">a</span>,<span class="hljs-symbol">2</span>))<br>   <span class="hljs-symbol">end</span> <span class="hljs-symbol">do</span><br>   <br><span class="hljs-symbol">end</span> <span class="hljs-symbol">subroutine</span> <span class="hljs-symbol">write_matrix</span><br></code></pre></td></tr></table></figure><p>​当上述代码被编译和执行时，它产生了以下结果：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">Matrix</span> Transpose: A Matrix<br><br><span class="hljs-attribute">1</span>  <span class="hljs-number">1</span>  <span class="hljs-number">1</span><br><span class="hljs-attribute">2</span>  <span class="hljs-number">2</span>  <span class="hljs-number">2</span><br><span class="hljs-attribute">3</span>  <span class="hljs-number">3</span>  <span class="hljs-number">3</span><br><span class="hljs-attribute">Transposed</span> Matrix:<br><br><span class="hljs-attribute">1</span>  <span class="hljs-number">2</span>  <span class="hljs-number">3</span><br><span class="hljs-attribute">1</span>  <span class="hljs-number">2</span>  <span class="hljs-number">3</span><br><span class="hljs-attribute">1</span>  <span class="hljs-number">2</span>  <span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><h2 id="位置函数"><a href="#位置函数" class="headerlink" title="位置函数"></a>位置函数</h2><p>下表描述了位置函数：</p><table><thead><tr><th>函数</th><th>描述</th></tr></thead><tbody><tr><td><strong>maxloc</strong>(array, mask)</td><td>它返回数组中的最大元素的位置上，如果掩码仅包含那些其中满足条件的掩码，则返回位置，其结果是一个整数向量。</td></tr><tr><td><strong>minloc</strong>(array, mask)</td><td>它返回数组的数组中的最小元素的位置，如果掩码仅包含那些其中满足条件的掩码，则返回位置，其结果是一个整数向量。</td></tr></tbody></table><p>​<strong>示例</strong></p><p>​下面的例子演示了这一概念：</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs fortran"><span class="hljs-function"><span class="hljs-keyword">program</span></span> arrayLocation<br><span class="hljs-keyword">implicit</span> <span class="hljs-keyword">none</span><br><br>   <span class="hljs-keyword">real</span>, <span class="hljs-keyword">dimension</span>(<span class="hljs-number">1</span>:<span class="hljs-number">6</span>) :: a = (/ <span class="hljs-number">21.0</span>, <span class="hljs-number">12.0</span>,<span class="hljs-number">33.0</span>, <span class="hljs-number">24.0</span>, <span class="hljs-number">15.0</span>, <span class="hljs-number">16.0</span> /)<br>   <span class="hljs-built_in">Print</span> *, <span class="hljs-built_in">maxloc</span>(a)<br>   <span class="hljs-built_in">Print</span> *, <span class="hljs-built_in">minloc</span>(a)<br>   <br><span class="hljs-keyword">end</span> <span class="hljs-function"><span class="hljs-keyword">program</span></span> arrayLocation   <br></code></pre></td></tr></table></figure><p>​当上述代码被编译和执行时，它产生了以下结果：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs">3<br>2<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Fortran</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Fortran-子程序</title>
    <link href="/2022/05/23/Fortran-%E5%AD%90%E7%A8%8B%E5%BA%8F/"/>
    <url>/2022/05/23/Fortran-%E5%AD%90%E7%A8%8B%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<p>Fortran 语言中的子程序事实上和其他编程语言的函数有点类似（后面会提到 Fortran 本身也支持函数）：<strong>把需要重复使用的某些代码都集中成一个子程序，调用时可以给子程序初始化一些变量值从而获得不同的结果</strong>。比如说数值微分或者微分方程组的解法一类的数值计算代码就可以写成子程序的形式。</p><h2 id="定义和调用"><a href="#定义和调用" class="headerlink" title="定义和调用"></a>定义和调用</h2><p>子程序的一般结构如下所示：</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs Fortran"><span class="hljs-comment">!!! 不带初始化变量的子程序</span><br><span class="hljs-function"><span class="hljs-keyword">subroutine</span></span> subr1<br>    <span class="hljs-keyword">implicit</span> <span class="hljs-keyword">none</span><br>    <span class="hljs-keyword">real</span> a, b<br>    <span class="hljs-keyword">integer</span> i<br>    ......<br>    ......<br><span class="hljs-keyword">end</span> <span class="hljs-function"><span class="hljs-keyword">subroutine</span></span> subr1<br></code></pre></td></tr></table></figure><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs fortran"><span class="hljs-comment">!!! 带初始化变量的子程序</span><br><span class="hljs-function"><span class="hljs-keyword">subroutine</span></span> subr2(x, m, y, n)<br>    <span class="hljs-keyword">implicit</span> <span class="hljs-keyword">none</span><br>    <span class="hljs-keyword">real</span> x, y, a, b, z(<span class="hljs-number">10</span>)<br>    <span class="hljs-keyword">integer</span> m, n, i, k<br>    ......<br>    ......<br><span class="hljs-keyword">end</span> <span class="hljs-function"><span class="hljs-keyword">subroutine</span></span> subr2<br></code></pre></td></tr></table></figure><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs fortran"><span class="hljs-comment">!!! 调用子程序</span><br><span class="hljs-keyword">real</span> z<br><span class="hljs-keyword">integer</span> m<br><span class="hljs-keyword">call</span> subr1<br>m = <span class="hljs-number">21</span><br><span class="hljs-keyword">call</span> subr2(<span class="hljs-number">10.0</span>, <span class="hljs-number">100</span>, z, m*<span class="hljs-number">5</span>+<span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure><p>子程序是以 <code>subroutine</code> 开头、以 <code>end subroutine</code> 结尾，其中<strong>第一行与一般主程序一样需要添加一行 <code>implicit none</code> 的声明</strong>。</p><h5 id="小提示"><a href="#小提示" class="headerlink" title="小提示"></a>小提示</h5><p><strong>值得注意</strong>的是，子程序可以在主程序中被任意调用若干次，但同时也是依赖主程序存在的，即<strong>只有子程序的代码无法被执行</strong>。</p><p>从上面的例子可以看出，无论是初始化还是没初始化变量，子程序都可以在主程序中被调用执行。只不过带初始化变量的子程序应该在被调用时给定相应的变量，否则无法正常被调用。</p><p>如下所示是一个完整包含主程序和子程序的代码示例。主程序是以 <code>program</code> 开头、以 <code>end program</code> 结尾的代码片段。子程序代码不被包含在主程序代码片段中，但与主程序在同一文件中。</p><h5 id="小提示-1"><a href="#小提示-1" class="headerlink" title="小提示"></a>小提示</h5><p><strong>子程序可以位于主程序代码片段之前或之后，不会影响在主程序中的正常调用</strong>。</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs fortran"><span class="hljs-function"><span class="hljs-keyword">program</span></span> stest1<br>    <span class="hljs-keyword">implicit</span> <span class="hljs-keyword">none</span><br>    <span class="hljs-keyword">real</span> x, y<br>    x = <span class="hljs-number">5.0</span><br>    y = <span class="hljs-number">100.0</span><br>    <span class="hljs-keyword">call</span> subr(x, y, <span class="hljs-number">10</span>)<br>    <span class="hljs-built_in">print</span> *, x, y<br><span class="hljs-keyword">end</span> <span class="hljs-function"><span class="hljs-keyword">program</span></span> stest1<br><br><span class="hljs-function"><span class="hljs-keyword">subroutine</span></span> subr(x, y, n)<br>    <span class="hljs-keyword">implicit</span> <span class="hljs-keyword">none</span><br>    <span class="hljs-keyword">real</span> x, y<br>    <span class="hljs-keyword">integer</span> n<br>    x = n<br>    y = y*x<br><span class="hljs-keyword">end</span> <span class="hljs-function"><span class="hljs-keyword">subroutine</span></span> subr<br></code></pre></td></tr></table></figure><p>子程序的调用和主程序的执行顺序是：<strong>主程序 → 子程序 → 主程序</strong>。</p><p>由于<strong>子程序被调用时实际上不会与其他正在被执行的子程序相互干扰</strong>，所以可以在一个主程序中重复调用同一子程序。如果在子程序中需要根据某个条件判断中断退出，可以如下所示利用 <code>if</code> 语句和 <code>return</code> 关键字来返回主程序。</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs fortran"><span class="hljs-function"><span class="hljs-keyword">subroutine</span></span> subr(x, y, m, n)<br>    <span class="hljs-keyword">implicit</span> <span class="hljs-keyword">none</span><br>    <span class="hljs-keyword">real</span> x, y<br>    <span class="hljs-keyword">integer</span> m, n<br>    ......<br>    <span class="hljs-keyword">if</span> (m &lt; n) <span class="hljs-keyword">return</span><br>    ......<br><span class="hljs-keyword">end</span> <span class="hljs-function"><span class="hljs-keyword">subroutine</span></span> subr<br></code></pre></td></tr></table></figure><h2 id="局部变量"><a href="#局部变量" class="headerlink" title="局部变量"></a>局部变量</h2><h3 id="子程序变量的局部性"><a href="#子程序变量的局部性" class="headerlink" title="子程序变量的局部性"></a>子程序变量的局部性</h3><p>子程序中定义的<strong>局部变量和参数独立于主程序</strong>。也就是说，当我们在主程序和子程序中同时定义<strong>相同名称的变量</strong>时，其实它们之间也是不同的。只有当我们在调用子程序时使用主程序中同名的变量对参数进行赋值时，主程序和子程序的同名变量才会具有相同的值。</p><p>如下面的示例 1 所示，编译执行的结果并非是期待的 10.0 和 30.0。</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs fortran"><span class="hljs-comment">!!! 示例 1</span><br><span class="hljs-function"><span class="hljs-keyword">program</span></span> stest1<br>    <span class="hljs-keyword">implicit</span> <span class="hljs-keyword">none</span><br>    <span class="hljs-keyword">real</span> x, y<br>    x = <span class="hljs-number">10.0</span><br>    y = <span class="hljs-number">30.0</span><br>    <span class="hljs-keyword">call</span> subr1<br><span class="hljs-keyword">end</span> <span class="hljs-function"><span class="hljs-keyword">program</span></span> stest1<br><br><span class="hljs-function"><span class="hljs-keyword">subroutine</span></span> subr1<br>    <span class="hljs-keyword">implicit</span> <span class="hljs-keyword">none</span><br>    <span class="hljs-keyword">real</span> x, y<br>    <span class="hljs-built_in">print</span> *, x, y<br><span class="hljs-keyword">end</span> <span class="hljs-function"><span class="hljs-keyword">subroutine</span></span> subr1<br><br><span class="hljs-comment">!!! 执行结果</span><br>&gt;&gt;&gt;    <span class="hljs-number">2.80259693E-45</span>   <span class="hljs-number">0.00000000</span><br></code></pre></td></tr></table></figure><p>当我们修改为带初始化变量的子程序时，如示例 2 所示，编译执行的结果和期待的一样。</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs fortran"><span class="hljs-comment">!!! 示例 2</span><br><span class="hljs-function"><span class="hljs-keyword">program</span></span> stest2<br>    <span class="hljs-keyword">implicit</span> <span class="hljs-keyword">none</span><br>    <span class="hljs-keyword">real</span> x, y<br>    x = <span class="hljs-number">10.0</span><br>    y = <span class="hljs-number">30.0</span><br>    <span class="hljs-keyword">call</span> subr2(x, y)<br><span class="hljs-keyword">end</span> <span class="hljs-function"><span class="hljs-keyword">program</span></span> stest2<br><br><span class="hljs-function"><span class="hljs-keyword">subroutine</span></span> subr2(x, y)<br>    <span class="hljs-keyword">implicit</span> <span class="hljs-keyword">none</span><br>    <span class="hljs-keyword">real</span> x, y<br>    <span class="hljs-built_in">print</span> *, x, y<br><span class="hljs-keyword">end</span> <span class="hljs-function"><span class="hljs-keyword">subroutine</span></span> subr2<br><br><span class="hljs-comment">!!! 执行结果</span><br>&gt;&gt;&gt;    <span class="hljs-number">10.0000000</span>       <span class="hljs-number">30.0000000</span><br></code></pre></td></tr></table></figure><p>这两个例子的对比再一次证明了子程序中定义的变量所具有的局部性，<strong>必须通过参数传递的方式才能与主程序同名变量保持一样的初始化值</strong>。同样地，这种局部性也会让主程序的变量值不会因为子程序的同名变量值发生改变而改变。</p><p>有人可能会有疑问，如果子程序中的参数使用的变量名与主程序的变量名不一致，调用能不能成功呢？当然是能够成功的。如下所示，将示例 2 中子程序原来的参数 x 和 y 换成 a 和 b，依然可以输出正确结果。</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs fortran"><span class="hljs-function"><span class="hljs-keyword">subroutine</span></span> subr2(a, b)<br>    <span class="hljs-keyword">implicit</span> <span class="hljs-keyword">none</span><br>    <span class="hljs-keyword">real</span> a, b<br>    <span class="hljs-built_in">print</span> *, a, b<br><span class="hljs-keyword">end</span> <span class="hljs-function"><span class="hljs-keyword">subroutine</span></span> subr2<br><br><span class="hljs-comment">!!! 执行结果</span><br>&gt;&gt;&gt;    <span class="hljs-number">10.0000000</span>       <span class="hljs-number">30.0000000</span><br></code></pre></td></tr></table></figure><h3 id="类型声明的一致性"><a href="#类型声明的一致性" class="headerlink" title="类型声明的一致性"></a>类型声明的一致性</h3><p>主程序中调用带初始化变量的子程序时，需要注意使用相同类型的变量来给子程序初始化参数，否则就会报错。如示例 3 中所示，子程序中所定义的参数 x 和 y 为实数、参数 m 和 n 为整数。主程序中调用时传递的变量值也是对应的实数和整数，具体如下表所示。</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs fortran"><span class="hljs-comment">!!! 示例 3</span><br><span class="hljs-function"><span class="hljs-keyword">program</span></span> stest3<br>    <span class="hljs-keyword">implicit</span> <span class="hljs-keyword">none</span><br>    <span class="hljs-keyword">real</span> z<br>    <span class="hljs-keyword">integer</span> n<br>    z = <span class="hljs-number">200.0</span><br>    n = <span class="hljs-number">21</span><br>    <span class="hljs-keyword">call</span> subr3(<span class="hljs-number">10.0</span>, z**<span class="hljs-number">2</span>, <span class="hljs-number">100</span>, n*<span class="hljs-number">5</span>+<span class="hljs-number">1</span>)<br><span class="hljs-keyword">end</span> <span class="hljs-function"><span class="hljs-keyword">program</span></span> stest3<br><br><span class="hljs-function"><span class="hljs-keyword">subroutine</span></span> subr3(x, y, m, n)<br>    <span class="hljs-keyword">implicit</span> <span class="hljs-keyword">none</span><br>    <span class="hljs-keyword">real</span> x, y<br>    <span class="hljs-keyword">integer</span> m, n<br>    <span class="hljs-built_in">print</span> *, x, y, m, n<br><span class="hljs-keyword">end</span> <span class="hljs-function"><span class="hljs-keyword">subroutine</span></span> subr3<br></code></pre></td></tr></table></figure><table><thead><tr><th>调用语句</th><th>子程序语句</th><th>数值类型</th></tr></thead><tbody><tr><td>10.0</td><td>x</td><td>实数</td></tr><tr><td>z**2</td><td>y</td><td>实数</td></tr><tr><td>100</td><td>m</td><td>整数</td></tr><tr><td>n*5+1</td><td>n</td><td>整数</td></tr></tbody></table><h3 id="子程序的返回值"><a href="#子程序的返回值" class="headerlink" title="子程序的返回值"></a>子程序的返回值</h3><p>刚才提到的子程序中定义的变量是局部变量，不会干扰主程序中的其他变量，但是如果我们想要把子程序计算的结果返回给主程序呢？在其他的编程语言中，可能大部分是使用 <code>return</code> 加变量名的方式来将子程序中的变量传递回主程序。<strong>在 Fortran 中，子程序会将参数变量全部返回给主程序，可以认为是地址引用</strong>。如果主程序调用子程序时<strong>用一个算式传递变量给子程序，那么可以认为是值引用</strong>。</p><p>如下面的示例 4 所示，主程序中调用子程序时最后的变量 p 就是要保存返回值的变量。从执行结果也可以看出，变量 x 和 y 并没有受到子程序的影响，只有变量 p 带着子程序的变量 z 的值正确返回了。因为这里 x+y 作为子程序中的 x 存在，而 x+y 这个变量实际上在主程序中不存在，所以是值引用。</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs fortran"><span class="hljs-comment">!!! 示例 4</span><br><span class="hljs-function"><span class="hljs-keyword">program</span></span> stest4<br>    <span class="hljs-keyword">implicit</span> <span class="hljs-keyword">none</span><br>    <span class="hljs-keyword">real</span> x, y, p<br>    x = <span class="hljs-number">10.0</span><br>    y = <span class="hljs-number">30.0</span><br>    <span class="hljs-keyword">call</span> subr4(x+y, <span class="hljs-number">20.0</span>, p)<br>    <span class="hljs-built_in">print</span> *, x, y, p<br><span class="hljs-keyword">end</span> <span class="hljs-function"><span class="hljs-keyword">program</span></span> stest4<br><br><span class="hljs-function"><span class="hljs-keyword">subroutine</span></span> subr4(x, y, z)<br>    <span class="hljs-keyword">implicit</span> <span class="hljs-keyword">none</span><br>    <span class="hljs-keyword">real</span> x, y, z<br>    z = x*y<br><span class="hljs-keyword">end</span> <span class="hljs-function"><span class="hljs-keyword">subroutine</span></span> subr4<br><br><span class="hljs-comment">!!! 执行结果</span><br>&gt;&gt;&gt;   <span class="hljs-number">10.0000000</span>       <span class="hljs-number">30.0000000</span>       <span class="hljs-number">800.000000</span><br></code></pre></td></tr></table></figure><h5 id="小提示-2"><a href="#小提示-2" class="headerlink" title="小提示"></a>小提示</h5><p><strong>值引用</strong>和<strong>地址引用</strong>的定义：值引用是指引用值而不引用原来的变量或者存储器中对应的地址，地址引用是指引用原来的变量或者存储器中对应的地址。<br><strong>值引用</strong>和<strong>地址引用</strong>的区别：前者不会因子程序的操作而发生改变，后者可能会因子程序的操作而发生改变。如果我们仅仅是为了传递某个值给子程序作为输入，可以采用值引用，从而避免对于主程序的干扰。如果我们希望子程序的操作改变变量的值，可以采用地址引用。</p><h2 id="数组变量"><a href="#数组变量" class="headerlink" title="数组变量"></a>数组变量</h2><h3 id="数组作为子程序参数"><a href="#数组作为子程序参数" class="headerlink" title="数组作为子程序参数"></a>数组作为子程序参数</h3><p>如果主程序想要用数组变量或数组变量的某个位置的值为调用的子程序赋值，Fortran 也是完全支持的。如下所示，第一行是用数组变量初始化子程序参数，第二行是用数组变量 a 中编号为 1 的元素初始化子程序参数。</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs fortran"><span class="hljs-keyword">call</span> sub(a)<br><span class="hljs-keyword">call</span> sub(a(<span class="hljs-number">1</span>))<br></code></pre></td></tr></table></figure><p>上面第一行调用方式对应的主程序和子程序可以类似于下面的示例 5。主程序和子程序中分别将 a 和 x 都定义为长度为 10 的一维数组，并在子程序中使用循环的方式依次为数组 x 的每个元素赋值。最后，赋好值的数组 x 也会返回给主程序。从执行结果看到，输出结果为期待的 a(3) 值。</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs fortran"><span class="hljs-comment">!!! 示例 5</span><br><span class="hljs-function"><span class="hljs-keyword">program</span></span> stest5<br>    <span class="hljs-keyword">implicit</span> <span class="hljs-keyword">none</span><br>    <span class="hljs-keyword">real</span> a(<span class="hljs-number">10</span>)<br>    <span class="hljs-keyword">call</span> sub(a)<br>    <span class="hljs-built_in">print</span> *, a(<span class="hljs-number">3</span>)<br><span class="hljs-keyword">end</span> <span class="hljs-function"><span class="hljs-keyword">program</span></span> stest5<br><br><span class="hljs-function"><span class="hljs-keyword">subroutine</span></span> sub(x)<br>    <span class="hljs-keyword">implicit</span> <span class="hljs-keyword">none</span><br>    <span class="hljs-keyword">real</span> x(<span class="hljs-number">10</span>)<br>    <span class="hljs-keyword">integer</span> i<br>    <span class="hljs-keyword">do</span> i = <span class="hljs-number">1</span>, <span class="hljs-number">10</span><br>        x(i) = i<br>    <span class="hljs-keyword">enddo</span><br><span class="hljs-keyword">end</span> <span class="hljs-function"><span class="hljs-keyword">subroutine</span></span> sub<br><br><span class="hljs-comment">!!! 执行结果</span><br>&gt;&gt;&gt;   <span class="hljs-number">3.00000000</span><br></code></pre></td></tr></table></figure><p>如果我们在调用时写成了 <code>call sub(a(1))</code>，那会怎么样呢？实际上还是会得到一样的结果。</p><h3 id="数组变量的顺序对应"><a href="#数组变量的顺序对应" class="headerlink" title="数组变量的顺序对应"></a>数组变量的顺序对应</h3><p>如果将 <code>a(1)</code> 修改为 <code>a(3)</code> 并保持数组 a 的长度为 10，即数组 a 和数组 x 不从第一个元素开始对应，那么源代码将无法被编译，如示例 5 的变种一所示。</p><p>要想在这种情况下还能正常编译，我们就必须扩充数组 a 的长度至少为 12。这样一来，子程序中要赋值的数都能正确存入数组 x 并返回给主程序的数组变量 a，如示例 5 的变种二所示。</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs fortran"><span class="hljs-comment">!!! 示例 5 的变种一</span><br><span class="hljs-function"><span class="hljs-keyword">program</span></span> stest5<br>    <span class="hljs-keyword">implicit</span> <span class="hljs-keyword">none</span><br>    <span class="hljs-keyword">real</span> a(<span class="hljs-number">10</span>)<br>    <span class="hljs-keyword">call</span> sub(a(<span class="hljs-number">3</span>))<br>    <span class="hljs-built_in">print</span> *, a(<span class="hljs-number">3</span>)<br><span class="hljs-keyword">end</span> <span class="hljs-function"><span class="hljs-keyword">program</span></span> stest5<br><br><span class="hljs-function"><span class="hljs-keyword">subroutine</span></span> sub(x)<br>    <span class="hljs-keyword">implicit</span> <span class="hljs-keyword">none</span><br>    <span class="hljs-keyword">real</span> x(<span class="hljs-number">10</span>)<br>    <span class="hljs-keyword">integer</span> i<br>    <span class="hljs-keyword">do</span> i = <span class="hljs-number">1</span>, <span class="hljs-number">10</span><br>        x(i) = i<br>    <span class="hljs-keyword">enddo</span><br><span class="hljs-keyword">end</span> <span class="hljs-function"><span class="hljs-keyword">subroutine</span></span> sub <br><br><span class="hljs-comment">!!! 执行结果</span><br>&gt;&gt;&gt; Error: Actual argument <span class="hljs-keyword">contains</span> too few elements for dummy argument <span class="hljs-string">&#x27;x&#x27;</span> (<span class="hljs-number">8</span>/<span class="hljs-number">10</span>) at (<span class="hljs-number">1</span>)<br><br><span class="hljs-comment">!!! 示例 5 的变种二</span><br><span class="hljs-function"><span class="hljs-keyword">program</span></span> stest5<br>    <span class="hljs-keyword">implicit</span> <span class="hljs-keyword">none</span><br>    <span class="hljs-keyword">real</span> a(<span class="hljs-number">12</span>)<br>    <span class="hljs-keyword">call</span> sub(a(<span class="hljs-number">3</span>))<br>    <span class="hljs-built_in">print</span> *, a(<span class="hljs-number">3</span>)<br><span class="hljs-keyword">end</span> <span class="hljs-function"><span class="hljs-keyword">program</span></span> stest5<br><br><span class="hljs-function"><span class="hljs-keyword">subroutine</span></span> sub(x)<br>    <span class="hljs-keyword">implicit</span> <span class="hljs-keyword">none</span><br>    <span class="hljs-keyword">real</span> x(<span class="hljs-number">10</span>)<br>    <span class="hljs-keyword">integer</span> i<br>    <span class="hljs-keyword">do</span> i = <span class="hljs-number">1</span>, <span class="hljs-number">10</span><br>        x(i) = i<br>    <span class="hljs-keyword">enddo</span><br><span class="hljs-keyword">end</span> <span class="hljs-function"><span class="hljs-keyword">subroutine</span></span> sub <br><br><span class="hljs-comment">!!! 执行结果</span><br>&gt;&gt;&gt;   <span class="hljs-number">1.00000000</span><br></code></pre></td></tr></table></figure><p>其实，**在子程序中也可以不定义数组的长度，将长度设置为 <code>*</code>**。</p><p>如下示例 6 所示，子程序的功能是将数组 a 中的前 n 个元素复制给数组 b。</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs fortran"><span class="hljs-comment">!!! 示例 6</span><br><span class="hljs-function"><span class="hljs-keyword">subroutine</span></span> copy(a, b, n)<br>    <span class="hljs-keyword">implicit</span> <span class="hljs-keyword">none</span><br>    <span class="hljs-keyword">real</span> a(*), b(*)<br>    <span class="hljs-keyword">integer</span> n, i<br>    <span class="hljs-keyword">do</span> i = i, n<br>        b(i) = a(i)<br>    <span class="hljs-keyword">enddo</span><br><span class="hljs-keyword">end</span> <span class="hljs-function"><span class="hljs-keyword">subroutine</span></span> copy<br></code></pre></td></tr></table></figure><h3 id="二维数组变量"><a href="#二维数组变量" class="headerlink" title="二维数组变量"></a>二维数组变量</h3><p>当然，除了一维数组，我们也可能会想在<strong>主程序中传递二维数组给子程序，但是<code>a(*, *)</code> 的写法在 Fortran 中是不支持的</strong>。因此，我们需要把二维数组的维度也传递给子程序。</p><p>如下示例 7 所示，数组 a 和 b 为二维数组，m 和 n 是它们的维度。子程序中使用数组变量名和给定的维度定义出二维数组。示例 7 的主程序定义了四个二维数组及它们的维度大小，调用子程序时不仅传递了数组本身，也传递了维度大小。而子程序采用了两个 for 循环叠加的方式来交替给二维数组中的每一行每一列的元素赋值。</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs fortran"><span class="hljs-comment">!!! 示例 7</span><br><span class="hljs-function"><span class="hljs-keyword">program</span></span> stest1<br>    <span class="hljs-keyword">implicit</span> <span class="hljs-keyword">none</span><br>    <span class="hljs-keyword">real</span> a(<span class="hljs-number">10</span>, <span class="hljs-number">20</span>), b(<span class="hljs-number">10</span>, <span class="hljs-number">20</span>), c(<span class="hljs-number">100</span>, <span class="hljs-number">200</span>), d(<span class="hljs-number">100</span>, <span class="hljs-number">200</span>)<br>    ......<br>    <span class="hljs-keyword">call</span> copy2d(a, b, <span class="hljs-number">10</span>, <span class="hljs-number">20</span>)<br>    <span class="hljs-keyword">call</span> copy2d(c, d, <span class="hljs-number">100</span>, <span class="hljs-number">200</span>)<br><span class="hljs-keyword">end</span> <span class="hljs-function"><span class="hljs-keyword">program</span></span> stest1<br><br><span class="hljs-function"><span class="hljs-keyword">subroutine</span></span> copy2d(a, b, m, n)<br>    <span class="hljs-keyword">implicit</span> <span class="hljs-keyword">none</span><br>    <span class="hljs-keyword">real</span> a(m, n), b(m, n)<br>    <span class="hljs-keyword">integer</span> m, n, i, j<br>    <span class="hljs-keyword">do</span> j = i, n<br>        <span class="hljs-keyword">do</span> i = i, m<br>            b(i, j) = a(i, j)<br>        <span class="hljs-keyword">enddo</span><br>    <span class="hljs-keyword">enddo</span><br><span class="hljs-keyword">end</span> <span class="hljs-function"><span class="hljs-keyword">subroutine</span></span> copy2d<br></code></pre></td></tr></table></figure><p>数组 a(m, n) 的定义表示数组的行号是从 1 到 m、列号是从 1 到 n。如果想要行号和列号从 0 开始，则应该将数组定义为 a(0:m-1, 0:n-1)。一维数组时可以定义为 a(0:*)。</p><h2 id="函数副程序"><a href="#函数副程序" class="headerlink" title="函数副程序"></a>函数副程序</h2><p><strong>函数副程序，这个称呼不一定十分准确，实际上就是其他编程语言中常用的函数</strong>。在某种程度上，函数只是子程序的替代，但是对于 Fortran 来说，函数必须将函数名作为变量进行声明，并将计算的结果赋给这个函数名同名变量。一个完整的例子如下示例 8 所示。</p><h5 id="小提示-3"><a href="#小提示-3" class="headerlink" title="小提示"></a>小提示</h5><p><strong>函数副程序只能返回一个结果，而子程序可以返回多个结果</strong>。所以如果只是用来计算某个公式或者求解某个结果，可以优先采用函数副程序。如果需要同时返回多个变量，则优先采用子程序。</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs fortran"><span class="hljs-comment">!!! 示例 8</span><br><span class="hljs-function"><span class="hljs-keyword">function</span></span> square(x)<br>    <span class="hljs-keyword">implicit</span> <span class="hljs-keyword">none</span><br>    <span class="hljs-keyword">real</span> square, x         <span class="hljs-comment">! 声明函数名同名变量</span><br>    square = x*x           <span class="hljs-comment">! 将计算结果赋给函数名同名变量</span><br><span class="hljs-keyword">end</span> <span class="hljs-function"><span class="hljs-keyword">function</span></span> square<br><br><span class="hljs-function"><span class="hljs-keyword">program</span></span> ftest1<br>    <span class="hljs-keyword">implicit</span> <span class="hljs-keyword">none</span><br>    <span class="hljs-keyword">real</span> x, y, square      <span class="hljs-comment">! 声明使用的函数名同名变量</span><br>    x = <span class="hljs-number">4.0</span><br>    y = <span class="hljs-number">3.0</span>*square(x+<span class="hljs-number">1.0</span>) + <span class="hljs-number">50.5</span><br>    <span class="hljs-built_in">print</span> *, x, y<br><span class="hljs-keyword">end</span> <span class="hljs-function"><span class="hljs-keyword">program</span></span> ftest1<br><br><span class="hljs-comment">!!! 执行结果</span><br>&gt;&gt;&gt;   <span class="hljs-number">4.00000000</span>       <span class="hljs-number">125.500000</span><br></code></pre></td></tr></table></figure><h5 id="小提示-4"><a href="#小提示-4" class="headerlink" title="小提示"></a>小提示</h5><p>Fortran 中的函数使用需要严格遵守函数名同名变量在主程序和函数中的相同类型声明，否则就无法通过编译。</p><h2 id="全局变量"><a href="#全局变量" class="headerlink" title="全局变量"></a>全局变量</h2><p>虽然我们在不同的子程序中使用同名的局部变量不会相互影响，但是有的时候也希望一些变量能在不同的子程序中共享使用，这类变量我们可以称之为<strong>全局变量</strong>。</p><p>Fortran 语言中全局变量必须使用 <code>module</code> 的方式单独定义。当在主程序或子程序中需要使用这些已定义的全局变量时，首先要使用 <code>use &lt;module 名&gt;</code> 来声明引用，并且该声明应在 <code>implicit none</code> 之前。如下所示，定义了两个整数类型的变量 nmin 和 nmax，以及实数类型的变量 tinitial 和 二维数组 amatrix。</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs fortran"><span class="hljs-keyword">module</span> data1<br>    <span class="hljs-keyword">integer</span> nmin, nmax<br>    <span class="hljs-keyword">real</span> tinitial, amatrix(<span class="hljs-number">20</span>, <span class="hljs-number">30</span>)<br><span class="hljs-keyword">end</span> <span class="hljs-keyword">module</span> data1<br></code></pre></td></tr></table></figure><p>示例 9 是一个完整的全局变量定义和使用的例子。可以看到，子程序并没有声明任何参数，而是利用定义的全局变量 xais 和 yais 来从主程序中传递值到子程序中。这里的程序执行顺序是：<strong>主程序 → 调用子程序 → 子程序中的打印 → 子程序修改 yais 变量 → 主程序中的打印 → 程序结束</strong>。所以最终的执行结果的第一行是子程序中打印还未修改的两个全局变量，而第二行是主程序中打印已被子程序修改的两个全局变量，符合预期效果。</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs fortran"><span class="hljs-comment">!!! 示例 9</span><br><span class="hljs-keyword">module</span> global<br>    <span class="hljs-keyword">real</span> xais, yais<br><span class="hljs-keyword">end</span> <span class="hljs-keyword">module</span> global<br><br><span class="hljs-function"><span class="hljs-keyword">program</span></span> stest4<br>    <span class="hljs-keyword">use</span> global<br>    <span class="hljs-keyword">implicit</span> <span class="hljs-keyword">none</span><br>    xais = <span class="hljs-number">5.0</span><br>    yais = <span class="hljs-number">100.0</span><br>    <span class="hljs-keyword">call</span> subr4<br>    <span class="hljs-built_in">print</span> *, xais, yais<br><span class="hljs-keyword">end</span> <span class="hljs-function"><span class="hljs-keyword">program</span></span> stest4<br><br><span class="hljs-function"><span class="hljs-keyword">subroutine</span></span> subr4<br>    <span class="hljs-keyword">use</span> global<br>    <span class="hljs-keyword">implicit</span> <span class="hljs-keyword">none</span><br>    <span class="hljs-built_in">print</span> *, xais, yais<br>    yais = <span class="hljs-number">25.0</span><br><span class="hljs-keyword">end</span> <span class="hljs-function"><span class="hljs-keyword">subroutine</span></span> subr4<br><br><span class="hljs-comment">!!! 执行结果</span><br>&gt;&gt;&gt;   <span class="hljs-number">5.00000000</span>       <span class="hljs-number">100.000000</span>    <br>&gt;&gt;&gt;   <span class="hljs-number">5.00000000</span>       <span class="hljs-number">25.0000000</span><br></code></pre></td></tr></table></figure><h5 id="小提示-5"><a href="#小提示-5" class="headerlink" title="小提示"></a>小提示</h5><p>有的时候子程序中可能并不需要 module 中定义的所有全局变量，只想引入几个有关的全局变量。在 Fortran 语言中可以用 <code>only</code> 的语法来限定引入的全局变量，如下所示。</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs fortran"><span class="hljs-keyword">use</span> 模块名, <span class="hljs-keyword">only</span> : 变量<span class="hljs-number">1</span>, 变量<span class="hljs-number">2</span>, ...<br><span class="hljs-keyword">use</span> global, <span class="hljs-keyword">only</span> : yaxsis<br></code></pre></td></tr></table></figure><h2 id="混合嵌套调用"><a href="#混合嵌套调用" class="headerlink" title="混合嵌套调用"></a>混合嵌套调用</h2><p>一般地，子程序或者函数的参数都是一些来自主程序的局部变量，那么子程序中调用函数是否也需要在参数中进行声明呢？是的，子程序如果想要使用某个函数，需要将函数名作为参数引用。</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs fortran"><span class="hljs-comment">!!! 示例 10</span><br><span class="hljs-function"><span class="hljs-keyword">subroutine</span></span> subrout(subr, xmin, xmax, n)<br>    <span class="hljs-keyword">implicit</span> <span class="hljs-keyword">none</span><br>    <span class="hljs-keyword">real</span> xmin, xmax, dx, y<br>    <span class="hljs-keyword">integer</span> n, i<br>    dx = (xmax - xmin)/n<br>    <span class="hljs-keyword">do</span> i = <span class="hljs-number">0</span>, n<br>        <span class="hljs-keyword">call</span> subr(dx*i+xmin, y)<br>        <span class="hljs-built_in">print</span> *, i, y<br>    <span class="hljs-keyword">enddo</span><br><span class="hljs-keyword">end</span> <span class="hljs-function"><span class="hljs-keyword">subroutine</span></span> subrout<br><br><span class="hljs-function"><span class="hljs-keyword">subroutine</span></span> funcout(fun, xmin, xmax, n)<br>    <span class="hljs-keyword">implicit</span> <span class="hljs-keyword">none</span><br>    <span class="hljs-keyword">real</span> fun, xmin, xmax, x, dx, y<br>    <span class="hljs-keyword">integer</span> n, i<br>    dx = (xmax-xmin)/n<br>    <span class="hljs-keyword">do</span> i = <span class="hljs-number">0</span>, n<br>        x = dx*i + xmin<br>        y = func(x)**<span class="hljs-number">3</span><br>        <span class="hljs-built_in">print</span> *, x, y<br>    <span class="hljs-keyword">enddo</span><br><span class="hljs-keyword">end</span> <span class="hljs-function"><span class="hljs-keyword">subroutine</span></span> funcout<br><br><span class="hljs-function"><span class="hljs-keyword">subroutine</span></span> sub(x, y)<br>    <span class="hljs-keyword">implicit</span> <span class="hljs-keyword">none</span><br>    <span class="hljs-keyword">real</span> y, x<br>    y = <span class="hljs-number">2</span>*<span class="hljs-built_in">sin</span>(x) + <span class="hljs-built_in">cos</span>(x**<span class="hljs-number">2</span>)<br><span class="hljs-keyword">end</span> <span class="hljs-function"><span class="hljs-keyword">subroutine</span></span> sub<br><br><span class="hljs-function"><span class="hljs-keyword">function</span></span> fun(x)<br>    <span class="hljs-keyword">implicit</span> <span class="hljs-keyword">none</span><br>    <span class="hljs-keyword">real</span> fun, x<br>    fun = <span class="hljs-built_in">sin</span>(x)**<span class="hljs-number">3</span><br><span class="hljs-keyword">end</span> <span class="hljs-function"><span class="hljs-keyword">function</span></span> fun<br><br><span class="hljs-function"><span class="hljs-keyword">program</span></span> test_func<br>    <span class="hljs-keyword">implicit</span> <span class="hljs-keyword">none</span><br>    <span class="hljs-keyword">real</span>, <span class="hljs-keyword">external</span> :: fun<br>    <span class="hljs-keyword">external</span> sub<br>    <span class="hljs-keyword">call</span> subrout(sub, <span class="hljs-number">0.0</span>, <span class="hljs-number">3.0</span>, <span class="hljs-number">10</span>)<br>    <span class="hljs-keyword">call</span> funcout(fun, <span class="hljs-number">0.0</span>, <span class="hljs-number">3.0</span>, <span class="hljs-number">10</span>)<br><span class="hljs-keyword">end</span> <span class="hljs-function"><span class="hljs-keyword">program</span></span> test_func<br><br><span class="hljs-comment">!!! 执行结果</span><br>&gt;&gt;&gt;        <span class="hljs-number">0</span>   <span class="hljs-number">1.00000000</span>    <br>           <span class="hljs-number">1</span>   <span class="hljs-number">1.58699322</span>    <br>           <span class="hljs-number">2</span>   <span class="hljs-number">2.06518173</span>    <br>           <span class="hljs-number">3</span>   <span class="hljs-number">2.25615215</span>    <br>           <span class="hljs-number">4</span>   <span class="hljs-number">1.99450183</span>    <br>           <span class="hljs-number">5</span>   <span class="hljs-number">1.36681640</span>    <br>           <span class="hljs-number">6</span>  <span class="hljs-number">0.952533364</span>    <br>           <span class="hljs-number">7</span>   <span class="hljs-number">1.42861772</span>    <br>           <span class="hljs-number">8</span>   <span class="hljs-number">2.21715832</span>    <br>           <span class="hljs-number">9</span>   <span class="hljs-number">1.38931477</span>    <br>          <span class="hljs-number">10</span> -<span class="hljs-number">0.628890276</span>    <br>   <span class="hljs-number">0.00000000</span>       <span class="hljs-number">0.00000000</span>    <br>  <span class="hljs-number">0.300000012</span>       <span class="hljs-number">1.71903503E-05</span><br>  <span class="hljs-number">0.600000024</span>       <span class="hljs-number">5.83394058E-03</span><br>  <span class="hljs-number">0.900000036</span>      <span class="hljs-number">0.111042053</span>    <br>   <span class="hljs-number">1.20000005</span>      <span class="hljs-number">0.530770957</span>    <br>   <span class="hljs-number">1.50000000</span>      <span class="hljs-number">0.977679431</span>    <br>   <span class="hljs-number">1.80000007</span>      <span class="hljs-number">0.787805617</span>    <br>   <span class="hljs-number">2.10000014</span>      <span class="hljs-number">0.266100109</span>    <br>   <span class="hljs-number">2.40000010</span>       <span class="hljs-number">2.92694476E-02</span><br>   <span class="hljs-number">2.70000005</span>       <span class="hljs-number">4.75692534E-04</span><br>   <span class="hljs-number">3.00000000</span>       <span class="hljs-number">2.21971472E-08</span><br></code></pre></td></tr></table></figure><p>上面的示例 10 是子程序和函数副程序的混合嵌套使用的一个范例，上述代码的主要结构如下所示：在主程序 <code>test_func</code> 中调用子程序 <code>subrout</code> 和 <code>funcout</code>，再由子程序 <code>subrout</code> 调用子程序 <code>sub</code> 以及子程序 <code>funcout</code> 调用函数副程序 <code>fun</code>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">test_func（主程序）<br>├── subrout（子程序）<br>│   └── sub（子程序）<br>└── funcout（子程序）<br>    └── fun（函数副程序）<br></code></pre></td></tr></table></figure><h5 id="小提示-6"><a href="#小提示-6" class="headerlink" title="小提示"></a>小提示</h5><p>这里比较重要的是，在主程序中需要对递归调用的子程序和函数副程序进行声明。主程序中的递归子程序调用声明只需要 <code>external</code> 加上子程序名即可，而主程序中的递归函数副程序调用声明需要同时定义函数变量和函数名，因此写为 <code>real, external ::</code> 加上函数副程序名。</p><p>当然在直接调用函数副程序 <code>fun</code> 的子程序 <code>funcout</code> 中也需要定义函数同名变量，写为 <code>real fun</code>。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Fortran</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Fortran-条件与循环语句</title>
    <link href="/2022/05/23/Fortran-%E6%9D%A1%E4%BB%B6%E4%B8%8E%E5%BE%AA%E7%8E%AF%E8%AF%AD%E5%8F%A5/"/>
    <url>/2022/05/23/Fortran-%E6%9D%A1%E4%BB%B6%E4%B8%8E%E5%BE%AA%E7%8E%AF%E8%AF%AD%E5%8F%A5/</url>
    
    <content type="html"><![CDATA[<h2 id="循环语句"><a href="#循环语句" class="headerlink" title="循环语句"></a>循环语句</h2><p>Fortran 语言中的循环语句与其他高级编程语言中的 For 循环、while 循环有点类似，但也略有不同。</p><h3 id="do-循环"><a href="#do-循环" class="headerlink" title="do 循环"></a>do 循环</h3><p>Fortran 的最简单的循环语句称为 do 语句，其形式如下所示：</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs fortran"><span class="hljs-comment">!!! 不设置步长，默认为 1</span><br><span class="hljs-keyword">do</span> 整数型变量 = 起始值, 结束值<br>    ......<br>    ......<br><span class="hljs-keyword">enddo</span> <br></code></pre></td></tr></table></figure><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs fortran"><span class="hljs-comment">!!! 示例 1</span><br><span class="hljs-keyword">integer</span> a(<span class="hljs-number">10</span>)<br><span class="hljs-keyword">do</span> n = <span class="hljs-number">1</span>, <span class="hljs-number">10</span>      <span class="hljs-comment">! 计算 1，2，3，4，5，6，7，8，9，10</span><br>    a(n) = n<br><span class="hljs-keyword">enddo</span><br><br><span class="hljs-comment">!!! 设置步长，可以设置正整数和负整数，不能为 0</span><br><span class="hljs-keyword">do</span> 整数型变量 = 初始值, 结束值, 步长<br>    ......<br>    ......<br><span class="hljs-keyword">enddo</span><br><br><span class="hljs-comment">!!! 示例 2</span><br><span class="hljs-keyword">integer</span> a(<span class="hljs-number">5</span>)<br><span class="hljs-keyword">do</span> n = <span class="hljs-number">1</span>, <span class="hljs-number">10</span>, <span class="hljs-number">2</span>   <span class="hljs-comment">! 计算 1，3，5，7，9</span><br>    a(<span class="hljs-built_in">nint</span>(n/<span class="hljs-number">2</span>)) = n<br><span class="hljs-keyword">enddo</span><br><br><span class="hljs-comment">!!! 示例 3</span><br><span class="hljs-keyword">integer</span> a(<span class="hljs-number">5</span>)<br><span class="hljs-keyword">do</span> n = <span class="hljs-number">10</span>, <span class="hljs-number">1</span>, -<span class="hljs-number">2</span>   <span class="hljs-comment">! 计算 10，8，6，4，2</span><br>    a(n/<span class="hljs-number">2</span>) = n<br><span class="hljs-keyword">enddo</span><br></code></pre></td></tr></table></figure><h5 id="小提示"><a href="#小提示" class="headerlink" title="小提示"></a>小提示</h5><p>在使用 do 循环语句的时候，我们需要注意在<strong>结束循环语句后循环条件变量 n 仍然存在</strong>。如果后续计算中还<strong>使用到了相同变量，务必要进行重新初始化赋值</strong>，否则可能造成数据上的污染。我们可以拿示例 3 举个例子，当循环结束后，n 的值其实为 0 (不是 2)。虽然此时的 n 值并不满足循环继续的条件，但是已经完成了对步长的迭代计算，所以如果后续还是使用相同的变量 n，我们期待的 n 初始值与循环结束后的 n 值就可能不一样。<strong>建议在将某个变量设置为循环条件变量之后，循环外尽量不要使用同一个变量</strong>，从而避免这一可能存在的干扰。</p><p>do 循环语句实际上也<strong>可以存在嵌套，即一个 do 循环语句包含了其他的 do 循环语句</strong>，如下示例 4 所示。其中需要注意的是，在多重 do 循环语句中，循环语句的<strong>条件变量不要使用相同的</strong>，否则很可能出现了我们意料之外的问题。建议同一个 do 循环嵌套语句中使用不同的条件变量。如果不在同一个 do 循环嵌套语句中，使用相同的条件变量产生问题的可能性比较小。</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs fortran"><span class="hljs-comment">!!! 示例 4</span><br><span class="hljs-keyword">integer</span> a(<span class="hljs-number">10</span>)<br><span class="hljs-keyword">integer</span> b(<span class="hljs-number">10</span>, <span class="hljs-number">5</span>)<br><span class="hljs-keyword">do</span> n = <span class="hljs-number">1</span>, <span class="hljs-number">10</span><br>    a(n) = n<br>    <span class="hljs-keyword">do</span> m = <span class="hljs-number">1</span>, <span class="hljs-number">10</span>, <span class="hljs-number">2</span><br>        b(n, <span class="hljs-built_in">nint</span>(m/<span class="hljs-number">2</span>)) = a(n) + m<br>    <span class="hljs-keyword">enddo</span><br><span class="hljs-keyword">enddo</span><br></code></pre></td></tr></table></figure><h5 id="小提示-1"><a href="#小提示-1" class="headerlink" title="小提示"></a>小提示</h5><p>其实在 do 循环中所指定的条件变量的初始值、结束值及步长也可以用已有值的变量来代替，如下所示。</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs fortran"><span class="hljs-keyword">integer</span> m, <span class="hljs-built_in">sum</span><br>m = <span class="hljs-number">10</span><br><span class="hljs-built_in">sum</span> = <span class="hljs-number">0</span><br><span class="hljs-keyword">do</span> n = <span class="hljs-number">1</span>, m<br>    <span class="hljs-built_in">sum</span> = <span class="hljs-built_in">sum</span> + n<br><span class="hljs-keyword">enddo</span><br></code></pre></td></tr></table></figure><h3 id="while-循环"><a href="#while-循环" class="headerlink" title="while 循环"></a>while 循环</h3><p>通过上面的内容，不难发现上述的 do 循环确实看起来有点像 C、C++ 中的 For 循环，那么 Fortran 语言中是否也存在 while 循环呢？答案是<strong>当然了</strong>，其形式如下所示。</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs fortran"><span class="hljs-keyword">do</span> <span class="hljs-keyword">while</span> (条件)<br>   ......<br>    ......<br><span class="hljs-keyword">enddo</span><br></code></pre></td></tr></table></figure><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs fortran"><span class="hljs-comment">!!! 示例 5</span><br><span class="hljs-comment">!!! 计算并输出 10，9，8，7，6，5，4，3，2，1 的平方</span><br><span class="hljs-keyword">integer</span> n<br>n = <span class="hljs-number">10</span><br><span class="hljs-keyword">do</span> <span class="hljs-keyword">while</span> (n &gt; <span class="hljs-number">0</span>)   <br>    <span class="hljs-built_in">print</span> *, n**<span class="hljs-number">2</span><br>    n = n - <span class="hljs-number">1</span><br><span class="hljs-keyword">enddo</span><br></code></pre></td></tr></table></figure><p>我们可以从示例 5 中发现，while 循环其实就是变化后的 do 循环。do 循环中判断条件紧跟着 do 字符串，当符合条件时进入循环体内部继续执行，否则跳出循环。while 循环中将 do 循环的初始值放置在了循环语句的前面进行声明，while 循环的条件中只有对于结束值的声明，而原来 do 循环的步长自增或自减操作则放置在了循环体中。这里有一点不同的是，如果自增或自减语句被放置在循环体的第一行，那么最后的执行结果就与 do 循环的不一致了。这是因为 <strong>do 循环实际上是在循环体执行完成后执行的步长自增或自减操作，而 while 循环中则可以自行设置自增或自减操作在循环体中的位置</strong>。</p><h2 id="条件语句"><a href="#条件语句" class="headerlink" title="条件语句"></a>条件语句</h2><p>Fortran 语言中的条件语句可以分为<strong>有条件</strong>和<strong>无条件</strong>两种。我们所熟知的 if 语句就是有条件的，而无条件的则是类似于汇编语言的 goto 语句、exit 语句、cycle 语句，甚至还有无条件 do 循环语句。</p><h3 id="if-语句"><a href="#if-语句" class="headerlink" title="if 语句"></a>if 语句</h3><p>if 语句最简单的方式就是，将条件判断语句与执行语句放在同一行，如下所示。这也是因为执行语句比较短，放置在同一行反而代码更加美观。当然一般来说执行语句可能不是一行，甚至是多分支、多重的，因此也有单分支 if 语句、双分支 if 语句、多重 if 语句，如下所示。</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs fortran"><span class="hljs-comment">!!! 最简单的 if 语句</span><br><span class="hljs-keyword">if</span> (条件) 执行语句<br><br></code></pre></td></tr></table></figure><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs fortran"><span class="hljs-comment">!!! 示例 6</span><br><span class="hljs-keyword">integer</span> n<br><span class="hljs-keyword">integer</span> i<br>n = <span class="hljs-number">10</span><br>i = -<span class="hljs-number">4</span><br><span class="hljs-keyword">if</span> (i &lt; <span class="hljs-number">0</span>) n = <span class="hljs-number">5</span><br><span class="hljs-built_in">print</span> *, n<br><br><br><span class="hljs-comment">!!! 单分支 if 语句</span><br><span class="hljs-keyword">if</span> (条件) <span class="hljs-keyword">then</span><br>    ......<br>    ......<br><span class="hljs-keyword">endif</span><br><br><span class="hljs-comment">!!! 示例 7</span><br><span class="hljs-keyword">if</span> (i &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">then</span><br>    n = <span class="hljs-number">5</span><br><span class="hljs-keyword">endif</span><br><span class="hljs-built_in">print</span> *, n<br><br><br><span class="hljs-comment">!!! 双分支 if 语句 (一般)</span><br><span class="hljs-keyword">if</span> (条件) <span class="hljs-keyword">then</span><br>    ......<br><span class="hljs-keyword">else</span><br>    ......<br><span class="hljs-keyword">endif</span><br><br><span class="hljs-comment">!!! 示例 8</span><br><span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span>) <span class="hljs-keyword">then</span><br>    n = <span class="hljs-number">8</span><br><span class="hljs-keyword">else</span><br>    n = <span class="hljs-number">5</span><br><span class="hljs-keyword">endif</span><br><span class="hljs-built_in">print</span> *, n<br><br><br><span class="hljs-comment">!!! 多重 if 语句</span><br><span class="hljs-keyword">if</span> (条件 <span class="hljs-number">1</span>) <span class="hljs-keyword">then</span><br>    .....<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (条件 <span class="hljs-number">2</span>) <span class="hljs-keyword">then</span><br>        ......<br>    <span class="hljs-keyword">else</span><br>        .....<br>    <span class="hljs-keyword">endif</span><br><span class="hljs-keyword">endif</span><br><br><span class="hljs-comment">!!! 示例 9</span><br><span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span>) <span class="hljs-keyword">then</span><br>    n = <span class="hljs-number">8</span><br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (i &gt; -<span class="hljs-number">2</span>) <span class="hljs-keyword">then</span><br>        n = <span class="hljs-number">6</span><br>    <span class="hljs-keyword">else</span><br>        n = <span class="hljs-number">5</span><br>    <span class="hljs-keyword">endif</span><br><span class="hljs-keyword">endif</span><br><span class="hljs-built_in">print</span> *, n<br></code></pre></td></tr></table></figure><p>在使用条件语句对条件变量进行比较判断时，除了我们常用的 <code>&gt;</code>、<code>&lt;</code> 之外，也有其他比较符号可以使用，如下表所示。</p><table><thead><tr><th>比较条件符号</th><th>含义</th><th>示例</th></tr></thead><tbody><tr><td>&#x3D;&#x3D;</td><td>左边等于右边</td><td>n &#x3D;&#x3D; 10</td></tr><tr><td>&#x2F;&#x3D;</td><td>左边不等于右边</td><td>n &#x2F;&#x3D; 10</td></tr><tr><td>&gt;</td><td>左边大于右边</td><td>n &gt; 10</td></tr><tr><td>&gt;&#x3D;</td><td>左边大于或等于右边</td><td>n &gt;&#x3D;10</td></tr><tr><td>&lt;</td><td>左边小于右边</td><td>n &lt; 10</td></tr><tr><td>&lt;&#x3D;</td><td>左边小于或等于右边</td><td>n &lt;&#x3D; 10</td></tr></tbody></table><h5 id="小提示-2"><a href="#小提示-2" class="headerlink" title="小提示"></a>小提示</h5><p>这里需要注意一点，如果我们想要**比较左右两边是否相等，不是使用 <code>=</code>，而是使用 <code>==</code>**。其实这一点也比较容易理解，<code>=</code> 的含义是将等号右边的值或者计算结果赋值给左边的变量，为了加以区分，比较左右两边时则使用 <code>==</code>。另外，根据使用其他高级编程语言的经验来看，<code>==</code> 是恒等于的意思，即左右两边不仅值相等、类型也相等，这不正是最稳妥的比较是否相等的方式吗？</p><p>当我们使用条件语句的时候还有一类使用场景，就是<strong>判断一个变量值是否在一个区间，即存在一个下限值和一个上限值</strong>。如果使用我们上述的 if 语句恐怕只有多重 if 语句才能满足我们的需求了，但是这代码写起来可能有点显得多余，毕竟我们在逻辑上是想要同时判断变量值与上下限值的大小。所以 Fortran 语言的 if 语句中也**存在逻辑运算符 <code>.and.</code>、<code>.or.</code> 和 <code>.not.</code>**，具体如下表所示。</p><table><thead><tr><th>逻辑运算符</th><th>含义</th></tr></thead><tbody><tr><td>条件 1 .and. 条件 2</td><td>同时满足条件 1 和条件 2</td></tr><tr><td>条件 1 .or. 条件 2</td><td>满足条件 1 和条件 2 之一即可</td></tr><tr><td>.not. 条件</td><td>不满足条件，即满足条件的相反条件</td></tr></tbody></table><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs fortran"><span class="hljs-comment">!!! 示例 10</span><br><span class="hljs-keyword">if</span> (i &lt; <span class="hljs-number">0</span> .and. i &gt; -<span class="hljs-number">2</span>) <span class="hljs-keyword">then</span><br>    n = <span class="hljs-number">5</span><br><span class="hljs-keyword">else</span><br>    n = <span class="hljs-number">10</span><br><span class="hljs-keyword">endif</span><br></code></pre></td></tr></table></figure><h5 id="小提示-3"><a href="#小提示-3" class="headerlink" title="小提示"></a>小提示</h5><p>我们在其他高级编程语言中可能已经习惯了类似于 <strong><code>-2 &lt; n &lt; 0</code> <strong>这样的写法，有的时候在 Fortran 语言中也会不自觉地写成这样。但是在 Fortran 语言中这种</strong>写法是不被支持的</strong>，我们需要使用逻辑运算符 <code>.and.</code> 来把上下限值判断连接起来，而不能写在一起。</p><h2 id="无条件语句"><a href="#无条件语句" class="headerlink" title="无条件语句"></a>无条件语句</h2><p>无条件语句一般来说与条件语句的作用是不相同的，主要是为了程序可以跳转、中途退出，但也有类似于 do 循环这样的，只不过还是需要 if 语句来帮助完成跳出循环的判断。<strong>无条件语句有 goto 语句、exit 语句、 cycle 语句三种</strong>。</p><h3 id="goto-语句"><a href="#goto-语句" class="headerlink" title="goto 语句"></a>goto 语句</h3><p>如下所示，这里的 goto 语句的用法与汇编语言的 goto 语句有点类似，<strong>指定一个行号即可无条件跳转到该行执行</strong>。如果是像下面这样<strong>调用 goto 语句的行在跳转到的行之前，那么它们之间的行都会被完全忽略</strong>。如示例 11 所示，<code>a = 15</code> 的赋值语句会被忽略所以 a 的值是在 goto 语句执行之前赋的值 10；同理，<code>b = 11</code> 的赋值语句在 goto 语句和跳转行之间会被忽略，跳转行的 <code>b = 20</code> 生效。如示例 12 所示，当 goto 语句跳转到它之前行执行时，就会造成无限循环，每次执行到 goto 语句就会又跳转到前面，这样 goto 语句后面的命令都不会被执行。</p><h5 id="小提示-4"><a href="#小提示-4" class="headerlink" title="小提示"></a>小提示</h5><p>我们在使用 goto 语句时对跳转的行一定要非常注意，一不小心很容易造成死循环。建议使用 goto 语句的时候跳转到其后的行，杜绝跳转到前面的行。</p><p>为了提高代码可读性，我们<strong>不想将 goto 语句跳转的行直接指向一个操作或者命令，这时我们就可以用 continue 来代替跳转行</strong>，如示例 13 所示。</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs fortran"><span class="hljs-keyword">goto</span> 行号<br><br>行号 操作或命令<br><br><span class="hljs-comment">!!! 示例 11</span><br>   a = <span class="hljs-number">10</span><br>   <span class="hljs-keyword">goto</span> <span class="hljs-number">8</span><br>   b = <span class="hljs-number">11</span><br>   a = <span class="hljs-number">15</span><br><span class="hljs-number">8</span>  b = <span class="hljs-number">20</span><br>   <span class="hljs-built_in">print</span> *, a, b  <span class="hljs-comment">! 此处输出 a 的值为 10，b 的值为 20</span><br><br><span class="hljs-comment">!!! 示例 12</span><br><br><span class="hljs-number">8</span> a = <span class="hljs-number">10</span><br>  b = <span class="hljs-number">11</span><br>  a = a + b<br>  <span class="hljs-keyword">goto</span> <span class="hljs-number">8</span><br>  b = b - a       <span class="hljs-comment">! 永远不会被执行</span><br>  <span class="hljs-built_in">print</span> *, a, b   <span class="hljs-comment">! 永远不会被执行</span><br><br><span class="hljs-comment">!!! 示例 13</span><br><span class="hljs-number">8</span> <span class="hljs-keyword">continue</span><br>  a = <span class="hljs-number">10</span><br>  b = <span class="hljs-number">11</span><br>  a = a + b<br>  <span class="hljs-keyword">goto</span> <span class="hljs-number">8</span><br></code></pre></td></tr></table></figure><h3 id="exit-语句"><a href="#exit-语句" class="headerlink" title="exit 语句"></a>exit 语句</h3><p>当我们在使用 do 循环语句时，如果<strong>想要在某个与循环条件无关的条件满足时提前退出循环，就要使用 if 语句和 exit 语句的组合</strong>了。如示例 14 所示，当 sum 的值超过 10 时循环就会被提前终止。由于 <code>1+2+3+4=10</code>，所以 i 加到 5 才会使得 sum 值超过 10，此时的 sum 则为 <code>1+2+3+4+5=15</code>，而 i 也因为提前退出循环而不会执行自增操作，所以此时输出的 i 值为最后的 5。如果将原来的 exit 语句换成 goto 语句，并将 goto 语句指向的跳转行设为循环外的下一行，则最后的效果也是一样的，如示例 15 所示。</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs fortran"><span class="hljs-comment">!!! 示例 14</span><br><span class="hljs-built_in">sum</span> = <span class="hljs-number">0</span><br><span class="hljs-keyword">do</span> i = <span class="hljs-number">1</span>, <span class="hljs-number">10</span><br>    <span class="hljs-built_in">sum</span> = <span class="hljs-built_in">sum</span> + i<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">sum</span> &gt; <span class="hljs-number">10</span>) <span class="hljs-keyword">exit</span><br><span class="hljs-keyword">enddo</span><br><span class="hljs-built_in">print</span> *, i, <span class="hljs-built_in">sum</span>      <span class="hljs-comment">! 输出 i 的值为 5，sum 的值为 15</span><br><br><span class="hljs-comment">!!! 示例 15</span><br>    <span class="hljs-built_in">sum</span> = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">do</span> i = <span class="hljs-number">1</span>, <span class="hljs-number">10</span><br>        <span class="hljs-built_in">sum</span> = <span class="hljs-built_in">sum</span> + i<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">sum</span> &gt; <span class="hljs-number">10</span>) <span class="hljs-keyword">goto</span> <span class="hljs-number">8</span><br>    <span class="hljs-keyword">enddo</span><br><span class="hljs-number">8</span>   <span class="hljs-built_in">print</span> *, i, <span class="hljs-built_in">sum</span>  <span class="hljs-comment">! 输出 i 的值仍为 5，sum 的值仍为 15</span><br></code></pre></td></tr></table></figure><h3 id="cycle-语句"><a href="#cycle-语句" class="headerlink" title="cycle 语句"></a>cycle 语句</h3><p>cycle 语句与 exit 语句正好表示了<strong>相反</strong>的意思，它指示程序在<strong>满足条件时继续执行循环、不满足条件时跳出循环</strong>。如示例 16 所示，这个 cycle 语句的效果与示例 14、15 的完全一致。</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs fortran"><span class="hljs-comment">!!! 示例 16</span><br><span class="hljs-built_in">sum</span> = <span class="hljs-number">0</span><br><span class="hljs-keyword">do</span> i = <span class="hljs-number">1</span>, <span class="hljs-number">10</span><br>    <span class="hljs-built_in">sum</span> = <span class="hljs-built_in">sum</span> + i<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">sum</span> &lt;= <span class="hljs-number">10</span>) <span class="hljs-keyword">cycle</span><br><span class="hljs-keyword">enddo</span><br><span class="hljs-built_in">print</span> *, i, <span class="hljs-built_in">sum</span>      <span class="hljs-comment">! 输出 i 的值仍为 5，sum 的值仍为 15</span><br></code></pre></td></tr></table></figure><p>Copy</p><h3 id="多重循环下的-exit-与-goto-语句"><a href="#多重循环下的-exit-与-goto-语句" class="headerlink" title="多重循环下的 exit 与 goto 语句"></a>多重循环下的 exit 与 goto 语句</h3><p>一般来说在复杂的行列式计算中经常会遇到多重循环，这与以上 goto 和 exit 语句的场景稍显不同。goto 语句的跳转行因为可以指定任何一行，所以不会被多重循环影响，可以直接跳转到多重循环之外或者某一重循环之中的某一行，如示例 17 所示。而<strong>exit 语句如果还是按照上面的用法每次只能退出一重循环，碰到需要同时退出多重循环时就比较麻烦</strong>。所以 Fortran 语言为了尽量避免这一问题，就给 exit 语句添加一种**类似于 goto 语句指示跳转行的方法 <code>exit out</code>**，如示例 18 所示。</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs fortran"><span class="hljs-comment">!!! 示例 17</span><br>    <span class="hljs-built_in">sum</span> = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">do</span> i = <span class="hljs-number">1</span>, <span class="hljs-number">10</span><br>        <span class="hljs-keyword">do</span> j = <span class="hljs-number">1</span>, <span class="hljs-number">10</span><br>            <span class="hljs-built_in">sum</span> = <span class="hljs-built_in">sum</span> + i + j<br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">sum</span> &gt; <span class="hljs-number">10</span>) go <span class="hljs-number">10</span><br>        <span class="hljs-keyword">enddo</span><br>    <span class="hljs-keyword">enddo</span><br><span class="hljs-number">10</span>  <span class="hljs-built_in">print</span> *, i, j, <span class="hljs-built_in">sum</span>   <span class="hljs-comment">! 输出 i 的值为 1，j 的值为 4，sum 的值为 11</span><br><br><span class="hljs-comment">!!! 示例 18</span><br><span class="hljs-built_in">sum</span> = <span class="hljs-number">0</span><br><span class="hljs-keyword">out</span>: <span class="hljs-keyword">do</span> i = <span class="hljs-number">1</span>, <span class="hljs-number">10</span><br>        <span class="hljs-keyword">do</span> j = <span class="hljs-number">1</span>, <span class="hljs-number">10</span><br>            <span class="hljs-built_in">sum</span> = <span class="hljs-built_in">sum</span> + i + j<br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">sum</span> &gt; <span class="hljs-number">10</span>) <span class="hljs-keyword">exit</span> <span class="hljs-keyword">out</span><br>        <span class="hljs-keyword">enddo</span><br>     <span class="hljs-keyword">enddo</span> <span class="hljs-keyword">out</span><br><span class="hljs-built_in">print</span> *, i, j, <span class="hljs-built_in">sum</span>       <span class="hljs-comment">! 输出 i 的值为 1，j 的值为 4，sum 的值为 11 </span><br></code></pre></td></tr></table></figure><h5 id="小提示-5"><a href="#小提示-5" class="headerlink" title="小提示"></a>小提示</h5><p>这里需要注意的是，<strong>当使用 <code>exit out</code> 方法时，out 是对应于循环的一个别名，需要同时在 do 前和 enddo 后添加 out 的声明</strong>。当然，这里的别名也可以使用其他符合规则的字符串，只要不与同一个代码文件中的其他别名或变量名等相同即可。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Fortran</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Fortran 基础知识</title>
    <link href="/2022/05/23/Fortran-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    <url>/2022/05/23/Fortran-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
    
    <content type="html"><![CDATA[<h2 id="主函数"><a href="#主函数" class="headerlink" title="主函数"></a>主函数</h2><p>一个完整的Fortran代码，一般来说，<strong>以 <code>program code_name</code> 开始，以 <code>end program code_name</code> 结束的首末声明</strong>，<strong>变量声明</strong>以及<strong>需要执行的命令或者操作</strong>三个部分组成。通用的 Fortran 代码文件的文件后缀可以是 <code>.f90</code>、<code>.f</code>、<code>.g95</code> 等等，但通常为了统一和适应不同版本的 Fortran 编译环境<strong>建议采用 <code>.f90</code> 后缀</strong>。和 C、C++ 语言比较类似，Fortran 代码也是通过编译执行。比如对如下所示的示例代码执行 **<code>gfortran code_name.f90 -o code_name</code> **即可生成可执行程序 <code>code_name</code>，再执行 **<code>./code_name</code> **则会输出代码执行结果如下。</p><p>code_name.f90</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs fortran"><span class="hljs-function"><span class="hljs-keyword">program</span></span> code_name<br>    <span class="hljs-keyword">implicit</span> <span class="hljs-keyword">none</span><br>    <span class="hljs-keyword">real</span> x, y, z<br>    x = <span class="hljs-number">2</span><br>    y = <span class="hljs-number">3</span><br>    z = x + y * <span class="hljs-number">5</span><br>    <span class="hljs-built_in">print</span> *, x, y<br>    <span class="hljs-built_in">print</span> *, <span class="hljs-string">&#x27;z = &#x27;</span>, z <br><span class="hljs-keyword">end</span> <span class="hljs-function"><span class="hljs-keyword">program</span></span> code_name<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">  2.00000000       3.00000000    <br>z =    17.0000000<br></code></pre></td></tr></table></figure><p>上面给出的示例代码中有一行 <code>implicit none</code>，明明本来的代码已经符合三个部分了，为什么要多加这一行呢？这是因为在旧 Fortran 中存在隐式类型声明，为了规避在 Fortran 95 以后的版本中可能出现错误，特意在每个开头声明之后都加上这么一行。这样我们在写代码的过程中如果使用到了未提前声明或者打错字符的变量名，编译程序就会报错告知我们。这对于形成良好的代码习惯和增强代码可维护性有很大的帮助，因此此行声明必不可少。</p><h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><p>Fortran 语言和别的高级编程语言一样，都拥有完整的运算符，包括简单的加减乘除、复杂的乘方等运算。如下表所示是 Fortran 语言中的运算符的写法和使用方法，其中运算符的计算优先顺序与数学计算中一致：<strong>乘方运算 &gt; 乘除运算 &gt; 加减运算</strong>。</p><h2 id="数据类型与变量声明"><a href="#数据类型与变量声明" class="headerlink" title="数据类型与变量声明"></a>数据类型与变量声明</h2><p>Fortran 语言的数据类型比较简单，没有像其他高级编程语言那样分得那么细，主要分为<strong>整数型</strong>和<strong>实数型</strong>两个大类。整数型的计算与 C、C++、Python 中有点类似，整数与整数的商还是一个整数。<strong>即使当不整除的时候，为了保持结果和参与运算的变量类型一致 Fortran 编译器会只取正常数学运算结果的整数部分</strong>。实数型其实与数学意义上的实数是一致的，既<strong>包括整数也包括小数</strong>，所以当不整除的除法中的两个变量<strong>有一个为实数型</strong>时，Fortran 编译器会将两个变量类型对应成实数型并<strong>计算出正常的带小数的结果</strong>。</p><p><strong>所有变量都要在使用之前声明类型</strong>，所以<strong>当属于同一种类型时我们可以按照下面那样写在同一行</strong>，不同变量之间用逗号分隔开。为了代码美观，<strong>建议在逗号与后一个变量名之间留一个空格</strong>。</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs fortran"><span class="hljs-comment">!!! 两个整数型相除</span><br><span class="hljs-keyword">integer</span> x, y<br>x = <span class="hljs-number">2</span><br>y = <span class="hljs-number">3</span><br><span class="hljs-built_in">print</span> *, x/y   <span class="hljs-comment">! 结果为 0</span><br><span class="hljs-built_in">print</span> *, y/x   <span class="hljs-comment">! 结果为 1</span><br><br><span class="hljs-comment">!!! 被除数为实数型，除数为整数型</span><br><span class="hljs-keyword">real</span> m <br><span class="hljs-keyword">integer</span> n <br>m = <span class="hljs-number">10</span><br>n = <span class="hljs-number">3</span><br><span class="hljs-built_in">print</span> *, m/n   <span class="hljs-comment">! 结果为  3.33333325</span><br><br><span class="hljs-comment">!!! 被除数为整数型，除数为实数型</span><br><span class="hljs-keyword">integer</span> m <br><span class="hljs-keyword">real</span> n <br>m = <span class="hljs-number">10</span><br>n = <span class="hljs-number">3</span><br><span class="hljs-built_in">print</span> *, m/n   <span class="hljs-comment">! 结果为  3.33333325</span><br><br><span class="hljs-comment">!!! 被除数和除数均为实数型</span><br><span class="hljs-keyword">real</span> m, n<br>m = <span class="hljs-number">10</span><br>n = <span class="hljs-number">3</span><br><span class="hljs-built_in">print</span> *, m/n   <span class="hljs-comment">! 结果为  3.33333325</span><br></code></pre></td></tr></table></figure><p>实际上，Fortran 语言除了整数型和实数型两个大类之外，还有一些小类，比如说<strong>复数类型、布尔类型、字符串类型</strong>。因为操作系统一般使用实数型或者复数类型时都<strong>默认采用单精度</strong>，如果需要使用双精度则需要特殊声明。所有数据类型总结如下：</p><table><thead><tr><th>数据类型</th><th>标识符</th><th>示例</th></tr></thead><tbody><tr><td>整数型</td><td>integer</td><td>2</td></tr><tr><td>实数型</td><td>real</td><td>2.0</td></tr><tr><td>双精度实数型</td><td>double precision</td><td>2.0</td></tr><tr><td>复数型</td><td>complex</td><td>(1.0, 2.0)</td></tr><tr><td>双精度复数型</td><td>complex(kind(0d0))</td><td>(1.0, 2.0)</td></tr><tr><td>布尔型</td><td>logical</td><td>true&#x2F;false</td></tr><tr><td>字符串型</td><td>character</td><td>“Text”</td></tr></tbody></table><h5 id="小提示"><a href="#小提示" class="headerlink" title="小提示"></a>小提示</h5><p>这里有一点值得十分注意：一个 Fortran 文件的<strong>变量声明必须在最开始</strong>，如果多个变量声明行之间掺杂了其他的操作行或者命令行，则<strong>后续的变量声明将会无效</strong>，在编译的过程中就会直接报错。</p><h2 id="数学函数"><a href="#数学函数" class="headerlink" title="数学函数"></a>数学函数</h2><p>Fortran 既然是为数值计算而生的，那么自然就包含了对初等数学函数和数据类型变化函数的完整支持。如下表所示为有关初等数学函数的写法和用法。</p><table><thead><tr><th>写法</th><th>函数名称</th><th>数学表达</th><th>必要条件</th><th>函数值的范围</th></tr></thead><tbody><tr><td>sqrt(x)</td><td>平方根</td><td>\sqrt{x}<em>x</em></td><td>x \geqq 0<em>x</em>≧0</td><td></td></tr><tr><td>sin(x)</td><td>正弦函数</td><td>\sin xsin<em>x</em></td><td></td><td></td></tr><tr><td>cos(x)</td><td>余弦函数</td><td>\cos xcos<em>x</em></td><td></td><td></td></tr><tr><td>tan(x)</td><td>正切函数</td><td>\tan xtan<em>x</em></td><td></td><td></td></tr><tr><td>asin(x)</td><td>反正弦函数</td><td>\sin^{-1}xsin−1<em>x</em></td><td>-1\leqq x \leqq 1−1≦<em>x</em>≦1</td><td>-\frac{\pi}{2} \leqq f \leqq \frac{\pi}{2}−2<em>π</em>≦<em>f</em>≦2<em>π</em></td></tr><tr><td>acos(x)</td><td>反余弦函数</td><td>\cos^{-1}xcos−1<em>x</em></td><td>-1\leqq x \leqq 1−1≦<em>x</em>≦1</td><td>0 \leqq f \leqq \pi0≦<em>f</em>≦<em>π</em></td></tr><tr><td>atan(x)</td><td>反正切函数</td><td>\tan^{-1}xtan−1<em>x</em></td><td></td><td>-\frac{\pi}{2} &lt; f &lt; \frac{\pi}{2}−2<em>π</em>&lt;<em>f</em>&lt;2<em>π</em></td></tr><tr><td>atan2(y, x)</td><td>反正切函数</td><td>\tan^{-1}(y&#x2F;x)tan−1(<em>y</em>&#x2F;<em>x</em>)</td><td></td><td>-\pi &lt; f &lt; \pi−<em>π</em>&lt;<em>f</em>&lt;<em>π</em></td></tr><tr><td>exp(x)</td><td>指数函数</td><td>e^x<em>e**x</em></td><td></td><td></td></tr><tr><td>log(x)</td><td>对数函数</td><td>\log_{e}xlog<em>e**x</em></td><td>x &gt; 0<em>x</em>&gt;0</td><td></td></tr><tr><td>log10(x)</td><td>常用对数函数</td><td>\log_{10}xlog10<em>x</em></td><td>x &gt; 0<em>x</em>&gt;0</td><td></td></tr><tr><td>sinh(x)</td><td>双曲正弦函数</td><td>\sinh xsinh<em>x</em></td><td></td><td></td></tr><tr><td>cosh(x)</td><td>双曲余弦函数</td><td>\cosh xcosh<em>x</em></td><td></td><td></td></tr><tr><td>tanh(x)</td><td>双曲正切函数</td><td>\tanh xtanh<em>x</em></td><td></td><td></td></tr></tbody></table><p>下表为有关数据类型变化函数的写法和用法。</p><table><thead><tr><th>写法</th><th>函数名称</th><th>输入类型</th><th>输出类型</th><th>函数的含义</th></tr></thead><tbody><tr><td>real(n)</td><td>实数化</td><td>整数</td><td>实数</td><td>变成实数型</td></tr><tr><td>abs(n)</td><td>绝对值</td><td>整数</td><td>整数</td><td>n<em>n</em> 的绝对值</td></tr><tr><td>mod(m, n)</td><td>求余</td><td>2个整数</td><td>整数</td><td>m<em>m</em> 对 n<em>n</em> 求余</td></tr><tr><td>int(x)</td><td>整数化</td><td>实数</td><td>整数</td><td>变成整数型(去尾)</td></tr><tr><td>nint(x)</td><td>整数化</td><td>实数</td><td>整数</td><td>变成整数型(四舍五入)</td></tr><tr><td>sign(x, s)</td><td>符号变更</td><td>实数</td><td>实数</td><td>s \geqq 0, \lvert x \rvert; s &lt; 0, -\lvert x \rvert<em>s</em>≧0,∣<em>x</em>∣;<em>s</em>&lt;0,−∣<em>x</em>∣</td></tr><tr><td>abs(x)</td><td>绝对值</td><td>实数或复数</td><td>实数</td><td>x<em>x</em> 的绝对值</td></tr><tr><td>mod(x, y)</td><td>求余</td><td>2个实数</td><td>实数</td><td>x<em>x</em> 对 y<em>y</em> 求余</td></tr><tr><td>real(z)</td><td>复数的实部</td><td>复数</td><td>实数</td><td>z<em>z</em> 的实部</td></tr><tr><td>imag(z)</td><td>复数的虚部</td><td>复数</td><td>实数</td><td>z<em>z</em> 的虚部</td></tr><tr><td>cmplx(x, y)</td><td>复数化</td><td>两个实数</td><td>复数</td><td>x+iy<em>x</em>+<em>i**y</em></td></tr><tr><td>conjg(z)</td><td>共轭复数</td><td>复数</td><td>复数</td><td>z<em>z</em> 的共轭复数</td></tr></tbody></table><h2 id="打印输出"><a href="#打印输出" class="headerlink" title="打印输出"></a>打印输出</h2><p>Fortran 的打印输出其实已经在前面的示例代码中已经提到了，就是所谓的 <code>print</code> 语句。**<code>print</code> 语句必须紧接着 <code>*</code>**，其含义是按照标准格式输出，如果缺失这个的话在编译时就会报出 <code>Error: Expected comma in I/O list at (1)</code> 的错误。正确的打印输出示例代码如下：</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs fortran"><span class="hljs-keyword">integer</span> n<br>n = <span class="hljs-number">2</span><br><span class="hljs-built_in">print</span> *, <span class="hljs-number">1</span>+<span class="hljs-number">2</span>, n, n-<span class="hljs-number">1</span>, n/<span class="hljs-number">1</span>, n**<span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><p>输出结果如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">3           2           1           2           <br></code></pre></td></tr></table></figure><p>如果需要和其他高级编程语言那样<strong>在输出的过程中加入字符串到其中</strong>，则按如下设置：</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs fortran"><span class="hljs-keyword">real</span> m<br>m = <span class="hljs-number">5</span><br><span class="hljs-built_in">print</span> *, <span class="hljs-string">&#x27;m = &#x27;</span>, m, <span class="hljs-string">&#x27;  m*2 = &#x27;</span>, m*<span class="hljs-number">2</span><br><span class="hljs-built_in">print</span> *, <span class="hljs-string">&#x27;m = &#x27;</span>,m, <span class="hljs-string">&#x27;  m*2 = &#x27;</span>,m*<span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><p>输出结果如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">m =    5.00000000       m*2 =    10.0000000<br>m =    5.00000000       m*2 =    10.0000000<br></code></pre></td></tr></table></figure><p>根据以上输出结果我们可以看出，<code>m</code> 与 <code>=</code> 之间的一个空格与实际输出时是一致的，而输出变量 <code>m</code> 时不管与前一个逗号之间是否有空格，输出结果都不会发生改变，都存在超过一个以上的空格。实际上，这也是 Fortran 编译器为了能够区分输出内容，而特意在标准输出时对逗号分割的内容上添加这样的空格。不过为了代码阅读上的美观，建议在代码编写时还是保持变量与逗号之间的一个空格。</p><h5 id="小提示-1"><a href="#小提示-1" class="headerlink" title="小提示"></a>小提示</h5><p>这里输出字符串的时候引用字符串的符号**可以使用<code>&#39;</code>，也可以使用<code>&quot;</code>**。本质上没有什么区别，只是需要成对使用，不然就会报错。</p><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><h3 id="数组的定义"><a href="#数组的定义" class="headerlink" title="数组的定义"></a>数组的定义</h3><p>前面我们所介绍的有关数据类型基本上能够涵盖一般的日常使用，但是对于科研人员来说，矩阵、行列式等等才是计算过程中不可缺少的数据类型。为此，Fortran 也有了数组一样的数据类型来支持这一需求。如下所示，我们可以直接采用原有的整数型、实数型和复数型定义数组。<strong>当括号中只有一个数字时，表示是一维数组；当括号中有逗号分割的两个数字时，表示是二维数组；三维数组以此类推</strong>。二维数组可以用于表示我们所熟知的矩阵、行列式等数据类型。</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs fortran"><span class="hljs-keyword">integer</span> m(<span class="hljs-number">10</span>)         <span class="hljs-comment">! 长度为 10 的整数型数组</span><br><span class="hljs-keyword">real</span> x(<span class="hljs-number">20</span>), y(<span class="hljs-number">4</span>, <span class="hljs-number">5</span>)   <span class="hljs-comment">! 长度为 20 的实数型数组， 4 行 x 5 列的二维实数型数组</span><br><span class="hljs-keyword">complex</span> matrix(<span class="hljs-number">5</span>, <span class="hljs-number">5</span>)  <span class="hljs-comment">! 5 行 x 5 列的二维复数型数组</span><br></code></pre></td></tr></table></figure><h5 id="小提示-2"><a href="#小提示-2" class="headerlink" title="小提示"></a>小提示</h5><p>这里需要注意的是，在定义数组的时候<strong>不仅可以用正整数，也可以用负整数和 0</strong>。比如 <code>real n(-3:5)</code> 表示定义一个长度为 9、序号从 -3 到 5 (包括 0)的一维数组，<code>real m(-2:1, 0:4)</code> 表示定义一个 3 行 x 4 列、行序号从 -2 到 0、列序号从 1 到 4 的二维数组。一般来说，为了与实际数学运算中的理解保持一致，建议采用正整数来定义数组更加方便。</p><h3 id="数组元素的选取"><a href="#数组元素的选取" class="headerlink" title="数组元素的选取"></a>数组元素的选取</h3><p>既然定义了数组，那么我们就需要有对于数组的增加、选择这样的基本操作。<strong>Fortran 数组中的序号是从 1 开始的，即写作 n(1)<strong>，这点与其他高级编程语言略有不同，不过符合人类的数学认识。因此如下所示，当定义一个长度为 10 的数组 n 时，数组 n 的最后一个元素就是 n(10)。在实际的存储中，我们能够很容易理解一维数组是按照 1 到 10 的顺序从左往右排列的，但是在二维数组中又会是怎么样呢？是行优先还是列优先呢？一般来说，在我们接触过的高级编程语言中几乎都是行优先的，即先存储第一行再存储第二行，以此类推。但是，在 Fortran 中则是</strong>列优先</strong>的，也就是说 Fortran 的二维数组<strong>存储时会先存储第一列再存储第二列</strong>，再以此类推。</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs fortran"><span class="hljs-keyword">real</span> n(<span class="hljs-number">10</span>)     <span class="hljs-comment">! n(1) ~ n(10)</span><br><span class="hljs-keyword">real</span> m(<span class="hljs-number">4</span>, <span class="hljs-number">4</span>)   <span class="hljs-comment">! m(1, 1) m(2, 1) m(3, 1) ... m(4, 4)</span><br></code></pre></td></tr></table></figure><h5 id="小提示-3"><a href="#小提示-3" class="headerlink" title="小提示"></a>小提示</h5><p>如果我们在使用数组 n 的过程中忘记了加上序号，那么程序<strong>默认就会对整个数组的全部元素进行操作</strong>，而非像其他高级编程语言可能会指向数组的第一个元素。</p><p>当我们想要去选取数组中的某一个元素时，可以直接通过对应的序号进行选取。但是如果想要选多个元素或者某一行、某一列时，这就有点不同了。比如说，现在有一个长度为 10 的一维数组 n，我们想要获取到从第 3 个元素到第 5 个元素的 3 个元素，**应该使用 <code>:</code> 来将序号的上下限分隔开同时选中，即 n(3:5)**。如果有一个 3 行 x 4 列 的二维数组 m，我们想要获取到第 2 行到第 3 行的所有元素，则应该使用 m(2:3, 1:4) 来选取。</p><h2 id="跨行与注释"><a href="#跨行与注释" class="headerlink" title="跨行与注释"></a>跨行与注释</h2><p>有的时候我们编写的<strong>计算式可能会比较长</strong>，这个时候为了代码和公式的高可阅读性，我们通常采用 Fortran 语言所提供的跨行功能。比如说如下所示的原打印输出，就可以在<strong>中途使用 <code>&amp;</code> 符号来声明下一行是前一行的后续</strong>，这样的执行结果是一致的。</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs fortran"><span class="hljs-built_in">print</span> *, zhang, qian, sun, li, zhou, wu, zhen, wang<br><br><span class="hljs-comment">!!! 可以换成</span><br><span class="hljs-built_in">print</span> *, zhang, qian, sun, li &amp;<br>       , zhou, wu, zhen, wang<br></code></pre></td></tr></table></figure><p>上面的例子是变量的跨行输出，如果是一个长字符串，也是可以使用一样的方式的，<strong>只是需要在中断的前一行末尾和下一行开头同时加上 <code>&amp;</code> 符号</strong>，如下所示。</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs fortran"><span class="hljs-built_in">print</span> *, <span class="hljs-string">&#x27;Fortran is so good for the scientific calculation.&#x27;</span><br><br><span class="hljs-comment">!!! 可以换成</span><br><span class="hljs-built_in">print</span> *, <span class="hljs-string">&#x27;Fortran is so good &amp;</span><br><span class="hljs-string">          &amp;for the scientific calculation.&#x27;</span><br></code></pre></td></tr></table></figure><p>我们之前在定义变量的时候已经提过，为了代码整洁性可能会同时将同一类型的变量放置在同一行，之间用逗号分割即可。如果是在给变量赋值的时候，是不是也能够将赋值式放置在同一行呢？原则上来说，<strong>如果赋值式比较短的话，是可以将多行赋值式缩短在同一行的</strong>，它们之间使用 <code>;</code> 进行连接。这里值得注意的是，**最后一个赋值式后面一定不要多加 <code>;</code>**，如下所示。</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs fortran"><span class="hljs-comment">!!! 修改前</span><br>x = <span class="hljs-number">3</span><br>y = <span class="hljs-number">4</span><br>z = <span class="hljs-number">5</span><br><br><span class="hljs-comment">!!! 修改后</span><br>x = <span class="hljs-number">3</span>; y = <span class="hljs-number">4</span>; z = <span class="hljs-number">5</span><br></code></pre></td></tr></table></figure><p>Fortran 语言中的注释其实在上面的内容中也已经接触到了，**<code>!</code> 之后的内容将会被 Fortran 编译器认为是注释内容<strong>。一般来说，一个 <code>!</code> 的注释其实就已经足够了，但是为了区分行注释与行末注释，建议在</strong>行注释的时候使用三个 <code>!</code><strong>，而在</strong>行末注释时使用一个 <code>!</code>**。当然如果存在相邻多行同时进行注释，或者在一个可视窗口内有多个行末注释，建议协调成同一列以增强代码整洁性。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Fortran</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++ 多态</title>
    <link href="/2022/05/22/C++/"/>
    <url>/2022/05/22/C++/</url>
    
    <content type="html"><![CDATA[<p>​       有了虚函数，基类指针指向基类对象时就使用基类的成员（包括成员函数和成员变量），指向派生类对象时就 使用派生类的成员。换句话说，基类指针可以按照基类的方式来做事，也可以按照派生类的方式来做事，它有 多种形态，或者说有多种表现方式，我们将这种现象称为<strong>多态（Polymorphism）</strong>。</p><p>​       C++提供多态的目的是：可以通过基类指针对所有派生类（包括直接派生和间接派生）的成员变量和成员函数 进行“全方位”的访问，尤其是成员函数。如果没有多态，我们只能访问成员变量。</p><p>​       除了指针，<strong>引用也可以实现多态</strong>。不过引用不像指针灵活，指针可以随时改变指向，而引用只能指代固定的对象，在多态性方面缺乏表现力，所 以以后我们再谈及多态时一般是说指针。</p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
